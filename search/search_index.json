{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to FinOpt","text":"<p>FinOpt is a modular Python framework designed for intelligent financial planning. It combines stochastic simulation of income and investment returns with convex optimization to help users achieve their financial goals under uncertainty.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stochastic Income Modeling: Simulate fixed and variable income with growth, seasonality, and noise.</li> <li>Wealth Dynamics: Model the evolution of investment accounts using affine wealth representations.</li> <li>Goal-Oriented Optimization: Find the minimum time to achieve multiple financial goals (e.g., emergency funds, housing) with a specified level of confidence.</li> <li>Bilevel Optimization: Solve complex problems that minimize time while maximizing terminal wealth.</li> <li>Extensible Architecture: Modular design allows for custom return models, optimizers, and goal types.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Using Conda (recommended)\nconda env create -f environment.yml\nconda activate finance\n\n# Install CVXPY for convex optimization\npip install cvxpy\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from finopt import FinancialModel, Account, IncomeModel, FixedIncome\nfrom finopt.goals import TerminalGoal\nfrom finopt.optimization import CVaROptimizer\n\n# Define income and accounts\nincome = IncomeModel(fixed=FixedIncome(base=1_500_000, annual_growth=0.03))\naccounts = [\n    Account.from_annual(\"Conservative\", annual_return=0.08, annual_volatility=0.09),\n    Account.from_annual(\"Aggressive\", annual_return=0.14, annual_volatility=0.15)\n]\n\n# Create model and optimize\nmodel = FinancialModel(income, accounts)\ngoals = [TerminalGoal(account=\"Aggressive\", threshold=5_000_000, confidence=0.80)]\n\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\nresult = model.optimize(goals=goals, optimizer=optimizer, T_max=120, n_sims=500, seed=42)\n\n# Visualize results\nmodel.plot(\"wealth\", result=result, show_trajectories=True)\n</code></pre>"},{"location":"#documentation-roadmap","title":"Documentation Roadmap","text":"<p>Explore the technical components of the FinOpt framework:</p>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Stochastic Returns: Generating correlated lognormal returns for simulation.</li> <li>Income Module: Modeling fixed and variable cash flows with growth and seasonality.</li> <li>Portfolio Dynamics: The mathematics of wealth evolution and affine representations.</li> <li>Scheduled Withdrawals: Integration of planned cash outflows into the wealth equation.</li> </ul>"},{"location":"#optimization-logic","title":"Optimization &amp; Logic","text":"<ul> <li>Goals Framework: Defining financial milestones as probabilistic chance constraints.</li> <li>Optimization: Technical details on CVaR reformulation and Sample Average Approximation (SAA) solvers.</li> </ul>"},{"location":"#integration-architecture","title":"Integration &amp; Architecture","text":"<ul> <li>Unified Model: The <code>FinancialModel</code> facade that orchestrates all system components.</li> <li>Technical Framework: A deep dive into the system architecture, design principles, and mathematical foundations.</li> </ul>"},{"location":"#advanced-utilities","title":"Advanced &amp; Utilities","text":"<ul> <li>Exceptions: Error handling and custom exception classes.</li> <li>Serialization: Saving and loading models and scenarios.</li> <li>Shared Utilities: Common helper functions and numerical routines.</li> </ul>"},{"location":"exceptions/","title":"<code>exceptions</code> \u2014 Error Handling for FinOpt","text":"<p>Core idea: Provide a unified exception hierarchy for consistent error handling across all FinOpt modules. All exceptions inherit from <code>FinOptError</code>, enabling catch-all handling when needed while maintaining specific error types for precise debugging.</p>"},{"location":"exceptions/#why-a-dedicated-exceptions-module","title":"Why a dedicated exceptions module?","text":"<ul> <li>Consistency: All FinOpt errors share a common base class</li> <li>Precision: Specific exception types for different failure modes</li> <li>Debugging: Descriptive error messages with actionable suggestions</li> <li>Integration: Clean separation between FinOpt errors and Python built-ins</li> </ul>"},{"location":"exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>FinOptError (base)\n\u251c\u2500\u2500 ConfigurationError      # Invalid configuration or parameters\n\u251c\u2500\u2500 ValidationError         # Data validation failures\n\u2502   \u251c\u2500\u2500 TimeIndexError          # Month/date indexing errors\n\u2502   \u2514\u2500\u2500 AllocationConstraintError   # Allocation policy violations\n\u251c\u2500\u2500 OptimizationError       # Solver failures\n\u2502   \u2514\u2500\u2500 InfeasibleError         # No feasible solution exists\n\u2514\u2500\u2500 MemoryLimitError        # Memory limit exceeded\n</code></pre>"},{"location":"exceptions/#exception-classes","title":"Exception Classes","text":""},{"location":"exceptions/#finopterror","title":"<code>FinOptError</code>","text":"<p>Base exception for all FinOpt errors. Use this to catch any FinOpt-specific error.</p> <pre><code>from finopt.exceptions import FinOptError\n\ntry:\n    result = model.optimize(goals)\nexcept FinOptError as e:\n    logger.error(f\"FinOpt error: {e}\")\n</code></pre>"},{"location":"exceptions/#configurationerror","title":"<code>ConfigurationError</code>","text":"<p>Invalid configuration or parameters.</p> <p>Raised when: - Invalid <code>annual_growth</code> values (must be &gt; -1) - Incompatible parameter combinations - Missing required configuration fields</p> <pre><code>from finopt.exceptions import ConfigurationError\n\n# Example: Invalid annual growth\nraise ConfigurationError(\n    \"annual_growth must be &gt; -1, got -2.0. \"\n    \"Value &lt;= -1 would cause income to become zero or negative.\"\n)\n</code></pre> <p>Common causes: - <code>FixedIncome(annual_growth=-1.5)</code> \u2014 growth rate too negative - <code>Account.from_annual(annual_return=-1.1, ...)</code> \u2014 return below -100%</p>"},{"location":"exceptions/#validationerror","title":"<code>ValidationError</code>","text":"<p>Data validation failures.</p> <p>Raised when: - Invalid array shapes - Out-of-bounds values - Constraint violations</p> <pre><code>from finopt.exceptions import ValidationError\n\n# Example: Invalid horizon\nraise ValidationError(\n    f\"T must be positive, got {T}. \"\n    f\"Use T &gt;= 1 for valid return simulations.\"\n)\n</code></pre> <p>Common causes: - <code>model.simulate(T=-5)</code> \u2014 negative horizon - <code>X.shape != (T, M)</code> \u2014 allocation policy shape mismatch - <code>confidence &gt; 1.0</code> \u2014 probability out of range</p>"},{"location":"exceptions/#timeindexerror","title":"<code>TimeIndexError</code>","text":"<p>Month/date indexing errors. Subclass of <code>ValidationError</code>.</p> <p>Raised when: - Month out of valid range - Date before simulation start - Inconsistent date/month specifications</p> <pre><code>from finopt.exceptions import TimeIndexError\n\n# Example: Withdrawal before simulation\nraise TimeIndexError(\n    f\"Withdrawal month {month} is before simulation start (month 1). \"\n    f\"Months are 1-indexed: month 1 = end of first simulation month.\"\n)\n</code></pre> <p>Common causes: - <code>IntermediateGoal(date=date(2024, 1, 1))</code> with <code>start=date(2025, 1, 1)</code> \u2014 goal before start - <code>WithdrawalEvent(month=0)</code> \u2014 month must be \u2265 1 - Goal month exceeds horizon T</p>"},{"location":"exceptions/#allocationconstrainterror","title":"<code>AllocationConstraintError</code>","text":"<p>Allocation policy constraint violations. Subclass of <code>ValidationError</code>.</p> <p>Raised when: - Negative allocations (\\(x_t^m &lt; 0\\)) - Simplex violations (\\(\\sum_m x_t^m \\neq 1\\)) - Invalid allocation array shape</p> <pre><code>from finopt.exceptions import AllocationConstraintError\n\n# Example: Negative allocation\nraise AllocationConstraintError(\n    f\"Allocation X has negative values at positions: {negative_locs}. \"\n    f\"Min value: {X.min():.6f}. Allocations must be non-negative.\"\n)\n</code></pre> <p>Common causes: - Manual allocation with <code>X[t, m] = -0.1</code> - Rounding errors after optimization (use tolerance) - Row sums not equal to 1.0</p>"},{"location":"exceptions/#optimizationerror","title":"<code>OptimizationError</code>","text":"<p>Optimization solver failures.</p> <p>Raised when: - Solver convergence failure - Numerical instability - Unexpected solver status</p> <pre><code>from finopt.exceptions import OptimizationError\n\n# Example: Solver failure\nraise OptimizationError(\n    f\"Solver returned unexpected status: {prob.status}. \"\n    f\"Try adjusting solver settings or using a different solver.\"\n)\n</code></pre> <p>Common causes: - Ill-conditioned problem (extreme parameter values) - Solver timeout - Numerical precision issues with very large wealth values</p>"},{"location":"exceptions/#infeasibleerror","title":"<code>InfeasibleError</code>","text":"<p>No feasible solution exists. Subclass of <code>OptimizationError</code>.</p> <p>Raised when: - Goals cannot be achieved within the horizon - Withdrawal constraints cannot be satisfied - Conflicting constraint requirements</p> <pre><code>from finopt.exceptions import InfeasibleError\n\n# Example: No feasible solution\nraise InfeasibleError(\n    f\"No feasible solution found in T \u2208 [{T_min}, {T_max}]. \"\n    f\"Consider: (1) increasing T_max, (2) relaxing goal thresholds, \"\n    f\"(3) reducing withdrawal amounts, (4) increasing epsilon tolerances.\"\n)\n</code></pre> <p>Common causes: - Goal threshold too high for available contributions - Withdrawal exceeds projected wealth - Intermediate goal conflicts with terminal goal - <code>confidence</code> too high (e.g., 0.99 may be infeasible)</p> <p>Recovery strategies: 1. Increase <code>T_max</code> to allow more time for wealth accumulation 2. Lower goal <code>threshold</code> values 3. Reduce <code>confidence</code> levels (e.g., 0.90 \u2192 0.80) 4. Reduce or reschedule withdrawal amounts 5. Increase contribution rates</p>"},{"location":"exceptions/#memorylimiterror","title":"<code>MemoryLimitError</code>","text":"<p>Memory limit exceeded.</p> <p>Raised when: - Large accumulation factor arrays - Too many Monte Carlo scenarios - Excessive horizon length</p> <pre><code>from finopt.exceptions import MemoryLimitError\n\n# Example: Memory exceeded\nraise MemoryLimitError(\n    f\"Accumulation factors would require {memory_gb:.1f} GB. \"\n    f\"Use LazyAccumulationFactors for large problems, or reduce: \"\n    f\"n_sims={n_sims}, T={T}, M={M}\"\n)\n</code></pre> <p>Common causes: - <code>n_sims=10000</code> with <code>T=240</code> and <code>M=5</code> \u2014 very large scenario matrix - Pre-computing all accumulation factors for long horizons</p> <p>Recovery strategies: 1. Reduce <code>n_sims</code> (e.g., 500 is often sufficient) 2. Use lazy evaluation for accumulation factors 3. Reduce horizon <code>T</code> if possible 4. Process in batches</p>"},{"location":"exceptions/#usage-patterns","title":"Usage Patterns","text":""},{"location":"exceptions/#a-catch-all-finopt-errors","title":"A) Catch all FinOpt errors","text":"<pre><code>from finopt.exceptions import FinOptError\n\ntry:\n    result = model.optimize(goals=goals, T_max=120)\nexcept FinOptError as e:\n    print(f\"FinOpt encountered an error: {e}\")\n    # Log, notify user, or attempt recovery\n</code></pre>"},{"location":"exceptions/#b-handle-specific-error-types","title":"B) Handle specific error types","text":"<pre><code>from finopt.exceptions import (\n    InfeasibleError,\n    ValidationError,\n    OptimizationError\n)\n\ntry:\n    result = model.optimize(goals=goals, T_max=60)\nexcept InfeasibleError as e:\n    print(f\"Goals are not achievable: {e}\")\n    # Suggest relaxing constraints\nexcept ValidationError as e:\n    print(f\"Invalid input: {e}\")\n    # Fix input data\nexcept OptimizationError as e:\n    print(f\"Solver failed: {e}\")\n    # Try different solver\n</code></pre>"},{"location":"exceptions/#c-re-raise-with-context","title":"C) Re-raise with context","text":"<pre><code>from finopt.exceptions import ValidationError\n\ndef validate_goals(goals, accounts):\n    for goal in goals:\n        if goal.account not in [a.name for a in accounts]:\n            raise ValidationError(\n                f\"Goal references unknown account '{goal.account}'. \"\n                f\"Available accounts: {[a.name for a in accounts]}\"\n            )\n</code></pre>"},{"location":"exceptions/#d-conditional-recovery-for-infeasibility","title":"D) Conditional recovery for infeasibility","text":"<pre><code>from finopt.exceptions import InfeasibleError\n\ndef optimize_with_fallback(model, goals, T_max=60):\n    try:\n        return model.optimize(goals=goals, T_max=T_max)\n    except InfeasibleError:\n        # Try with extended horizon\n        print(f\"Infeasible at T_max={T_max}, trying T_max={T_max*2}\")\n        return model.optimize(goals=goals, T_max=T_max*2)\n</code></pre>"},{"location":"exceptions/#module-usage-in-finopt","title":"Module Usage in FinOpt","text":"Module Exceptions Used <code>income.py</code> <code>ValidationError</code>, <code>ConfigurationError</code> <code>portfolio.py</code> <code>ValidationError</code>, <code>AllocationConstraintError</code> <code>goals.py</code> <code>ValidationError</code>, <code>TimeIndexError</code> <code>withdrawal.py</code> <code>ValidationError</code>, <code>TimeIndexError</code> <code>optimization.py</code> <code>OptimizationError</code>, <code>InfeasibleError</code>, <code>ValidationError</code> <code>model.py</code> <code>ValidationError</code>, <code>MemoryLimitError</code> <code>returns.py</code> <code>ValidationError</code>"},{"location":"exceptions/#api-summary","title":"API Summary","text":"Exception Parent Purpose <code>FinOptError</code> <code>Exception</code> Base class for all FinOpt errors <code>ConfigurationError</code> <code>FinOptError</code> Invalid configuration or parameters <code>ValidationError</code> <code>FinOptError</code> Data validation failures <code>TimeIndexError</code> <code>ValidationError</code> Month/date indexing errors <code>AllocationConstraintError</code> <code>ValidationError</code> Allocation policy violations <code>OptimizationError</code> <code>FinOptError</code> Solver failures <code>InfeasibleError</code> <code>OptimizationError</code> No feasible solution exists <code>MemoryLimitError</code> <code>FinOptError</code> Memory limit exceeded"},{"location":"framework/","title":"FinOpt \u2014 Technical Framework","text":"<p>Tagline: Intelligent financial planning through stochastic simulation and convex optimization under uncertainty.</p> <p>This document describes the theoretical and technical framework of FinOpt, a modular system that connects user objectives (emergency funds, housing, retirement) with optimal investment strategies under stochastic income, returns, and withdrawals via chance-constrained optimization.</p>"},{"location":"framework/#0-system-architecture","title":"0. System Architecture","text":"<p>FinOpt is composed of nine core modules:</p> Module Purpose Key Abstractions <code>income.py</code> Cash flow modeling <code>FixedIncome</code>, <code>VariableIncome</code>, <code>IncomeModel</code> <code>portfolio.py</code> Wealth dynamics <code>Account</code>, <code>Portfolio</code> (affine wealth executor) <code>returns.py</code> Stochastic returns <code>ReturnModel</code> (correlated lognormal) <code>goals.py</code> Goal specification <code>IntermediateGoal</code>, <code>TerminalGoal</code>, <code>GoalSet</code> <code>withdrawal.py</code> Cash outflows <code>WithdrawalEvent</code>, <code>StochasticWithdrawal</code>, <code>WithdrawalModel</code> <code>optimization.py</code> Solvers <code>CVaROptimizer</code>, <code>GoalSeeker</code> <code>model.py</code> Orchestration <code>FinancialModel</code> (unified facade) <code>serialization.py</code> Persistence <code>save_model</code>, <code>load_model</code>, <code>save_scenario</code> <code>config.py</code> Configuration Pydantic configs for type-safe parameters <p>Supporting modules:</p> Module Purpose <code>utils.py</code> Rate conversions, formatters, metrics <code>exceptions.py</code> Error hierarchy (<code>FinOptError</code>, <code>InfeasibleError</code>, etc.) <code>types.py</code> Type definitions (<code>MonthlyContributionDict</code>, etc.) <p>Dependency graph: <pre><code>model.py (FinancialModel)\n    \u251c\u2500\u2192 income.py (IncomeModel)\n    \u251c\u2500\u2192 portfolio.py (Portfolio)\n    \u251c\u2500\u2192 returns.py (ReturnModel)\n    \u251c\u2500\u2192 withdrawal.py (WithdrawalModel)\n    \u2514\u2500\u2192 optimization.py (GoalSeeker)\n            \u251c\u2500\u2192 goals.py (GoalSet)\n            \u2514\u2500\u2192 CVaROptimizer\n\nserialization.py \u2190\u2192 config.py\n         \u2193\n    All modules (to_dict/from_dict)\n\nutils.py \u2190\u2500\u2500 All modules\nexceptions.py \u2190\u2500\u2500 All modules\n</code></pre></p> <p>Design principles: - Loose coupling: Each module usable independently - Lazy imports: Optimization only loaded when needed (TYPE_CHECKING) - Separation of concerns: Portfolio executes dynamics, doesn't generate returns - Reproducibility: Explicit seed management with automatic propagation - Convexity: CVaR reformulation preserves convexity for global optimality</p>"},{"location":"framework/#1-income-module","title":"1. Income Module","text":"<p>Total monthly income at time \\(t\\) is composed of fixed and variable parts:</p> \\[ Y_t = y_t^{\\text{fixed}} + Y_t^{\\text{variable}} \\] <p>Note: Either component can be <code>None</code> (at least one required).</p>"},{"location":"framework/#11-fixed-income","title":"1.1 Fixed Income","text":"<p>The fixed component reflects baseline salary subject to compounded annual growth \\(g\\) and scheduled raises:</p> \\[ y_t^{\\text{fixed}} = \\text{current\\_salary}(t) \\cdot (1+m)^{\\Delta t} \\] <p>where \\(m = (1 + g)^{1/12} - 1\\) is the monthly compounded rate.</p> <p>API: <pre><code>fixed = FixedIncome(\n    base=1_400_000,                    # Current monthly salary\n    annual_growth=0.03,                # 3% annual growth\n    salary_raises={                    # Date-based raises\n        date(2025, 7, 1): 200_000,\n        date(2026, 1, 1): 150_000\n    }\n)\n</code></pre></p>"},{"location":"framework/#12-variable-income","title":"1.2 Variable Income","text":"<p>The variable component models irregular income with:</p> <ul> <li>Seasonality: \\(s \\in \\mathbb{R}^{12}\\) (multiplicative monthly factors)</li> <li>Noise: \\(\\epsilon_t \\sim \\mathcal{N}(0, \\sigma^2)\\) (Gaussian shocks)</li> <li>Growth: compounded rate \\(m\\) applied to base income</li> <li>Boundaries: optional floor and cap constraints</li> </ul> \\[ \\tilde{Y}_t = \\max(\\text{floor},\\ \\mu_t (1 + \\epsilon_t)), \\quad \\text{where } \\mu_t = \\text{base} \\cdot (1 + m)^t \\cdot s_{(t \\bmod 12)} \\] <p>API: <pre><code>variable = VariableIncome(\n    base=200_000,\n    sigma=0.15,\n    seasonality=[1.0, 0.95, 1.05, ...],  # 12-month cycle\n    floor=50_000,\n    cap=400_000,\n    annual_growth=0.02,\n    seed=42\n)\n</code></pre></p>"},{"location":"framework/#13-contributions","title":"1.3 Contributions","text":"<p>A fraction of income is allocated monthly via calendar-rotating schedules:</p> \\[ A_t = \\alpha_{(t \\bmod 12)}^{f} \\cdot y_t^{\\text{fixed}} + \\alpha_{(t \\bmod 12)}^{v} \\cdot Y_t^{\\text{variable}} \\] <p>where \\(\\alpha^f, \\alpha^v \\in [0,1]^{12}\\) control fixed/variable contribution rates (default: 30% fixed, 100% variable).</p> <p>Vectorized API: <pre><code>income = IncomeModel(fixed=fixed, variable=variable)\nincome.monthly_contribution = {\"fixed\": [0.35]*12, \"variable\": [1.0]*12}\n\n# Single realization\nA = income.contributions(months=24, start=date(2025, 1, 1))\n\n# Monte Carlo (vectorized)\nA = income.contributions(months=24, start=date(2025, 1, 1), n_sims=500, output=\"array\")\n# \u2192 shape: (500, 24)\n</code></pre></p>"},{"location":"framework/#2-portfolio-dynamics","title":"2. Portfolio Dynamics","text":""},{"location":"framework/#21-wealth-evolution-with-withdrawals","title":"2.1 Wealth Evolution with Withdrawals","text":"<p>Multiple accounts \\(m \\in \\mathcal{M} = \\{1,\\dots,M\\}\\) evolve via:</p> \\[ \\boxed{W_{t+1}^m = \\big(W_t^m + A_t x_t^m - D_t^m\\big)(1 + R_t^m)} \\] <p>where: - \\(W_t^m\\) = wealth in account \\(m\\) at start of month \\(t\\) - \\(A_t x_t^m\\) = allocated contribution (\\(x_t^m\\) fraction of total \\(A_t\\)) - \\(D_t^m\\) = withdrawal from account \\(m\\) during month \\(t\\) - \\(R_t^m\\) = stochastic return of account \\(m\\)</p> <p>Timing convention: Withdrawal occurs at start of month (before returns applied).</p> <p>API: <pre><code>accounts = [\n    Account.from_annual(\"Conservador\", annual_return=0.06,\n                        annual_volatility=0.08, initial_wealth=1_000_000,\n                        display_name=\"Fondo Conservador\"),\n    Account.from_annual(\"Agresivo\", annual_return=0.12,\n                        annual_volatility=0.15, initial_wealth=500_000)\n]\nportfolio = Portfolio(accounts)\n</code></pre></p>"},{"location":"framework/#22-allocation-policy","title":"2.2 Allocation Policy","text":"<p>Contributions allocated via decision variables \\(x_t^m \\in [0,1]\\) satisfying:</p> \\[ \\sum_{m=1}^M x_t^m = 1, \\quad x_t^m \\ge 0, \\quad \\forall t \\] <p>The allocation simplex at horizon \\(T\\):</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} : x_t^m \\ge 0,\\ \\sum_{m=1}^M x_t^m = 1,\\ \\forall t \\right\\} \\]"},{"location":"framework/#23-affine-wealth-representation","title":"2.3 Affine Wealth Representation","text":"<p>Recursive wealth can be expressed in closed-form:</p> \\[ \\boxed{W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s x_s^m - D_s^m\\big) F_{s,t}^m} \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Key insight: Withdrawals \\(D\\) are parameters (not decision variables), so wealth remains affine in \\(X\\), preserving convexity for optimization.</p> <p>Implementation: <pre><code>result = portfolio.simulate(A=A, R=R, X=X, D=D, method=\"affine\")\nW = result.wealth  # (n_sims, T+1, M)\n</code></pre></p>"},{"location":"framework/#3-withdrawal-module","title":"3. Withdrawal Module","text":""},{"location":"framework/#31-withdrawal-types","title":"3.1 Withdrawal Types","text":"<p>Scheduled Withdrawals (deterministic): <pre><code>event = WithdrawalEvent(\n    account=\"Conservador\",\n    amount=400_000,\n    date=date(2025, 6, 1),\n    description=\"Compra bicicleta\"\n)\nschedule = WithdrawalSchedule(events=[event, ...])\n</code></pre></p> <p>Stochastic Withdrawals (uncertain): <pre><code>stochastic = StochasticWithdrawal(\n    account=\"Conservador\",\n    base_amount=300_000,\n    sigma=50_000,\n    date=date(2025, 9, 1),\n    floor=200_000,\n    cap=500_000,\n    seed=42\n)\n</code></pre></p> <p>Unified Model: <pre><code>withdrawals = WithdrawalModel(\n    scheduled=schedule,\n    stochastic=[stochastic]\n)\n\n# Generate withdrawal scenarios\nD = withdrawals.to_array(T=36, start_date=date(2025, 1, 1),\n                         accounts=accounts, n_sims=500, seed=42)\n# \u2192 shape: (500, 36, 2)\n</code></pre></p>"},{"location":"framework/#32-withdrawal-feasibility","title":"3.2 Withdrawal Feasibility","text":"<p>The optimizer adds CVaR constraints to ensure sufficient wealth:</p> \\[ \\mathbb{P}(W_t^m \\geq D_t^m) \\geq 1 - \\epsilon \\] <p>Default: <code>withdrawal_epsilon=0.05</code> (95% confidence).</p>"},{"location":"framework/#4-goals-framework","title":"4. Goals Framework","text":""},{"location":"framework/#41-goal-types","title":"4.1 Goal Types","text":"<p>Intermediate Goal (fixed calendar date): <pre><code>IntermediateGoal(\n    account=\"Conservador\",\n    threshold=5_500_000,\n    confidence=0.90,\n    date=date(2026, 1, 1)  # Calendar date (not month offset)\n)\n</code></pre></p> <p>Mathematical constraint:</p> \\[ \\mathbb{P}\\big(W_{t}^m \\ge b\\big) \\ge 1-\\varepsilon \\] <p>Terminal Goal (variable horizon): <pre><code>TerminalGoal(\n    account=\"Agresivo\",\n    threshold=30_000_000,\n    confidence=0.85\n)\n</code></pre></p> <p>Mathematical constraint:</p> \\[ \\mathbb{P}\\big(W_{T}^m \\ge b\\big) \\ge 1-\\varepsilon \\] <p>where \\(T\\) is the optimization horizon (decision variable).</p>"},{"location":"framework/#42-goal-set","title":"4.2 Goal Set","text":"<p>The goal set \\(\\mathcal{G}\\) is partitioned into:</p> \\[ \\mathcal{G} = \\mathcal{G}_{\\text{int}} \\cup \\mathcal{G}_{\\text{term}} \\] <p>Properties: 1. Minimum horizon: \\(T \\geq T_{\\min} := \\max_{g \\in \\mathcal{G}_{\\text{int}}} t_g\\) 2. Calendar resolution: Dates \u2192 month offsets via <code>resolve_month(start_date)</code> 3. Account mapping: Names \u2192 indices via <code>GoalSet</code></p> <p>Utility functions: <pre><code>from finopt.goals import check_goals, goal_progress, print_goal_status\n\n# Validate goal satisfaction\nmetrics = check_goals(result, goals, accounts, start_date)\n\n# Compute VaR-based progress\nprogress = goal_progress(result, goals, accounts, start_date)\n\n# Pretty-print status\nprint_goal_status(result, goals, accounts, start_date)\n</code></pre></p>"},{"location":"framework/#5-optimization-framework","title":"5. Optimization Framework","text":""},{"location":"framework/#51-bilevel-problem","title":"5.1 Bilevel Problem","text":"<p>Find the minimum time \\(T^*\\) to achieve all goals:</p> \\[ \\boxed{\\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\mathcal{F}_T \\neq \\emptyset} \\] <p>where the goal-feasible set at horizon \\(T\\) is:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\text{CVaR}_{\\varepsilon}(b_t^m - W_t^m(X)) \\leq 0, \\; \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\text{CVaR}_{\\varepsilon}(b^m - W_T^m(X)) \\leq 0, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\\\ &amp; \\text{CVaR}_{\\epsilon_w}(D_t^m - W_t^m(X)) \\leq 0, \\; \\forall \\text{withdrawals} \\end{aligned} \\right\\} \\]"},{"location":"framework/#52-cvar-reformulation","title":"5.2 CVaR Reformulation","text":"<p>Challenge: Chance constraint \\(\\mathbb{P}(W \\geq b) \\geq 1-\\varepsilon\\) is non-convex.</p> <p>Solution: CVaR reformulation (Rockafellar &amp; Uryasev 2000):</p> \\[ \\mathbb{P}(W \\geq b) \\geq 1-\\varepsilon \\quad \\Longleftrightarrow \\quad \\text{CVaR}_\\varepsilon(b - W) \\leq 0 \\] <p>Epigraphic form (LP-compatible):</p> \\[ \\gamma + \\frac{1}{\\varepsilon N}\\sum_{i=1}^N z_i \\leq 0, \\quad z_i \\geq b - W^{(i)} - \\gamma, \\quad z_i \\geq 0 \\] <p>Key property: Preserves convexity because \\(W(X)\\) is affine in \\(X\\).</p>"},{"location":"framework/#53-cvaroptimizer","title":"5.3 CVaROptimizer","text":"<pre><code>from finopt.optimization import CVaROptimizer\n\noptimizer = CVaROptimizer(\n    n_accounts=2,\n    objective=\"balanced\",     # \"risky\", \"balanced\", \"conservative\", \"risky_turnover\"\n    solver=\"CLARABEL\",        # Default solver (or \"ECOS\", \"SCS\", \"MOSEK\")\n    verbose=True\n)\n</code></pre> <p>Objectives:</p> Objective Formula Type <code>\"risky\"</code> \\(\\mathbb{E}[\\sum_m W_T^m]\\) LP <code>\"balanced\"</code> \\(-\\sum_{t,m}(\\Delta x_{t,m})^2\\) QP (turnover penalty) <code>\"conservative\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\cdot \\text{Std}(W_T)\\) QP <code>\"risky_turnover\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\sum(\\Delta x)^2\\) QP"},{"location":"framework/#54-goalseeker-bilevel-solver","title":"5.4 GoalSeeker (Bilevel Solver)","text":"<pre><code>from finopt.optimization import GoalSeeker\n\nseeker = GoalSeeker(\n    optimizer,\n    T_max=120,\n    search_method=\"binary\",  # or \"linear\"\n    verbose=True\n)\n\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=W0,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    D_generator=D_gen,           # Optional withdrawals\n    withdrawal_epsilon=0.05\n)\n</code></pre> <p>Search methods: - <code>\"binary\"</code>: Binary search over \\([T_{\\min}, T_{\\max}]\\) \u2014 faster for large ranges - <code>\"linear\"</code>: Linear search from \\(T_{\\min}\\) \u2014 finds exact minimum</p>"},{"location":"framework/#6-integration-financialmodel","title":"6. Integration: FinancialModel","text":""},{"location":"framework/#61-unified-facade","title":"6.1 Unified Facade","text":"<pre><code>from finopt.model import FinancialModel\n\nmodel = FinancialModel(\n    income=income,\n    accounts=accounts,\n    default_correlation=None,  # Return correlation matrix\n    enable_cache=True\n)\n</code></pre>"},{"location":"framework/#62-core-methods","title":"6.2 Core Methods","text":""},{"location":"framework/#simulation","title":"Simulation","text":"<pre><code>result = model.simulate(\n    T=36,\n    X=X,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals  # Optional WithdrawalModel\n)\n# Returns: SimulationResult\n</code></pre>"},{"location":"framework/#optimization","title":"Optimization","text":"<pre><code>result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    search_method=\"binary\"\n)\n# Returns: OptimizationResult\n</code></pre>"},{"location":"framework/#re-simulation-from-optimization","title":"Re-simulation from Optimization","text":"<pre><code>sim_result = model.simulate_from_optimization(\n    opt_result,\n    n_sims=1000,\n    seed=999\n)\n</code></pre>"},{"location":"framework/#validation","title":"Validation","text":"<pre><code>status = model.verify_goals(result, goals)\n</code></pre>"},{"location":"framework/#63-seed-propagation","title":"6.3 Seed Propagation","text":"<pre><code>User seed\n    \u251c\u2500\u2192 Income: seed\n    \u251c\u2500\u2192 Returns: seed + 1\n    \u2514\u2500\u2192 Withdrawals: seed + 2\n</code></pre> <p>Rationale: Statistical independence between income, return, and withdrawal shocks.</p>"},{"location":"framework/#7-serialization","title":"7. Serialization","text":""},{"location":"framework/#71-model-persistence","title":"7.1 Model Persistence","text":"<pre><code>from finopt.serialization import save_model, load_model\nfrom pathlib import Path\n\n# Save\nsave_model(model, Path(\"config.json\"))\n\n# Load\nmodel = load_model(Path(\"config.json\"))\n</code></pre>"},{"location":"framework/#72-scenario-persistence","title":"7.2 Scenario Persistence","text":"<pre><code>from finopt.serialization import save_scenario, load_scenario\n\nsave_scenario(\n    scenario_name=\"Plan de Retiro\",\n    goals=goals,\n    path=Path(\"scenarios/retirement.json\"),\n    model=model,\n    withdrawals=withdrawals,\n    start_date=date(2025, 1, 1),\n    n_sims=1000,\n    seed=42,\n    T_max=120\n)\n\nscenario = load_scenario(Path(\"scenarios/retirement.json\"))\n</code></pre>"},{"location":"framework/#8-complete-workflow-example","title":"8. Complete Workflow Example","text":"<pre><code>from datetime import date\nfrom finopt.model import FinancialModel\nfrom finopt.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.portfolio import Account\nfrom finopt.goals import IntermediateGoal, TerminalGoal\nfrom finopt.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\nfrom finopt.optimization import CVaROptimizer\n\n# 1. Define income\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000, annual_growth=0.03),\n    variable=VariableIncome(base=200_000, sigma=0.15, seed=42)\n)\n\n# 2. Define accounts\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08, initial_wealth=1_000_000),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15, initial_wealth=500_000)\n]\n\n# 3. Define withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule([\n        WithdrawalEvent(\"Conservador\", 5_000_000, date(2027, 1, 1), \"Pie departamento\")\n    ])\n)\n\n# 4. Define goals\ngoals = [\n    IntermediateGoal(account=\"Conservador\", threshold=8_000_000,\n                     confidence=0.90, date=date(2026, 6, 1)),\n    TerminalGoal(account=\"Agresivo\", threshold=30_000_000, confidence=0.85)\n]\n\n# 5. Create model\nmodel = FinancialModel(income, accounts)\n\n# 6. Optimize\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\nopt_result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    search_method=\"binary\"\n)\n\nprint(f\"Optimal horizon: T*={opt_result.T} months\")\nprint(f\"Feasible: {opt_result.feasible}\")\n\n# 7. Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)\nstatus = model.verify_goals(sim_result, goals)\n\n# 8. Visualize\nmodel.plot(\"wealth\", result=sim_result, goals=goals,\n           start=date(2025, 1, 1), show_trajectories=True)\n</code></pre>"},{"location":"framework/#9-key-mathematical-results","title":"9. Key Mathematical Results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\):</p> \\[ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m \\] <p>is affine in \\(X\\) (withdrawals \\(D\\) are parameters).</p> <p>Proposition 2 (CVaR Convexity): The constraint \\(\\text{CVaR}_\\varepsilon(b - W(X)) \\leq 0\\) is convex in \\(X\\) when \\(W(X)\\) is affine.</p> <p>Proposition 3 (Analytical Gradient):</p> \\[ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t \\] <p>Proposition 4 (Global Optimality): CVaR reformulation with affine wealth yields a convex program \u2192 global optimum guaranteed.</p>"},{"location":"framework/#10-implementation-details","title":"10. Implementation Details","text":""},{"location":"framework/#101-wealth-array-indexing","title":"10.1 Wealth Array Indexing","text":"<p>Shape: <code>(n_sims, T+1, M)</code> using start-of-period semantics: - <code>wealth[i, 0, m]</code> = \\(W_0^m\\) (initial wealth) - <code>wealth[i, t, m]</code> = \\(W_t^m\\) (wealth at start of period \\(t\\)) - <code>wealth[i, T, m]</code> = terminal wealth</p>"},{"location":"framework/#102-month-resolution","title":"10.2 Month Resolution","text":"<p>Goals and withdrawals use 1-indexed months: - <code>resolve_month(date(2025, 6, 1), start=date(2025, 1, 1))</code> \u2192 6 - Array index = month - 1 = 5</p>"},{"location":"framework/#103-memory-management","title":"10.3 Memory Management","text":"<p>Accumulation factors: \\(F \\in \\mathbb{R}^{N \\times (T+1) \\times (T+1) \\times M}\\)</p> <p>Estimates: - \\(N=500, T=24, M=2\\): ~115 MB - \\(N=500, T=120, M=5\\): ~14 GB</p> <p>Mitigation: - Use <code>method=\"recursive\"</code> for large \\(T\\) - Process in batches</p>"},{"location":"framework/#11-extensions-and-future-work","title":"11. Extensions and Future Work","text":""},{"location":"framework/#implemented","title":"Implemented","text":"<ul> <li>Multi-account portfolios with correlated returns</li> <li>Intermediate and terminal goals with CVaR constraints</li> <li>Withdrawal support (scheduled + stochastic)</li> <li>Binary/linear search for horizon optimization</li> <li>Calendar alignment for seasonality</li> <li>Seed propagation for reproducibility</li> <li>JSON serialization for persistence</li> </ul>"},{"location":"framework/#roadmap","title":"Roadmap","text":"<ul> <li>AR(1) temporal dependence in returns</li> <li>Transaction costs</li> <li>Tax-aware optimization</li> <li>GPU acceleration</li> <li>Multi-period rebalancing</li> </ul>"},{"location":"framework/#references","title":"References","text":"<ul> <li>CVaR reformulation: Rockafellar &amp; Uryasev (2000), \"Optimization of Conditional Value-at-Risk\"</li> <li>Affine wealth dynamics: Standard MPC technique exploiting linearity</li> <li>Bilevel optimization: Outer search + inner convex program</li> </ul>"},{"location":"framework/#appendix-quick-reference","title":"Appendix: Quick Reference","text":""},{"location":"framework/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>IncomeModel\n    \u251c\u2500 FixedIncome (frozen dataclass)\n    \u2514\u2500 VariableIncome (frozen dataclass)\n\nPortfolio\n    \u2514\u2500 Account\n\nReturnModel\n\nWithdrawalModel\n    \u251c\u2500 WithdrawalSchedule\n    \u2502   \u2514\u2500 WithdrawalEvent (frozen dataclass)\n    \u2514\u2500 StochasticWithdrawal (frozen dataclass)\n\nGoalSet\n    \u251c\u2500 IntermediateGoal (frozen dataclass)\n    \u2514\u2500 TerminalGoal (frozen dataclass)\n\nCVaROptimizer\nGoalSeeker\n\nFinancialModel (facade)\n\nExceptions:\n    FinOptError\n    \u251c\u2500 ConfigurationError\n    \u251c\u2500 ValidationError\n    \u2502   \u251c\u2500 TimeIndexError\n    \u2502   \u2514\u2500 AllocationConstraintError\n    \u251c\u2500 OptimizationError\n    \u2502   \u2514\u2500 InfeasibleError\n    \u2514\u2500 MemoryLimitError\n</code></pre>"},{"location":"framework/#key-type-signatures","title":"Key Type Signatures","text":"<pre><code># Simulation\nSimulationResult = model.simulate(\n    T: int,\n    X: np.ndarray,           # (T, M)\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date],\n    withdrawals: Optional[WithdrawalModel]\n)\n\n# Optimization\nOptimizationResult = model.optimize(\n    goals: List[IntermediateGoal | TerminalGoal],\n    optimizer: CVaROptimizer,\n    T_max: int,\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date],\n    withdrawals: Optional[WithdrawalModel],\n    search_method: Literal[\"binary\", \"linear\"]\n)\n\n# Validation\nDict[Goal, Dict[str, float]] = model.verify_goals(\n    result: SimulationResult | OptimizationResult,\n    goals: List[IntermediateGoal | TerminalGoal]\n)\n</code></pre>"},{"location":"goals/","title":"<code>goals</code> \u2014 Probabilistic Goal Specification for FinOpt","text":"<p>Core idea: translate financial goals into chance constraints that can be validated against Monte Carlo simulations and reformulated for convex optimization. <code>goals.py</code> connects what the user wants to achieve (e.g., \"$20M in account X with 90% confidence\") with the CVaR-based optimization framework that finds the minimum horizon and optimal allocation policy to satisfy these goals.</p>"},{"location":"goals/#why-a-dedicated-goals-module","title":"Why a dedicated goals module?","text":"<ul> <li>Probabilistic semantics: Goals are chance constraints \u2119(W_t^m \u2265 b) \u2265 1-\u03b5, not deterministic targets</li> <li>Two temporal flavors: Intermediate goals (fixed calendar date) vs. terminal goals (variable horizon T)</li> <li>Optimization-ready: Provides <code>GoalSet</code> abstraction consumed by <code>CVaROptimizer</code> and <code>GoalSeeker</code></li> <li>Validation utilities: Post-simulation functions to check goal satisfaction with detailed metrics</li> </ul>"},{"location":"goals/#design-philosophy","title":"Design philosophy","text":"<ol> <li>Immutable specifications</li> <li>Goals are <code>frozen</code> dataclasses \u2014 safe to hash, cache, and use as dict keys</li> <li> <p>No mutation after construction</p> </li> <li> <p>Dual temporal semantics</p> </li> <li><code>IntermediateGoal</code>: Fixed calendar checkpoint (independent of optimization horizon)</li> <li> <p><code>TerminalGoal</code>: Evaluated at variable T (the horizon being optimized)</p> </li> <li> <p>Account resolution</p> </li> <li>Goals reference accounts by name (<code>str</code>) or index (<code>int</code>)</li> <li> <p><code>GoalSet</code> validates and resolves references at construction time</p> </li> <li> <p>Calendar-aware month resolution</p> </li> <li>Dates converted to month offsets via <code>resolve_month(start_date)</code></li> <li>Results cached for O(1) lookup during optimization</li> </ol>"},{"location":"goals/#key-concepts","title":"Key concepts","text":""},{"location":"goals/#chance-constraints","title":"Chance constraints","text":"<p>Goals are formulated as probabilistic requirements:</p> <p>IntermediateGoal (fixed time t_fixed): <pre><code>\u2119(W_{t_fixed}^m \u2265 threshold) \u2265 confidence\n</code></pre></p> <p>TerminalGoal (variable horizon T): <pre><code>\u2119(W_T^m \u2265 threshold) \u2265 confidence\n</code></pre></p> <p>Where: - <code>W_t^m</code> = wealth in account m at time t - <code>threshold</code> = minimum required wealth (e.g., $5,500,000 CLP) - <code>confidence</code> = 1 - \u03b5 (e.g., 0.90 means 90% chance of success) - <code>\u03b5</code> = violation tolerance (e.g., 0.10 allows 10% failure rate)</p>"},{"location":"goals/#cvar-reformulation","title":"CVaR reformulation","text":"<p>The optimization module transforms these non-convex chance constraints into tractable convex form:</p> <pre><code>Original (non-convex):  \u2119(W_t \u2265 b) \u2265 1-\u03b5\nCVaR form (convex):     CVaR_\u03b5(b - W_t) \u2264 0\n</code></pre> <p>This enables globally optimal allocation policies via convex programming.</p>"},{"location":"goals/#main-api","title":"Main API","text":""},{"location":"goals/#1-intermediategoal-dataclass","title":"1) <code>IntermediateGoal</code> (dataclass)","text":"<p>Fixed-time financial checkpoint. Used for liquidity requirements, planned expenses, or milestone tracking.</p> <pre><code>from datetime import date\nfrom finopt.src.goals import IntermediateGoal\n\ngoal = IntermediateGoal(\n    date=date(2025, 7, 1),       # Target date (required)\n    account=\"Emergency\",          # Account name or index\n    threshold=5_500_000,          # Minimum wealth required\n    confidence=0.90               # 90% chance of success\n)\n\n# Month resolution (relative to simulation start)\nmonth = goal.resolve_month(date(2025, 1, 1))  # \u2192 6\n\n# Violation tolerance\nepsilon = goal.epsilon  # \u2192 0.10\n</code></pre> <p>Parameters: - <code>date</code>: Target date for evaluation (converted to month offset) - <code>account</code>: Account identifier (int index or str name) - <code>threshold</code>: Minimum required wealth (must be &gt; 0) - <code>confidence</code>: Required probability of success \u2208 (0, 1)</p> <p>Month resolution semantics: - <code>date=July 1, 2025</code> with <code>start_date=January 1, 2025</code> \u2192 month 6 - Checks wealth W_6 (wealth at start of period 6, i.e., July 1)</p>"},{"location":"goals/#2-terminalgoal-dataclass","title":"2) <code>TerminalGoal</code> (dataclass)","text":"<p>End-of-horizon target evaluated at variable T. Used for retirement targets, long-term savings, or final portfolio value.</p> <pre><code>from finopt.src.goals import TerminalGoal\n\ngoal = TerminalGoal(\n    account=\"Retirement\",         # Account name or index\n    threshold=20_000_000,         # Terminal wealth target\n    confidence=0.90               # 90% chance of success\n)\n</code></pre> <p>Parameters: - <code>account</code>: Account identifier (int index or str name) - <code>threshold</code>: Minimum required terminal wealth (must be &gt; 0) - <code>confidence</code>: Required probability of success \u2208 (0, 1)</p> <p>Key difference from IntermediateGoal: - No fixed <code>date</code> \u2014 evaluated at horizon T (the optimization variable) - Used by <code>GoalSeeker</code> to find minimum T* such that goal is feasible</p>"},{"location":"goals/#3-goalset-class","title":"3) <code>GoalSet</code> (class)","text":"<p>Validated collection of goals with account resolution and utilities for optimization.</p> <pre><code>from datetime import date\nfrom finopt.src.portfolio import Account\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal, GoalSet\n\n# Define accounts\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Housing\", annual_return=0.07, annual_volatility=0.12)\n]\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Emergency\", threshold=20_000_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=7_000_000, confidence=0.90)\n]\n\n# Create validated collection\ngoal_set = GoalSet(goals, accounts, start_date=date(2025, 1, 1))\n\n# Access properties\ngoal_set.T_min                    # \u2192 6 (from intermediate goal)\ngoal_set.M                        # \u2192 2 (number of accounts)\ngoal_set.intermediate_goals       # \u2192 [IntermediateGoal(...)]\ngoal_set.terminal_goals           # \u2192 [TerminalGoal(...), TerminalGoal(...)]\n\n# Resolve account index for a goal\nidx = goal_set.get_account_index(goals[0])  # \u2192 0\n\n# Get cached resolved month (O(1))\nmonth = goal_set.get_resolved_month(goals[0])  # \u2192 6\n</code></pre> <p>Validation rules: - Goals list cannot be empty - All account references must resolve to valid indices - No duplicate IntermediateGoal for same (month, account) pair - No duplicate TerminalGoal for same account</p> <p>Key methods: - <code>get_account_index(goal)</code>: Returns resolved 0-based account index - <code>get_resolved_month(goal)</code>: Returns cached month offset for IntermediateGoal - <code>estimate_minimum_horizon(...)</code>: Heuristic T estimate for terminal goals</p>"},{"location":"goals/#4-goal-validation-functions","title":"4) Goal validation functions","text":""},{"location":"goals/#check_goals-validate-goal-satisfaction","title":"<code>check_goals()</code> \u2014 Validate goal satisfaction","text":"<pre><code>from finopt.src.goals import check_goals\n\nstatus = check_goals(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n\nfor goal, metrics in status.items():\n    print(f\"{goal}: {'\u2713' if metrics['satisfied'] else '\u2717'}\")\n    print(f\"  Violation rate: {metrics['violation_rate']:.1%}\")\n    print(f\"  Required rate:  {metrics['required_rate']:.1%}\")\n    print(f\"  Margin:         {metrics['margin']:+.1%}\")\n</code></pre> <p>Returns dict with metrics for each goal: - <code>satisfied</code>: bool \u2014 True if empirical violation rate \u2264 \u03b5 - <code>violation_rate</code>: float \u2014 Empirical \u2119(W_t^m &lt; threshold) - <code>required_rate</code>: float \u2014 Goal's \u03b5 = 1 - confidence - <code>margin</code>: float \u2014 required_rate - violation_rate (positive = satisfied) - <code>median_shortfall</code>: float \u2014 Median shortfall over violated scenarios - <code>n_violations</code>: int \u2014 Count of scenarios violating threshold</p>"},{"location":"goals/#goal_progress-track-progress-toward-goals","title":"<code>goal_progress()</code> \u2014 Track progress toward goals","text":"<pre><code>from finopt.src.goals import goal_progress\n\nprogress = goal_progress(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n\nfor goal, pct in progress.items():\n    account = goal.account\n    print(f\"{account}: {pct:.1%} progress\")\n</code></pre> <p>Progress metric: <code>min(1, VaR_{1-\u03b5}(W_t^m) / threshold)</code></p> <ul> <li>0.0: VaR is zero (far from goal)</li> <li>0.5: VaR is 50% of threshold (halfway)</li> <li>1.0: VaR \u2265 threshold (goal achieved at confidence level)</li> </ul>"},{"location":"goals/#print_goal_status-pretty-print-goal-satisfaction","title":"<code>print_goal_status()</code> \u2014 Pretty-print goal satisfaction","text":"<pre><code>from finopt.src.goals import print_goal_status\n\nprint_goal_status(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n</code></pre> <p>Example output: <pre><code>=== Goal Status ===\n\n[\u2713] IntermediateGoal: Emergency Fund @ month 6\n    Target: $5,500,000 | Confidence: 90.0%\n    Status: SATISFIED (margin: +2.3%)\n    Violation rate: 7.7% (38 scenarios)\n\n[\u2717] TerminalGoal: Emergency Fund @ T=24\n    Target: $20,000,000 | Confidence: 90.0%\n    Status: VIOLATED (margin: -3.1%)\n    Violation rate: 13.1% (66 scenarios)\n    Median shortfall: $1,234,567\n</code></pre></p>"},{"location":"goals/#month-resolution-semantics","title":"Month resolution semantics","text":"<p>Goals and the wealth array use start-of-period indexing:</p> Date <code>resolve_month()</code> Wealth Index Interpretation January 1, 2025 (start) \u2014 W_0 Initial wealth February 1, 2025 1 W_1 Wealth at start of month 1 July 1, 2025 6 W_6 Wealth at start of month 6 January 1, 2026 (T=12) 12 W_12 Terminal wealth <p>Example with start_date = January 1, 2025: <pre><code>goal = IntermediateGoal(date=date(2025, 7, 1), ...)\nmonth = goal.resolve_month(date(2025, 1, 1))  # \u2192 6\n# Checks wealth[i, 6, m] which is W_6 (wealth at July 1)\n</code></pre></p>"},{"location":"goals/#integration-with-optimization","title":"Integration with optimization","text":""},{"location":"goals/#optimization-workflow","title":"Optimization workflow","text":"<pre><code>from finopt import FinancialModel\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.optimization import CVaROptimizer\n\n# 1. Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Retirement\", threshold=20_000_000, confidence=0.90)\n]\n\n# 2. Create optimizer\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\n\n# 3. Optimize (finds minimum T* and optimal X*)\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42\n)\n\n# 4. Validate goals\nresult.validate_goals()  # Uses stored goal_set\n</code></pre>"},{"location":"goals/#how-goals-flow-through-the-system","title":"How goals flow through the system","text":"<ol> <li>User defines goals \u2192 <code>IntermediateGoal</code> / <code>TerminalGoal</code> objects</li> <li><code>GoalSet</code> validates \u2192 Resolves accounts, caches months, computes T_min</li> <li><code>CVaROptimizer</code> reformulates \u2192 Chance constraints \u2192 CVaR \u2264 0</li> <li><code>GoalSeeker</code> searches \u2192 Binary search over T with warm-start</li> <li><code>check_goals</code> validates \u2192 Post-simulation verification</li> </ol>"},{"location":"goals/#complete-example","title":"Complete example","text":"<pre><code>from datetime import date\nfrom finopt import FinancialModel, Account, IncomeModel, FixedIncome\nfrom finopt.src.goals import (\n    IntermediateGoal, TerminalGoal, GoalSet,\n    check_goals, goal_progress, print_goal_status\n)\nfrom finopt.optimization import CVaROptimizer\n\n# Setup\nincome = IncomeModel(fixed=FixedIncome(base=1_500_000, annual_growth=0.03))\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Growth\", annual_return=0.12, annual_volatility=0.15)\n]\nmodel = FinancialModel(income, accounts)\n\n# Define goals\nstart_date = date(2025, 1, 1)\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"Growth\", threshold=50_000_000, confidence=0.80)\n]\n\n# Validate goal structure\ngoal_set = GoalSet(goals, accounts, start_date)\nprint(f\"Minimum horizon from intermediate goals: T_min = {goal_set.T_min}\")\n\n# Optimize\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\nresult = model.optimize(goals=goals, optimizer=optimizer, T_max=120, n_sims=500)\n\n# Check results\nprint_goal_status(result, goals, accounts, start_date)\n\n# Get detailed metrics\nstatus = check_goals(result, goals, accounts, start_date)\nprogress = goal_progress(result, goals, accounts, start_date)\n</code></pre>"},{"location":"goals/#comparison-with-legacy-api","title":"Comparison with legacy API","text":"Legacy (removed) Current <code>Goal</code> dataclass <code>IntermediateGoal</code>, <code>TerminalGoal</code> <code>target_amount</code> <code>threshold</code> <code>target_date</code> / <code>target_month_index</code> <code>date</code> (IntermediateGoal only) <code>evaluate_goal()</code> <code>check_goals()</code> <code>evaluate_goals()</code> \u2192 DataFrame <code>check_goals()</code> \u2192 Dict <code>GoalEvaluation</code> Dict with metrics <code>allocate_contributions_proportional()</code> Removed (use optimization) <code>required_constant_contribution()</code> <code>GoalSet.estimate_minimum_horizon()</code> Deterministic success/failure Probabilistic chance constraints"},{"location":"income/","title":"<code>income</code> \u2014 Cash Flow Modeling for FinOpt","text":"<p>Core idea: Model where the money comes from (and how it evolves) so the rest of FinOpt can decide how to allocate and invest it. In FinOpt's pipeline, <code>income.py</code> is the entry point of cash flows: it turns assumptions about salary and variable earnings into a clean, reproducible monthly series that downstream modules consume for contributions and simulations.</p>"},{"location":"income/#why-a-dedicated-income-module","title":"Why a dedicated income module?","text":"<p>Financial planning hinges on cash availability per period. Any optimizer or simulator that ignores timing or volatility of income will produce plans that are hard to execute. <code>income.py</code> separates cash generation (what you earn) from capital dynamics (what you invest), giving you:</p> <ul> <li>Clarity: Incomes are modeled explicitly (fixed vs. variable).</li> <li>Composability: Outputs plug directly into <code>simulation.py</code> and <code>investment.py</code>.</li> <li>Reproducibility: Deterministic by default; any randomness is controlled by an explicit seed.</li> <li>Extensibility: Easy to add expenses, taxes, or more streams without touching portfolio code.</li> <li>Performance: Vectorized Monte Carlo generation via <code>n_sims</code> parameter.</li> </ul>"},{"location":"income/#design-principles","title":"Design principles","text":"<ol> <li>Deterministic baseline, controlled randomness</li> <li> <p>Everything is deterministic unless you explicitly add noise to <code>VariableIncome</code> via <code>sigma</code> and <code>seed</code>.</p> </li> <li> <p>Calendar-first outputs</p> </li> <li> <p>Returns pandas Series/DataFrames indexed by the first day of each month (friendly for reporting and plotting).</p> </li> <li> <p>Minimal but expressive</p> </li> <li>Two stream types cover common cases:<ul> <li><code>FixedIncome</code>: predictable salary with optional annual growth and scheduled raises.</li> <li><code>VariableIncome</code>: irregular stream with seasonality and Gaussian noise.</li> </ul> </li> <li> <p>Either component can be <code>None</code> in <code>IncomeModel</code> (at least one required).</p> </li> <li> <p>Single responsibility</p> </li> <li> <p><code>income.py</code> does not simulate returns or portfolios. It only projects income and derives contribution series from it.</p> </li> <li> <p>Vectorized Monte Carlo</p> </li> <li>All projection methods support <code>n_sims</code> parameter for efficient batch generation.</li> <li>~100x speedup vs. sequential calls for typical Monte Carlo workloads.</li> </ol>"},{"location":"income/#the-three-core-surfaces","title":"The three core surfaces","text":""},{"location":"income/#1-fixedincome","title":"1) <code>FixedIncome</code>","text":"<p>A deterministic monthly base with compounded annual growth and optional salary raises:</p> <p>Parameters: - <code>base</code>: monthly base income at t=0 (must be non-negative) - <code>annual_growth</code>: nominal annual rate (converted internally to monthly compounding) - <code>salary_raises</code>: <code>Optional[Dict[date, float]]</code> \u2014 absolute raise amounts at specific dates - <code>name</code>: identifier for labeling outputs (default: <code>\"fixed\"</code>)</p> <p>Method signature: <pre><code>def project(\n    self,\n    months: int,\n    *,\n    start: Optional[date] = None,\n    output: Literal[\"array\", \"series\"] = \"array\",\n    n_sims: int = 1,\n) -&gt; np.ndarray | pd.Series\n</code></pre></p> <p>Parameters: - <code>months</code>: Number of months to project (\u2265 0) - <code>start</code>: Required when <code>salary_raises</code> is specified; used for calendar alignment - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index - <code>n_sims</code>: Number of simulations (deterministic replication for API consistency)</p> <p>Returns: - If <code>n_sims=1</code> and <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(months,)</code> - If <code>n_sims&gt;1</code> and <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(n_sims, months)</code> (all rows identical) - If <code>n_sims=1</code> and <code>output=\"series\"</code>: <code>pd.Series</code> indexed by first-of-month dates - If <code>n_sims&gt;1</code> and <code>output=\"series\"</code>: raises <code>ValueError</code></p> <p>Key behaviors: - Monthly projection uses the equivalent monthly rate: <code>m = (1 + annual_growth)^(1/12) - 1</code> - Salary raises are applied permanently from the month containing the specified date - Growth compounds on the updated base after each raise - Guarantees non-negativity and well-formed arrays - When <code>n_sims &gt; 1</code>, the deterministic projection is replicated across all simulations</p> <p>Interpretation: models a salary with contractual raises and inflation adjustments; simple and transparent.</p>"},{"location":"income/#2-variableincome","title":"2) <code>VariableIncome</code>","text":"<p>A variable stream with optional seasonality, noise, floor/cap, and annual growth:</p> <p>Parameters: - <code>base</code>: baseline monthly income before transformations - <code>seasonality</code>: 12 multiplicative factors (Jan\u2013Dec), must have length 12 - <code>sigma</code>: standard deviation of noise as a fraction of the month mean - <code>floor</code> / <code>cap</code>: guardrails applied after noise (e.g., minimum expected side income) - <code>annual_growth</code>: nominal annual rate applied before seasonality - <code>seed</code>: RNG seed for reproducible noise (can be overridden in <code>.project()</code>) - <code>name</code>: identifier for labeling outputs (default: <code>\"variable\"</code>)</p> <p>Method signature: <pre><code>def project(\n    self,\n    months: int,\n    *,\n    start: Optional[date | int] = None,\n    seed: Optional[int] = None,\n    output: Literal[\"array\", \"series\"] = \"array\",\n    n_sims: int = 1,\n) -&gt; np.ndarray | pd.Series\n</code></pre></p> <p>Parameters: - <code>months</code>: Number of months to project (\u2265 0) - <code>start</code>: Can be <code>date</code> or <code>int</code> (month 1-12); determines seasonality rotation - <code>seed</code>: Overrides instance-level seed if provided; controls reproducibility of all simulations - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index - <code>n_sims</code>: Number of independent simulations to generate</p> <p>Returns: - If <code>n_sims=1</code> and <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(months,)</code> - If <code>n_sims&gt;1</code> and <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(n_sims, months)</code> - If <code>n_sims=1</code> and <code>output=\"series\"</code>: <code>pd.Series</code> indexed by first-of-month dates - If <code>n_sims&gt;1</code> and <code>output=\"series\"</code>: raises <code>ValueError</code></p> <p>Performance: <pre><code># Vectorized: ~100x faster than sequential calls\nsims = vi.project(months=240, n_sims=500)  # shape: (500, 240)\n\n# vs. sequential (avoid this)\nsims = np.array([vi.project(240) for _ in range(500)])  # slow!\n</code></pre></p> <p>Interpretation: models tutoring, bonuses, or freelancing income whose level changes across the year and fluctuates each month.</p>"},{"location":"income/#3-incomemodel","title":"3) <code>IncomeModel</code>","text":"<p>A fa\u00e7ade that combines streams and produces projections, contributions, metrics, and visualizations.</p> <p>Parameters: - <code>fixed</code>: <code>Optional[FixedIncome]</code> \u2014 deterministic income stream (can be <code>None</code>) - <code>variable</code>: <code>Optional[VariableIncome]</code> \u2014 stochastic income stream (can be <code>None</code>) - <code>name_fixed</code>: label for fixed component in outputs (default: <code>\"fixed\"</code>) - <code>name_variable</code>: label for variable component in outputs (default: <code>\"variable\"</code>) - <code>monthly_contribution</code>: <code>Optional[MonthlyContributionDict]</code> \u2014 12-month fractional arrays per stream</p> <p>Constraint: At least one of <code>fixed</code> or <code>variable</code> must be provided.</p>"},{"location":"income/#core-projection-methods","title":"Core projection methods","text":"<p><code>project(months, start=None, output=\"series\", seed=None, n_sims=1)</code></p> <p>Returns total income (optionally as DataFrame with component breakdown or dict of arrays).</p> <p>Parameters: - <code>months</code>: Number of months to project - <code>start</code>: Start date for calendar alignment - <code>output</code>: Output format:   - <code>\"series\"</code>: total as <code>pd.Series</code> (default, n_sims=1 only)   - <code>\"dataframe\"</code>: breakdown <code>pd.DataFrame</code> with [fixed, variable, total] (n_sims=1 only)   - <code>\"array\"</code>: <code>dict</code> with <code>{name_fixed: array, name_variable: array, \"total\": array}</code> - <code>seed</code>: Controls reproducibility of variable income - <code>n_sims</code>: Number of independent simulations (only <code>output=\"array\"</code> supports n_sims &gt; 1)</p> <p>Returns: - <code>n_sims=1</code>, <code>output=\"series\"</code>: <code>pd.Series</code> of total income - <code>n_sims=1</code>, <code>output=\"dataframe\"</code>: <code>pd.DataFrame</code> with component columns - <code>n_sims=1</code>, <code>output=\"array\"</code>: <code>dict</code> with shape <code>(months,)</code> arrays - <code>n_sims&gt;1</code>, <code>output=\"array\"</code>: <code>dict</code> with shape <code>(n_sims, months)</code> arrays</p> <p>Example: <pre><code># Total income as Series (default)\ntotal = income.project(months=24, start=date(2025, 9, 1))\n\n# Breakdown as DataFrame\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n\n# Multiple simulations (vectorized)\nresult = income.project(months=24, n_sims=500, output=\"array\")\n# result[\"total\"].shape \u2192 (500, 24)\n</code></pre></p> <p><code>contributions(months, start=None, seed=None, output=\"series\", n_sims=1)</code></p> <p>Computes monthly contributions using 12-month fractional arrays that rotate based on <code>start</code>:</p> \\[ \\text{contrib}_t = \\alpha^{\\text{fixed}}_{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{fixed}}_t + \\alpha^{\\text{variable}}_{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{variable}}_t \\] <p>where <code>offset = normalize_start_month(start)</code>.</p> <p>Parameters: - <code>months</code>: Number of months to compute contributions - <code>start</code>: Calendar start date for fraction rotation - <code>seed</code>: Controls reproducibility of variable income - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> (default) - <code>n_sims</code>: Number of independent simulations (only <code>output=\"array\"</code> supports n_sims &gt; 1)</p> <p>Returns: - <code>n_sims=1</code>, <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(months,)</code> - <code>n_sims&gt;1</code>, <code>output=\"array\"</code>: <code>np.ndarray</code> of shape <code>(n_sims, months)</code> - <code>n_sims=1</code>, <code>output=\"series\"</code>: <code>pd.Series</code> indexed by first-of-month dates</p> <p>Default fractions (if <code>monthly_contribution</code> is <code>None</code>): - Fixed: 30% each month - Variable: 100% each month</p> <p>Custom fractions via attribute: <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # Jan-Dec fractions\n    \"variable\": [1.0]*12\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <ul> <li>Contributions are floored at zero (no negative values)</li> <li>The 12-month arrays repeat cyclically for horizons &gt; 12 months</li> </ul>"},{"location":"income/#statistical-methods","title":"Statistical methods","text":"<p><code>income_metrics(months, start=None, variable_threshold=None)</code></p> <p>Returns <code>IncomeMetrics</code> frozen dataclass with: <pre><code>@dataclass(frozen=True)\nclass IncomeMetrics:\n    months: int\n    total_fixed, total_variable, total_income: float\n    mean_fixed, mean_variable, mean_total: float\n    std_variable, coefvar_variable: float\n    fixed_share, variable_share: float\n    min_variable, max_variable: float\n    pct_variable_below_threshold: float  # NaN if threshold not provided\n</code></pre></p> <p><code>summary(months, start=None, variable_threshold=None, round_digits=2)</code></p> <p>Convenience wrapper that returns <code>income_metrics()</code> as a rounded pandas Series.</p>"},{"location":"income/#visualization-methods","title":"Visualization methods","text":"<p><code>plot_income(months, start=None, ...)</code></p> <p>Plots fixed, variable, and total income streams.</p> <p>Key parameters: - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code> - <code>ylabel_left</code>, <code>ylabel_right</code>: axis labels - <code>dual_axis</code>: <code>\"auto\"</code> | <code>True</code> | <code>False</code> (default: <code>\"auto\"</code>) - <code>dual_axis_ratio</code>: threshold for automatic dual-axis activation (default: 3.0) - <code>show_trajectories</code>: show individual Monte Carlo paths (default: <code>True</code>) - <code>show_confidence_band</code>: show statistical intervals (default: <code>False</code>) - <code>trajectory_alpha</code>: transparency for trajectories (default: 0.07) - <code>confidence</code>: confidence level for bands (default: 0.9) - <code>n_simulations</code>: number of Monte Carlo simulations (default: 500) - <code>colors</code>: <code>{\"fixed\": \"black\", \"variable\": \"gray\", \"total\": \"blue\"}</code> - <code>save_path</code>, <code>return_fig_ax</code></p> <p>Dual-axis support: automatic when scales differ by <code>dual_axis_ratio</code>.</p> <p><code>plot_contributions(months, start=None, ...)</code></p> <p>Plots total monthly contributions with optional Monte Carlo trajectories and confidence bands.</p> <p>Key parameters: - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code>, <code>ylabel</code> - <code>show_trajectories</code>: show individual Monte Carlo paths (default: <code>True</code>) - <code>show_confidence_band</code>: show statistical intervals (default: <code>False</code>) - <code>trajectory_alpha</code>, <code>confidence</code>, <code>n_simulations</code> - <code>colors</code>: <code>{\"total\": \"blue\", \"ci\": \"orange\"}</code> - <code>save_path</code>, <code>return_fig_ax</code></p> <p><code>plot(mode=\"income\"|\"contributions\", ...)</code></p> <p>Unified wrapper that dispatches to <code>plot_income()</code> or <code>plot_contributions()</code>.</p>"},{"location":"income/#serialization","title":"Serialization","text":"<p><code>to_dict()</code> / <code>from_dict(payload)</code></p> <p>Serialize/deserialize model configuration for persistence. - Handles <code>salary_raises</code> date conversion (ISO format strings) - Supports <code>None</code> components (fixed-only or variable-only models)</p> <pre><code># Serialize\ndata = income.to_dict()\n# {\n#     \"fixed\": {\"base\": 1400000.0, \"annual_growth\": 0.03, ...},\n#     \"variable\": {\"base\": 200000.0, \"sigma\": 0.15, ...}\n# }\n\n# Deserialize\nincome = IncomeModel.from_dict(data)\n</code></pre>"},{"location":"income/#how-incomepy-powers-the-rest-of-finopt","title":"How <code>income.py</code> powers the rest of FinOpt","text":"<ul> <li> <p><code>simulation.py</code>   Uses <code>IncomeModel.contributions(...)</code> to generate the contribution series aligned to the simulation calendar, then combines it with deterministic or Monte Carlo returns to simulate wealth.</p> </li> <li> <p><code>investment.py</code>   Receives the contributions from <code>income.py</code> and applies capital accumulation:</p> </li> </ul> \\[ W_{t+1}=(W_t+A_t)(1+R_t). \\] <p>Metrics (CAGR, drawdown, volatility) are computed downstream on the resulting wealth path.</p> <ul> <li><code>utils.py</code>   Provides shared helpers used by <code>income.py</code> (e.g., rate conversions annual\u2194monthly, month index construction, validation).</li> </ul>"},{"location":"income/#recommended-usage-patterns","title":"Recommended usage patterns","text":""},{"location":"income/#a-baseline-projection-deterministic","title":"A) Baseline projection (deterministic)","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\n\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000.0, annual_growth=0.00),\n    variable=VariableIncome(base=200_000.0, sigma=0.00)  # no noise\n)\n\n# 24-month calendar-aligned totals (and components if needed)\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n</code></pre>"},{"location":"income/#b-fixed-only-or-variable-only-models","title":"B) Fixed-only or variable-only models","text":"<pre><code># Fixed income only (no variable component)\nfixed_only = IncomeModel(\n    fixed=FixedIncome(base=1_400_000.0, annual_growth=0.03),\n    variable=None\n)\n\n# Variable income only (no fixed component)\nvariable_only = IncomeModel(\n    fixed=None,\n    variable=VariableIncome(base=500_000.0, sigma=0.20, seed=42)\n)\n\n# Both work seamlessly\ntotal_fixed = fixed_only.project(months=12, start=date(2025, 1, 1))\ntotal_var = variable_only.project(months=12, start=date(2025, 1, 1))\n</code></pre>"},{"location":"income/#c-from-income-to-contributions","title":"C) From income to contributions","text":"<p>Option 1: Use defaults (30% fixed, 100% variable) <pre><code>contrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 2: Custom monthly fractions <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # 35% each month (Jan-Dec)\n    \"variable\": [1.0]*12     # 100% each month\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 3: Seasonal contribution patterns <pre><code># Higher contributions in bonus months\nincome.monthly_contribution = {\n    \"fixed\": [0.30]*12,\n    \"variable\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n                 1.0, 1.0, 1.0, 1.0, 1.0, 0.5]  # save 50% of Dec bonus\n}\n</code></pre></p>"},{"location":"income/#d-fixed-income-with-salary-raises","title":"D) Fixed income with salary raises","text":"<pre><code>fixed = FixedIncome(\n    base=1_400_000.0,\n    annual_growth=0.03,\n    salary_raises={\n        date(2025, 7, 1): 200_000,   # raise in July\n        date(2026, 1, 1): 150_000    # raise in January\n    }\n)\n# Requires start date when projecting\npath = fixed.project(months=24, start=date(2025, 1, 1))  # returns array by default\nseries = fixed.project(months=24, start=date(2025, 1, 1), output=\"series\")  # with calendar index\n</code></pre>"},{"location":"income/#e-variable-income-with-seasonality-noise","title":"E) Variable income with seasonality + noise","text":"<pre><code>seasonality = [1.00, 0.95, 1.05, 1.10, 1.15, 1.10,\n               1.00, 0.90, 0.95, 1.05, 1.10, 1.20]\n\nincome_var = VariableIncome(\n    base=200_000.0,\n    seasonality=seasonality,\n    sigma=0.15,\n    floor=50_000.0,\n    cap=400_000.0,\n    annual_growth=0.02,\n    seed=123\n)\n\n# Project as array (default)\npath = income_var.project(months=12)\n\n# Project as Series with calendar alignment\nseries = income_var.project(months=12, start=date(2025, 1, 1), output=\"series\")\n</code></pre>"},{"location":"income/#f-vectorized-monte-carlo-simulations","title":"F) Vectorized Monte Carlo simulations","text":"<pre><code># Generate 500 independent income scenarios in one call\nsims = income_var.project(months=24, n_sims=500)\n# sims.shape \u2192 (500, 24)\n\n# Compute statistics\nmean_income = sims.mean(axis=0)      # shape: (24,)\nstd_income = sims.std(axis=0)        # shape: (24,)\npercentile_5 = np.percentile(sims, 5, axis=0)\n\n# For contributions\ncontrib_sims = income.contributions(months=24, n_sims=500, output=\"array\")\n# contrib_sims.shape \u2192 (500, 24)\n\n# Full model projection with multiple sims\nresult = income.project(months=24, n_sims=500, output=\"array\")\n# result[\"total\"].shape \u2192 (500, 24)\n# result[\"fixed\"].shape \u2192 (500, 24)\n# result[\"variable\"].shape \u2192 (500, 24)\n</code></pre>"},{"location":"income/#g-statistical-summary","title":"G) Statistical summary","text":"<pre><code># Detailed metrics as dataclass\nmetrics = income.income_metrics(\n    months=24,\n    start=date(2025, 1, 1),\n    variable_threshold=150_000.0\n)\n\n# Compact summary as Series\nsummary = income.summary(months=24, start=date(2025, 1, 1), round_digits=2)\nprint(summary)\n</code></pre>"},{"location":"income/#h-visualization-with-monte-carlo-trajectories","title":"H) Visualization with Monte Carlo trajectories","text":"<pre><code># Income streams with stochastic trajectories (default if sigma &gt; 0)\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    n_simulations=500,\n    dual_axis=\"auto\",\n    save_path=\"income_projection.png\"\n)\n\n# Legacy mode: confidence bands only\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=False,\n    show_confidence_band=True,\n    confidence=0.95\n)\n\n# Hybrid mode: trajectories + bands\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    show_confidence_band=True,\n    n_simulations=150,\n    trajectory_alpha=0.03\n)\n\n# Contributions with trajectories\nincome.plot_contributions(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    title=\"Monthly Investment Contributions\"\n)\n\n# Using unified wrapper\nincome.plot(\n    mode=\"income\",  # or \"contributions\"\n    months=24,\n    start=date(2025, 1, 1)\n)\n</code></pre>"},{"location":"income/#key-design-decisions","title":"Key design decisions","text":""},{"location":"income/#1-monthly-fractions-are-12-element-arrays-not-scalars","title":"1. Monthly fractions are 12-element arrays, not scalars","text":"<p>This allows seasonal contribution strategies: save more during high-income months, less during lean months. The arrays rotate based on <code>start</code> and repeat cyclically.</p>"},{"location":"income/#2-salary-raises-are-date-based-not-month-offset-based","title":"2. Salary raises are date-based, not month-offset-based","text":"<p>You specify <code>{date(2025, 7, 1): 200_000}</code>, not <code>{6: 200_000}</code>. The conversion to month offsets happens internally relative to the projection <code>start</code> date, making the model calendar-aware.</p>"},{"location":"income/#3-flexible-output-formats-via-output-parameter","title":"3. Flexible output formats via <code>output</code> parameter","text":"<p>All projection methods support an <code>output</code> parameter to control return type: - <code>\"array\"</code>: returns <code>np.ndarray</code> (default for streams, no calendar overhead) - <code>\"series\"</code>: returns <code>pd.Series</code> with calendar index (default for <code>IncomeModel</code>, user-friendly) - <code>\"dataframe\"</code>: returns <code>pd.DataFrame</code> with component breakdown (only <code>IncomeModel.project()</code>)</p>"},{"location":"income/#4-reproducibility-via-explicit-seed-parameter","title":"4. Reproducibility via explicit <code>seed</code> parameter","text":"<p>Variable income randomness is controlled at two levels: - Instance-level: <code>VariableIncome(seed=42)</code> sets default seed - Method-level: <code>project(..., seed=123)</code> overrides for specific realizations This enables reproducible stochastic projections without mutating the model state.</p>"},{"location":"income/#5-monte-carlo-trajectories-as-primary-visualization","title":"5. Monte Carlo trajectories as primary visualization","text":"<p>When <code>sigma &gt; 0</code>, plotting methods default to showing individual trajectories (<code>show_trajectories=True</code>) instead of confidence bands, providing more intuitive visualization of stochastic dynamics. Confidence bands remain available via <code>show_confidence_band=True</code>.</p>"},{"location":"income/#6-dual-axis-activation-is-automatic-by-default","title":"6. Dual-axis activation is automatic by default","text":"<p>When fixed and variable incomes differ by a factor &gt; <code>dual_axis_ratio</code>, the plot automatically uses separate y-axes to avoid visual compression. Override with <code>dual_axis=True|False</code>.</p>"},{"location":"income/#7-vectorized-n_sims-for-monte-carlo-efficiency","title":"7. Vectorized <code>n_sims</code> for Monte Carlo efficiency","text":"<p>The <code>n_sims</code> parameter enables batch generation of multiple independent simulations: - Single memory allocation and NumPy vectorization throughout - ~100x speedup vs. sequential calls for typical workloads - Essential for Monte Carlo simulations in optimization</p>"},{"location":"income/#8-optional-components-fixed-only-or-variable-only","title":"8. Optional components (fixed-only or variable-only)","text":"<p><code>IncomeModel</code> supports partial configurations: - <code>IncomeModel(fixed=FixedIncome(...), variable=None)</code> \u2014 salary-only model - <code>IncomeModel(fixed=None, variable=VariableIncome(...))</code> \u2014 freelance-only model - At least one component must be provided (validation in <code>__post_init__</code>)</p>"},{"location":"income/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Rate conversion: <code>annual_to_monthly(g) = (1+g)^(1/12) - 1</code> ensures geometric compounding</li> <li>Calendar alignment: <code>month_index(start, months)</code> generates <code>pd.DatetimeIndex</code> of first-of-month dates</li> <li>Seasonality rotation: <code>normalize_start_month(start)</code> returns 0-indexed month offset (0=Jan, 11=Dec)</li> <li>Non-negativity: all income and contribution values are floored at zero after transformations</li> <li>Seed propagation: <code>seed=None</code> in methods uses instance seed; both <code>None</code> generates non-deterministic noise</li> <li>Validation: Uses <code>ValidationError</code> from <code>exceptions</code> module for input validation</li> <li>Type hints: Uses <code>MonthlyContributionDict</code> and <code>PlotColorsDict</code> from <code>types</code> module</li> </ul>"},{"location":"income/#api-summary","title":"API Summary","text":"Class Type Purpose <code>FixedIncome</code> frozen dataclass Deterministic income with growth and raises <code>VariableIncome</code> frozen dataclass Stochastic income with seasonality and noise <code>IncomeModel</code> dataclass Unified facade combining streams <code>IncomeMetrics</code> frozen dataclass Statistical summary container <p>Key methods:</p> Method Class Returns <code>project(months, start, output, n_sims)</code> All Array, Series, or DataFrame <code>contributions(months, start, seed, output, n_sims)</code> <code>IncomeModel</code> Array or Series <code>income_metrics(months, start, variable_threshold)</code> <code>IncomeModel</code> <code>IncomeMetrics</code> <code>summary(months, start, variable_threshold, round_digits)</code> <code>IncomeModel</code> <code>pd.Series</code> <code>plot_income(...)</code> <code>IncomeModel</code> Plot or (fig, ax) <code>plot_contributions(...)</code> <code>IncomeModel</code> Plot or (fig, ax) <code>plot(mode, ...)</code> <code>IncomeModel</code> Plot or (fig, ax) <code>to_dict()</code> / <code>from_dict(payload)</code> <code>IncomeModel</code> Serialization"},{"location":"model/","title":"<code>model</code> \u2014 Unified Orchestration for FinOpt","text":"<p>Purpose: Unified orchestrator for Monte Carlo simulation, integrating income generation, return modeling, withdrawals, and portfolio dynamics into a single coherent interface with intelligent caching, reproducibility guarantees, and optimization-ready outputs. <code>model.py</code> is the facade layer: while <code>income.py</code> generates cash flows, <code>returns.py</code> produces stochastic returns, <code>withdrawal.py</code> models cash outflows, and <code>portfolio.py</code> executes wealth dynamics, <code>model.py</code> coordinates the entire pipeline and packages results for analysis and optimization.</p>"},{"location":"model/#why-a-dedicated-model-module","title":"Why a dedicated model module?","text":"<p>Financial planning requires end-to-end simulation with multiple moving parts. <code>model.py</code> provides:</p> <ul> <li>Single entry point: Unified <code>FinancialModel</code> class orchestrates all components</li> <li>Intelligent caching: Parameter-based memoization avoids redundant computation</li> <li>Reproducibility: Explicit seed management with automatic propagation</li> <li>Rich analytics: <code>SimulationResult</code> container with financial metrics computation</li> <li>Seamless visualization: Auto-simulation in <code>plot()</code> methods</li> <li>Optimization integration: Direct <code>optimize()</code> method for goal-seeking</li> <li>Withdrawal support: Scheduled and stochastic withdrawals via <code>WithdrawalModel</code></li> </ul>"},{"location":"model/#design-principles","title":"Design principles","text":"<ol> <li>Facade pattern: Coordinates but doesn't re-implement (loose coupling)</li> <li>Explicit reproducibility: Seed propagation ensures statistical independence:</li> <li>Income uses <code>seed</code></li> <li>Returns use <code>seed+1</code></li> <li>Withdrawals use <code>seed+2</code></li> <li>Type-safe results: <code>SimulationResult</code> as explicit dataclass (not <code>dict</code>)</li> <li>Zero-overhead visualization: <code>plot()</code> auto-simulates with caching</li> <li>Optimization-ready: <code>optimize()</code> method for bilevel goal-seeking</li> </ol>"},{"location":"model/#core-components","title":"Core components","text":""},{"location":"model/#1-simulationresult","title":"1) <code>SimulationResult</code>","text":"<p>Container for complete Monte Carlo simulation output with lazy-computed analytics.</p> <p>Attributes: <pre><code>@dataclass(frozen=False)\nclass SimulationResult:\n    # Primary outputs\n    wealth: np.ndarray              # (n_sims, T+1, M)\n    total_wealth: np.ndarray        # (n_sims, T+1)\n    contributions: np.ndarray       # (n_sims, T) or (T,)\n    returns: np.ndarray             # (n_sims, T, M)\n    income: dict                    # {\"fixed\", \"variable\", \"total\"}\n    allocation: np.ndarray          # (T, M)\n    withdrawals: np.ndarray         # (n_sims, T, M) or (T, M) or None\n\n    # Metadata for reproducibility\n    T, n_sims, M: int\n    start: date\n    seed: Optional[int]\n    account_names: List[str]\n</code></pre></p> <p>Analytical methods:</p>"},{"location":"model/#metricsaccountnone-pddataframe","title":"<code>metrics(account=None) \u2192 pd.DataFrame</code>","text":"<p>Computes per-simulation financial metrics:</p> \\[ \\begin{aligned} \\text{CAGR}_i &amp;= \\left(\\frac{W_{T,i}}{W_{0,i}}\\right)^{12/T} - 1 \\\\ \\text{Sharpe}_i &amp;= \\frac{\\bar{R}_i}{\\sigma_i} \\quad \\text{(assumes } r_f = 0\\text{)} \\\\ \\text{Sortino}_i &amp;= \\frac{\\bar{R}_i}{\\sigma^-_i}, \\quad \\sigma^-_i = \\sqrt{\\mathbb{E}[\\min(R_t, 0)^2]} \\\\ \\text{MDD}_i &amp;= \\min_{t} \\frac{W_{t,i} - \\max_{s \\leq t} W_{s,i}}{\\max_{s \\leq t} W_{s,i}} \\end{aligned} \\] <p>Returns: DataFrame with columns <code>['cagr', 'volatility', 'sharpe', 'sortino', 'max_drawdown']</code></p>"},{"location":"model/#aggregate_metricsaccountnone-pdseries-pddataframe","title":"<code>aggregate_metrics(account=None) \u2192 pd.Series | pd.DataFrame</code>","text":"<p>Computes distribution-level risk metrics:</p> \\[ \\begin{aligned} \\text{VaR}_{0.95}(W_T) &amp;= F_{W_T}^{-1}(0.05) \\quad \\text{(5th percentile)} \\\\ \\text{CVaR}_{0.95}(W_T) &amp;= \\mathbb{E}[W_T \\mid W_T \\leq \\text{VaR}_{0.95}] \\end{aligned} \\] <p>Plus summary statistics: mean, median, std, min, max of \\(W_T\\).</p>"},{"location":"model/#summaryconfidence095-pddataframe","title":"<code>summary(confidence=0.95) \u2192 pd.DataFrame</code>","text":"<p>Statistical summary with confidence intervals: $$ \\text{CI}{1-\\alpha}(W_T) = \\left[F^{-1}(1-\\alpha/2)\\right] $$}(\\alpha/2), F^{-1}_{W_T</p>"},{"location":"model/#convergence_analysis-pddataframe","title":"<code>convergence_analysis() \u2192 pd.DataFrame</code>","text":"<p>Monte Carlo convergence diagnostics via standard error: \\(\\text{SE}(n) = \\frac{\\sigma_{W_T}}{\\sqrt{n}}\\)</p>"},{"location":"model/#2-financialmodel","title":"2) <code>FinancialModel</code>","text":"<p>Unified orchestrator coordinating the flow: <code>income \u2192 contributions (A) \u2192 returns (R) \u2192 withdrawals (D) \u2192 wealth (W)</code></p> <p>Constructor: <pre><code>FinancialModel(\n    income: IncomeModel,\n    accounts: List[Account],\n    default_correlation: Optional[np.ndarray] = None,\n    enable_cache: bool = True\n)\n</code></pre></p> <p>Internal components: <pre><code>self.returns = ReturnModel(accounts, default_correlation)\nself.portfolio = Portfolio(accounts)\n</code></pre></p> <p>Key methods:</p> Method Description <code>simulate(T, X, n_sims, ...)</code> Run Monte Carlo simulation <code>optimize(goals, optimizer, ...)</code> Find minimum-horizon policy <code>simulate_from_optimization(opt_result, ...)</code> Simulate with optimal policy <code>verify_goals(result, goals, ...)</code> Validate goal satisfaction <code>plot(mode, ...)</code> Unified visualization <code>cache_info()</code> Get cache statistics <code>clear_cache()</code> Free cached results"},{"location":"model/#simulation-workflow","title":"Simulation workflow","text":""},{"location":"model/#simulate-method","title":"<code>simulate()</code> method","text":"<pre><code>def simulate(\n    T: int,\n    X: np.ndarray,                    # (T, M)\n    n_sims: int = 1,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    use_cache: bool = True,\n    withdrawals: Optional[WithdrawalModel] = None\n) -&gt; SimulationResult\n</code></pre> <p>Pipeline execution:</p> <ol> <li>Cache lookup: SHA256 hash of <code>(T, X.tobytes(), n_sims, start, seed, withdrawals.to_dict())</code></li> <li>Seed propagation: <pre><code>A = income.contributions(T, start, seed=seed, n_sims=n_sims)\nR = returns.generate(T, n_sims, seed=None if seed is None else seed+1)\nD = withdrawals.to_array(T, start, accounts, n_sims, seed=seed+2)  # if provided\n</code></pre></li> <li>Wealth dynamics: <pre><code>portfolio_result = portfolio.simulate(A, R, X, D=D)\n</code></pre>    Uses wealth evolution:    $$    W_{t+1}^m = (W_t^m + A_t x_t^m - D_t^m)(1 + R_t^m)    $$</li> <li>Result packaging: Wrap arrays in <code>SimulationResult</code> dataclass</li> </ol> <p>Example: <pre><code>from datetime import date\nfrom finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\n# Basic simulation (no withdrawals)\nX = np.tile([0.7, 0.3], (24, 1))\nresult = model.simulate(T=24, X=X, n_sims=1000, seed=42)\n\n# With withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 2_000_000, date(2026, 6, 1), \"Vacation\")\n    ])\n)\nresult = model.simulate(T=24, X=X, n_sims=1000, seed=42, withdrawals=withdrawals)\n\n# Second call with same params: O(1) (cached)\nresult2 = model.simulate(T=24, X=X, n_sims=1000, seed=42, withdrawals=withdrawals)\nassert result is result2  # same object\n</code></pre></p>"},{"location":"model/#optimization-workflow","title":"Optimization workflow","text":""},{"location":"model/#optimize-method","title":"<code>optimize()</code> method","text":"<pre><code>def optimize(\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    optimizer: AllocationOptimizer,\n    T_max: int = 240,\n    n_sims: int = 500,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,\n    verbose: bool = True,\n    search_method: str = \"binary\",\n    withdrawals: Optional[WithdrawalModel] = None,\n    withdrawal_epsilon: float = 0.05,\n    **solver_kwargs\n) -&gt; OptimizationResult\n</code></pre> <p>Bilevel optimization: - Outer problem: Minimize horizon \\(T\\) - Inner problem: Find feasible allocation \\(X^*\\) at horizon \\(T\\)</p> <p>Search strategies: - <code>\"binary\"</code>: Binary search (faster, ~50% fewer iterations) - <code>\"linear\"</code>: Sequential search (safer, guaranteed to find solution)</p> <p>Example: <pre><code>from finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\n\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\n\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    search_method=\"binary\",\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(result.summary())\n</code></pre></p>"},{"location":"model/#simulate_from_optimization-method","title":"<code>simulate_from_optimization()</code> method","text":"<p>Convenience wrapper to simulate with optimal policy from optimization.</p> <pre><code>def simulate_from_optimization(\n    opt_result: OptimizationResult,\n    n_sims: int = 500,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,\n    withdrawals: Optional[WithdrawalModel] = None\n) -&gt; SimulationResult\n</code></pre> <p>Example: <pre><code># Optimize\nopt_result = model.optimize(goals, optimizer, T_max=120, n_sims=500, seed=42)\n\n# Validate with 1000 fresh scenarios\nsim_result = model.simulate_from_optimization(\n    opt_result,\n    n_sims=1000,\n    seed=999,  # Different seed for out-of-sample validation\n    withdrawals=withdrawals\n)\n</code></pre></p>"},{"location":"model/#verify_goals-method","title":"<code>verify_goals()</code> method","text":"<p>Validate goal satisfaction in simulation/optimization result.</p> <pre><code>def verify_goals(\n    result: Union[SimulationResult, OptimizationResult],\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    start: Optional[date] = None\n) -&gt; Dict[Goal, Dict[str, float]]\n</code></pre> <p>Returns: For each goal: - <code>satisfied</code>: bool - <code>violation_rate</code>: float (empirical \u2119(W &lt; threshold)) - <code>required_rate</code>: float (goal's \u03b5 = 1 - confidence) - <code>margin</code>: float (positive \u2192 satisfied) - <code>median_shortfall</code>: float - <code>n_violations</code>: int</p> <p>Example: <pre><code>status = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    if not metrics['satisfied']:\n        print(f\"VIOLATED: {goal}\")\n        print(f\"  Violation rate: {metrics['violation_rate']:.2%}\")\n        print(f\"  Shortfall: ${metrics['median_shortfall']:,.0f}\")\n</code></pre></p>"},{"location":"model/#unified-plotting-interface","title":"Unified plotting interface","text":""},{"location":"model/#plot-method","title":"<code>plot()</code> method","text":"<pre><code>def plot(\n    mode: str,\n    *,\n    T: Optional[int] = None,\n    X: Optional[np.ndarray] = None,\n    n_sims: int = 500,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    result: Optional[SimulationResult] = None,\n    goals: Optional[List] = None,\n    **kwargs\n)\n</code></pre> <p>Available modes:</p> Mode Requires Simulation Description <code>\"income\"</code> No Fixed + variable + total income streams <code>\"contributions\"</code> No Monthly contribution schedule <code>\"returns\"</code> No Return distributions and trajectories <code>\"returns_cumulative\"</code> No Cumulative return evolution <code>\"returns_horizon\"</code> No Risk-return by investment horizon <code>\"wealth\"</code> Yes Portfolio dynamics (4 panels) <code>\"comparison\"</code> Yes Multi-strategy comparison <p>Auto-simulation logic: <pre><code>IF mode in {\"wealth\", \"comparison\"}:\n    IF result provided:\n        use result\n    ELSE:\n        result = self.simulate(T, X, n_sims, start, seed)  # cached\n</code></pre></p> <p>Goals visualization: When <code>goals</code> parameter is provided to wealth plots: - TerminalGoal: Horizontal dashed line at threshold - IntermediateGoal: Dotted line with diamond marker at goal month</p> <p>Examples: <pre><code># Direct plotting (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42,\n           start=date(2025, 1, 1), goals=goals)\n\n# Reuse result across plots\nresult = model.simulate(T=24, X=X, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result, show_trajectories=True)\nmodel.plot(\"wealth\", result=result, show_trajectories=False)\n\n# Strategy comparison\nresults = {\n    \"Conservative\": model.simulate(T=24, X=X_cons, n_sims=500),\n    \"Aggressive\": model.simulate(T=24, X=X_agg, n_sims=500)\n}\nmodel.plot(\"comparison\", results=results)\n</code></pre></p>"},{"location":"model/#cache-management","title":"Cache management","text":""},{"location":"model/#inspection","title":"Inspection","text":"<pre><code>info = model.cache_info()\n# {'size': 3, 'memory_mb': 28.7}\n</code></pre> <p>Memory estimate: \\(\\approx n_{\\text{sims}} \\cdot T \\cdot M \\cdot 24\\) bytes (wealth + returns + contributions)</p>"},{"location":"model/#cache-key-components","title":"Cache key components","text":"<p>The cache key is computed via SHA256 hash of: - <code>T</code>: Horizon - <code>X.tobytes()</code>: Allocation policy bytes - <code>n_sims</code>: Number of simulations - <code>start</code>: Start date - <code>seed</code>: Random seed - <code>withdrawals.to_dict()</code>: Withdrawal configuration (if provided)</p>"},{"location":"model/#trade-offs","title":"Trade-offs","text":"<p>With cache (default): - Instant repeated calls - RAM scales with parameter space</p> <p>Without cache: <pre><code>model = FinancialModel(income, accounts, enable_cache=False)\n</code></pre> - Minimal memory - Re-simulation on every call</p> <p>Rule: Enable cache if <code>n_params \u00d7 n_sims \u00d7 T \u00d7 M \u00d7 24 &lt; 0.5 \u00d7 RAM</code>.</p>"},{"location":"model/#usage-patterns","title":"Usage patterns","text":""},{"location":"model/#a-basic-simulation-with-reproducibility","title":"A) Basic simulation with reproducibility","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04),\n    variable=VariableIncome(base=300_000, sigma=0.15, seed=100)\n)\n\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15)\n]\n\nmodel = FinancialModel(income, accounts)\n\n# Simulate\nX = np.tile([0.7, 0.3], (36, 1))\nresult = model.simulate(T=36, X=X, n_sims=2000, seed=42, start=date(2025, 1, 1))\n</code></pre>"},{"location":"model/#b-simulation-with-withdrawals","title":"B) Simulation with withdrawals","text":"<pre><code>from finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 5_000_000, date(2027, 1, 1), \"Pie departamento\")\n    ])\n)\n\nresult = model.simulate(\n    T=36, X=X, n_sims=2000, seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals\n)\n\n# Check withdrawals are recorded\nprint(result.withdrawals.shape)  # (2000, 36, 2)\n</code></pre>"},{"location":"model/#c-statistical-analysis","title":"C) Statistical analysis","text":"<pre><code># Summary statistics\nprint(result.summary(confidence=0.95))\n\n# Per-simulation metrics\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"Sharpe: {metrics['sharpe'].mean():.3f} \u00b1 {metrics['sharpe'].std():.3f}\")\n\n# Distribution-level risk\nagg = result.aggregate_metrics()\nprint(f\"VaR\u2089\u2085: ${agg.loc['Housing', 'var_95']:,.0f}\")\n</code></pre>"},{"location":"model/#d-full-optimization-workflow","title":"D) Full optimization workflow","text":"<pre><code>from finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\n# Optimize\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\nopt_result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={opt_result.T}\")\nprint(opt_result.summary())\n\n# Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"{goal.account}: {'\u2713' if metrics['satisfied'] else '\u2717'}\")\n</code></pre>"},{"location":"model/#e-visualization","title":"E) Visualization","text":"<pre><code># Pre-simulation plots\nmodel.plot(\"income\", months=24, start=date(2025, 1, 1))\nmodel.plot(\"returns_cumulative\", T=120, n_sims=500, start=date(2025, 1, 1))\n\n# Simulation-based with goals (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42,\n           start=date(2025, 1, 1), goals=goals, show_trajectories=True)\n\n# Using optimization result\nmodel.plot(\"wealth\", result=sim_result, goals=goals)\n</code></pre>"},{"location":"model/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter), where \\(F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m)\\).</p> <p>Proposition 2 (Stochastic Gradient): For independent \\(A_s\\) and \\(F_{s,t}^m\\): $$ \\mathbb{E}\\left[\\nabla_{x_s^m} W_t^m(X)\\right] = \\mathbb{E}[A_s] \\cdot \\mathbb{E}[F_{s,t}^m] $$</p> <p>Proposition 3 (Convergence Rate): For IID simulations: $$ \\left|\\hat{\\mathbb{E}}_n[W_T] - \\mathbb{E}[W_T]\\right| = O_p\\left(\\frac{1}{\\sqrt{n}}\\right) $$</p>"},{"location":"model/#seed-propagation","title":"Seed propagation","text":"<p>To ensure statistical independence while maintaining reproducibility:</p> Component Seed Used Purpose Income <code>seed</code> Stochastic contributions (VariableIncome) Returns <code>seed + 1</code> Correlated lognormal returns Withdrawals <code>seed + 2</code> Stochastic withdrawals <p>This ensures that changing the income model doesn't affect return scenarios (and vice versa), while maintaining full reproducibility when the same seed is used.</p>"},{"location":"model/#limitations","title":"Limitations","text":"<ol> <li> <p>Cache doesn't detect component mutations: Call <code>model.clear_cache()</code> after modifying <code>income</code> or <code>accounts</code> in-place.</p> </li> <li> <p>Fixed horizon T per simulation: For dynamic \\(T\\) optimization, use <code>optimize()</code> method.</p> </li> <li> <p>Constant correlation matrix: \\(\\Sigma\\) fixed over time (no regime-switching).</p> </li> <li> <p>Cache memory: Large parameter sweeps can consume significant RAM.</p> </li> </ol>"},{"location":"model/#complete-example","title":"Complete example","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\nfrom finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\n# 1. Setup income\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04,\n                     salary_raises={date(2025, 7, 1): 200_000}),\n    variable=VariableIncome(base=300_000, sigma=0.15,\n                           seasonality=[1.0, 0.9, 1.1, 1.0, 1.2, 1.1,\n                                       1.0, 0.9, 0.95, 1.05, 1.1, 1.3],\n                           seed=100)\n)\n\n# 2. Setup accounts\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06,\n                        display_name=\"Fondo de Emergencia\"),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15,\n                        display_name=\"Ahorro Vivienda\")\n]\n\n# 3. Create model\nmodel = FinancialModel(income, accounts)\n\n# 4. Define withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 5_000_000, date(2027, 6, 1), \"Pie departamento\")\n    ])\n)\n\n# 5. Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 12, 1), account=\"Emergency\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"Housing\", threshold=30_000_000, confidence=0.90)\n]\n\n# 6. Optimize\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\nopt_result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=60,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05,\n    verbose=True\n)\n\nprint(f\"\\n=== Optimization Result ===\")\nprint(f\"Optimal horizon: T*={opt_result.T} months\")\nprint(opt_result.summary())\n\n# 7. Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(\n    opt_result,\n    n_sims=1000,\n    seed=999,\n    withdrawals=withdrawals\n)\n\n# 8. Check goals\nstatus = model.verify_goals(sim_result, goals)\nprint(\"\\n=== Goal Validation ===\")\nfor goal, metrics in status.items():\n    symbol = \"\u2713\" if metrics['satisfied'] else \"\u2717\"\n    print(f\"[{symbol}] {goal.account}: {metrics['violation_rate']:.1%} violations\")\n\n# 9. Statistical summary\nprint(\"\\n=== Final Wealth Summary ===\")\nprint(sim_result.summary(confidence=0.95))\n\n# 10. Visualize\nmodel.plot(\"wealth\", result=sim_result, goals=goals,\n           title=\"Optimized Portfolio with Withdrawals\",\n           show_trajectories=True)\n\n# 11. Cache info\nprint(f\"\\nCache: {model.cache_info()}\")\n</code></pre>"},{"location":"model/#references","title":"References","text":"<p>Internal modules: - income.py: Generates \\(A_t\\) (contributions) with fixed + variable streams - returns.py: Generates \\(R_t^m\\) (correlated lognormal returns) - withdrawal.py: Generates \\(D_t^m\\) (scheduled + stochastic withdrawals) - portfolio.py: Executes \\(W_{t+1}^m = (W_t^m + A_t x_t^m - D_t^m)(1 + R_t^m)\\) - goals.py: Defines chance constraints for optimization - optimization.py: Implements CVaR reformulation and bilevel search</p>"},{"location":"optimization/","title":"<code>optimization</code> \u2014 Convex Programming for Goal-Driven Portfolios","text":"<p>Core idea: Transform financial goals into convex optimization problems via CVaR reformulation, searching over horizons to find minimum feasible time and optimal allocations.</p>"},{"location":"optimization/#philosophy-and-role","title":"Philosophy and Role","text":""},{"location":"optimization/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li><code>income.py</code> \u2192 Contribution scenarios \\(A_t\\)</li> <li><code>portfolio.py</code> \u2192 Wealth dynamics \\(W_t^m(X)\\) via affine representation</li> <li><code>goals.py</code> \u2192 Goal specifications as chance constraints</li> <li><code>optimization.py</code> \u2192 Decision synthesis: minimize \\(T\\), optimize allocations \\(X\\)</li> </ul>"},{"location":"optimization/#inversion-of-traditional-planning","title":"Inversion of Traditional Planning","text":"<p>Traditional: Given savings \\(X\\) and horizon \\(T\\), compute terminal wealth FinOpt: Given wealth goals, find minimum \\(T^*\\) and optimal \\(X^*\\)</p> <p>Requires: 1. Chance-constrained formulation: \\(\\mathbb{P}(W_t^m \\geq b) \\geq 1-\\varepsilon\\) 2. Convex reformulation via CVaR 3. Bilevel optimization: outer (minimize \\(T\\)), inner (convex program)</p>"},{"location":"optimization/#mathematical-foundations","title":"Mathematical Foundations","text":""},{"location":"optimization/#wealth-evolution","title":"Wealth Evolution","text":"<p>Multiple accounts \\(m \\in \\{1,\\dots,M\\}\\):</p> \\[ W_{t+1}^m = \\big(W_t^m + A_t x_t^m - D_t^m\\big)(1 + R_t^m) \\] <p>where \\(D_t^m\\) is the withdrawal from account \\(m\\) at time \\(t\\).</p> <p>Closed-form (affine representation):</p> \\[ \\boxed{ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\, x_s^m - D_s^m\\big) \\, F_{s,t}^m } \\] <p>where accumulation factor:</p> \\[ F_{s,t}^m := \\prod_{\\tau=s+1}^{t} (1 + R_\\tau^m) \\] <p>Key consequences: - Affinity: \\(W_t^m(X)\\) linear in \\(X\\) (withdrawals \\(D\\) are parameters) \u2192 enables convex programming - Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) \u2192 analytical derivatives - Efficiency: \\(O(1)\\) wealth evaluation, no recursion</p>"},{"location":"optimization/#allocation-simplex","title":"Allocation Simplex","text":"<p>Decision variables satisfy budget constraint:</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} : x_t^m \\geq 0, \\; \\sum_{m=1}^M x_t^m = 1, \\; \\forall t \\right\\} \\] <p>Cartesian product of \\(T\\) probability simplices: \\(\\mathcal{X}_T = \\Delta^{M-1} \\times \\cdots \\times \\Delta^{M-1}\\).</p>"},{"location":"optimization/#bilevel-optimization","title":"Bilevel Optimization","text":""},{"location":"optimization/#problem-statement","title":"Problem Statement","text":"\\[ \\boxed{ \\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\mathcal{F}_T \\neq \\emptyset } \\] <p>where goal-feasible set:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\mathbb{P}\\big(W_t^m(X) \\geq b_t^m\\big) \\geq 1-\\varepsilon_t^m, \\; \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\geq b^m\\big) \\geq 1-\\varepsilon^m, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\\\ &amp; \\mathbb{P}\\big(W_t^m(X) \\geq D_t^m\\big) \\geq 1-\\delta, \\; \\forall \\text{ withdrawals} \\end{aligned} \\right\\} \\] <p>Inner problem (fixed \\(T\\)): $$ \\max_{X \\in \\mathcal{F}_T} f(X) $$</p>"},{"location":"optimization/#implemented-objectives","title":"Implemented Objectives","text":"<p>All objectives exploit affine wealth \\(W_t^m(X) = b + \\Phi X\\) for convexity:</p> Objective Formula Type Use Case <code>\"risky\"</code> \\(\\mathbb{E}\\left[\\sum_{m} W_T^m\\right]\\) LP Maximum wealth accumulation <code>\"balanced\"</code> \\(-\\sum_{t,m}(x_{t+1,m} - x_t^m)^2\\) QP Stable allocations (default) <code>\"conservative\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\cdot \\text{Var}(W_T)\\) QP Risk-averse mean-variance <code>\"risky_turnover\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\cdot \\sum(\\Delta x)^2\\) QP Wealth + stability tradeoff <p>Note: The <code>conservative</code> objective uses variance (not standard deviation) in the CVXPY formulation for DCP compliance.</p>"},{"location":"optimization/#cvar-reformulation","title":"CVaR Reformulation","text":""},{"location":"optimization/#epigraphic-formulation-rockafellar-uryasev-2000","title":"Epigraphic Formulation (Rockafellar &amp; Uryasev 2000)","text":"<p>Transform chance constraint \\(\\mathbb{P}(W \\geq b) \\geq 1-\\varepsilon\\) into convex constraint:</p> \\[ \\text{CVaR}_\\varepsilon(b - W) \\leq 0 \\] <p>Epigraphic representation: $$ \\text{CVaR}\\alpha(L) = \\min^N z^i \\right} $$ subject to: $$ z^i \\geq L^i - \\gamma, \\quad z^i \\geq 0, \\quad \\forall i $$} \\left{ \\gamma + \\frac{1}{\\alpha N} \\sum_{i=1</p> <p>where \\(L^i = b - W^i\\) is shortfall in scenario \\(i\\).</p>"},{"location":"optimization/#convex-program-formulation","title":"Convex Program Formulation","text":"<p>Decision variables: - \\(X \\in \\mathbb{R}^{T \\times M}\\): allocations - \\(\\gamma_g \\in \\mathbb{R}\\): VaR level per goal \\(g\\) - \\(z_g \\in \\mathbb{R}_+^N\\): excess shortfall per goal \\(g\\)</p> <p>Constraints:</p> <ol> <li> <p>Simplex: \\(\\sum_m x_t^m = 1, \\; x_t^m \\geq 0\\)</p> </li> <li> <p>CVaR (per goal): $$ \\begin{aligned} z_g^i &amp;\\geq (\\text{threshold}g - W(X)) - \\gamma_g \\ \\gamma_g &amp;+ \\frac{1}{\\varepsilon_g N} \\sum_{i=1}^N z_g^i \\leq 0 \\end{aligned} $$}^{m_g,i</p> </li> <li> <p>Withdrawal feasibility (per withdrawal): $$ \\begin{aligned} z_w^i &amp;\\geq (D_t^m - W_t^{m,i}(X)) - \\gamma_w \\ \\gamma_w &amp;+ \\frac{1}{\\delta N} \\sum_{i=1}^N z_w^i \\leq 0 \\end{aligned} $$</p> </li> </ol>"},{"location":"optimization/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"optimization/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>OptimizationResult (frozen dataclass)\n    \u251c\u2500 X: np.ndarray (T, M)\n    \u251c\u2500 T: int\n    \u251c\u2500 objective_value: float\n    \u251c\u2500 feasible: bool\n    \u251c\u2500 goals: List[IntermediateGoal | TerminalGoal]\n    \u251c\u2500 goal_set: GoalSet\n    \u251c\u2500 solve_time: float\n    \u251c\u2500 validate_goals(result) \u2192 dict\n    \u251c\u2500 is_valid_allocation(tol) \u2192 bool\n    \u2514\u2500 summary() \u2192 str\n\nAllocationOptimizer (ABC)\n    \u251c\u2500 solve(T, A, R, initial_wealth, goal_set, D, ...) \u2192 OptimizationResult\n    \u251c\u2500 _check_feasibility(...) \u2192 bool\n    \u2514\u2500 _compute_objective(W, X, T, M) \u2192 float\n\nCVaROptimizer(AllocationOptimizer)\n    \u251c\u2500 cp: CVXPY module\n    \u251c\u2500 objective: str \u2208 {\"risky\", \"balanced\", \"risky_turnover\", \"conservative\"}\n    \u2514\u2500 solve(..., D, withdrawal_epsilon, ...) \u2192 OptimizationResult\n\nGoalSeeker\n    \u251c\u2500 optimizer: AllocationOptimizer\n    \u251c\u2500 seek(..., D_generator, withdrawal_epsilon, search_method) \u2192 OptimizationResult\n    \u251c\u2500 _linear_search(...) \u2192 OptimizationResult\n    \u2514\u2500 _binary_search(...) \u2192 OptimizationResult\n</code></pre>"},{"location":"optimization/#key-design-patterns","title":"Key Design Patterns","text":"<p>GoalSet passed explicitly: Caller creates <code>GoalSet</code> once before optimization loop:</p> <pre><code># In GoalSeeker.seek()\ngoal_set = GoalSet(goals, accounts, start_date)\n\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(\n        T=T, A=A, R=R, initial_wealth=initial_wealth,\n        goal_set=goal_set,  # Pre-validated, reused\n        D=D,                # Withdrawals (optional)\n        withdrawal_epsilon=0.05,\n        **solver_kwargs\n    )\n</code></pre> <p>Separation of responsibilities: - <code>GoalSet</code>: Validation, account resolution, minimum horizon estimation - <code>AllocationOptimizer</code>: Convex programming, feasibility checking - <code>GoalSeeker</code>: Bilevel search, warm starting</p>"},{"location":"optimization/#cvaroptimizer-api","title":"CVaROptimizer API","text":""},{"location":"optimization/#constructor","title":"Constructor","text":"<pre><code>from finopt.src.optimization import CVaROptimizer\n\noptimizer = CVaROptimizer(\n    n_accounts=3,\n    objective='balanced',           # Default: turnover minimization\n    objective_params={'lambda': 0.5},  # For conservative/risky_turnover\n    account_names=['Emergency', 'Housing', 'Retirement']\n)\n</code></pre>"},{"location":"optimization/#solve-method","title":"solve() Method","text":"<pre><code>result = optimizer.solve(\n    T=24,                          # Horizon (months)\n    A=A_scenarios,                 # (n_sims, T) contributions\n    R=R_scenarios,                 # (n_sims, T, M) returns\n    initial_wealth=np.array([1e6, 0.5e6, 2e6]),  # (M,)\n    goal_set=goal_set,             # Pre-validated GoalSet (REQUIRED)\n    X_init=None,                   # Warm start (optional, ignored by CVXPY)\n    D=withdrawal_matrix,           # (T, M) or (n_sims, T, M) withdrawals\n    withdrawal_epsilon=0.05,       # 95% confidence for withdrawals\n    solver='CLARABEL',             # Solver: CLARABEL, ECOS, SCS\n    verbose=True,\n    max_iters=10000,\n    abstol=1e-7,\n    reltol=1e-6\n)\n</code></pre>"},{"location":"optimization/#withdrawal-support","title":"Withdrawal Support","text":"<p>Withdrawals \\(D\\) can be: - Deterministic: Shape <code>(T, M)</code> \u2014 same withdrawal across all scenarios - Stochastic: Shape <code>(n_sims, T, M)</code> \u2014 per-scenario withdrawals</p> <p>Withdrawal feasibility constraint (Conservative - Option 1): <pre><code>\u2119(W_t^m \u2265 D_t^m) \u2265 1 - withdrawal_epsilon\n</code></pre></p> <p>Ensures sufficient wealth before each withdrawal, without relying on contributions.</p> <p>Implementation: <pre><code># CVaR reformulation for withdrawal constraint\n# Shortfall: D_t - W_t (positive = cannot meet withdrawal)\nshortfall = D_tm - W_pre_withdrawal\n\n# CVaR epigraphic constraints\nz_wd &gt;= shortfall - gamma_wd\ngamma_wd + sum(z_wd) / (withdrawal_epsilon * n_sims) &lt;= 0\n</code></pre></p> <p>Since \\(D\\) is a parameter (not decision variable), convexity is preserved.</p>"},{"location":"optimization/#goalseeker-api","title":"GoalSeeker API","text":""},{"location":"optimization/#constructor_1","title":"Constructor","text":"<pre><code>from finopt.src.optimization import GoalSeeker\n\nseeker = GoalSeeker(\n    optimizer=optimizer,\n    T_max=120,       # Maximum search horizon\n    verbose=True\n)\n</code></pre>"},{"location":"optimization/#seek-method","title":"seek() Method","text":"<pre><code>from datetime import date\n\n# Generator functions for scenarios\ndef A_gen(T, n_sims, seed):\n    return model.income.contributions(T, n_sims=n_sims, seed=seed, output=\"array\")\n\ndef R_gen(T, n_sims, seed):\n    return model.returns.generate(T, n_sims=n_sims, seed=seed)\n\n# Optional: withdrawal generator\ndef D_gen(T, n_sims, seed):\n    # Example: $500K withdrawal at month 12 from account 0\n    D = np.zeros((T, M))\n    if T &gt; 12:\n        D[12, 0] = 500_000\n    return D\n\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=np.array([1e6, 0.5e6]),\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\",        # \"binary\" or \"linear\"\n    D_generator=D_gen,             # Optional withdrawals\n    withdrawal_epsilon=0.05,       # 95% confidence\n    solver='CLARABEL',\n    verbose=True\n)\n</code></pre>"},{"location":"optimization/#search-strategies","title":"Search Strategies","text":""},{"location":"optimization/#linear-search-safe-slower","title":"Linear Search (Safe, Slower)","text":"<p>Algorithm: <pre><code>X_prev = None\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(T, A, R, initial_wealth, goal_set, D, X_init=X_prev)\n    if result.feasible:\n        return result  # Found T*\n    # Warm start: extend policy\n    if result.X is not None:\n        X_prev = np.vstack([result.X, result.X[-1:, :]])\n</code></pre></p> <p>Complexity: \\(O(T^* - T_{\\text{start}})\\) iterations</p> <p>Properties: - Always finds true \\(T^*\\) if feasible - No assumptions required - Warm start accelerates convergence</p>"},{"location":"optimization/#binary-search-faster-assumes-monotonicity","title":"Binary Search (Faster, Assumes Monotonicity)","text":"<p>Algorithm: <pre><code>left, right = T_start, T_max\nbest_result = None\n\nwhile left &lt; right:\n    mid = (left + right) // 2\n    result = optimizer.solve(mid, ...)\n\n    if result.feasible:\n        best_result = result\n        right = mid  # Search lower half\n    else:\n        left = mid + 1  # Search upper half\n\nreturn best_result\n</code></pre></p> <p>Complexity: \\(O(\\log(T_{\\max} - T_{\\text{start}}))\\) iterations</p> <p>Assumption: Monotonicity \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p> <p>When to use: - Typical financial planning scenarios (safe) - Contribution schedules are non-decreasing or stable - Goal structure is well-behaved</p> <p>When to avoid: - Contributions have sudden drops - Pathological goal configurations - Safety-critical applications \u2192 use linear search</p>"},{"location":"optimization/#solver-configuration","title":"Solver Configuration","text":""},{"location":"optimization/#available-solvers","title":"Available Solvers","text":"Solver Type Speed Stability Default CLARABEL Interior-point Balanced Good \u2713 ECOS Interior-point (LP/SOCP) Fast Good for well-conditioned SCS First-order conic Moderate Handles ill-conditioned"},{"location":"optimization/#solver-options-mapping","title":"Solver Options Mapping","text":"<p>The API uses standard option names that are mapped to solver-specific options:</p> <pre><code># Standard options\nresult = optimizer.solve(\n    ...,\n    solver='CLARABEL',\n    max_iters=10000,\n    abstol=1e-7,\n    reltol=1e-6\n)\n</code></pre> <p>Option mapping:</p> Standard ECOS SCS CLARABEL <code>max_iters</code> <code>max_iters</code> <code>max_iters</code> <code>max_iter</code> <code>abstol</code> <code>abstol</code> <code>eps_abs</code> <code>tol_gap_abs</code> <code>reltol</code> <code>reltol</code> <code>eps_rel</code> <code>tol_gap_rel</code>"},{"location":"optimization/#complexity-analysis","title":"Complexity Analysis","text":"<p>Variables: \\(T \\cdot M + G \\cdot (1 + N) + W \\cdot (1 + N)\\) - \\(T \\cdot M\\) allocations \\(X\\) - \\(G\\) VaR levels \\(\\gamma_g\\) + \\(G \\cdot N\\) excess shortfalls \\(z_g^i\\) - \\(W\\) withdrawal constraints (if applicable)</p> <p>Example: \\(T=24, M=3, G=3, N=300, W=2\\) - Variables: \\(72 + 903 + 602 = 1577\\) - Solve time: 30-100ms (CLARABEL)</p>"},{"location":"optimization/#optimizationresult","title":"OptimizationResult","text":""},{"location":"optimization/#attributes","title":"Attributes","text":"<pre><code>@dataclass(frozen=True)\nclass OptimizationResult:\n    X: np.ndarray              # Optimal allocation policy (T, M)\n    T: int                     # Horizon\n    objective_value: float     # f(X*)\n    feasible: bool             # All goals satisfied?\n    goals: List[...]           # Original goal specs\n    goal_set: GoalSet          # Validated collection\n    solve_time: float          # Solver time (seconds)\n    n_iterations: Optional[int]\n    diagnostics: Optional[dict]\n</code></pre>"},{"location":"optimization/#methods","title":"Methods","text":"<p>summary() \u2014 Human-readable output: <pre><code>print(result.summary())\n# OptimizationResult(\n#   Status: \u2713 Feasible\n#   Horizon: T=24 months\n#   Objective: 11234567.89\n#   Goals: 3 (1 intermediate, 2 terminal)\n#   Solve time: 0.342s\n#   Iterations: N/A\n# )\n</code></pre></p> <p>validate_goals(result) \u2014 Post-simulation validation: <pre><code>sim_result = model.simulate(T=result.T, X=result.X, n_sims=1000, seed=999)\nstatus = result.validate_goals(sim_result)\n\nfor goal, metrics in status.items():\n    print(f\"{goal.account}: {metrics['violation_rate']:.2%} violations\")\n</code></pre></p> <p>is_valid_allocation(tol) \u2014 Check simplex constraints: <pre><code>if not result.is_valid_allocation(tol=1e-6):\n    print(\"Warning: allocation violates simplex constraints\")\n</code></pre></p>"},{"location":"optimization/#diagnostics-and-debugging","title":"Diagnostics and Debugging","text":""},{"location":"optimization/#verbose-output","title":"Verbose Output","text":"<p>Enable <code>verbose=True</code> for detailed solver information:</p> <pre><code>[CVXPY Solution]\n  Status: optimal\n  Objective: 21543678.92\n  Solve time: 0.067s\n\n[Simplex Validation]\n  Max |\u03a3x_t - 1|: 3.45e-09\n  X bounds: [0.0000, 1.0000]\n\n[Goal Satisfaction Diagnostics]\n  Account 0 (Emergency):\n    Threshold:        5,500,000\n    Mean wealth:      6,234,567\n    Violation rate: 8.20% (max: 10.00%)\n    CVaR value:         -1234.56 (target: \u2264 0)\n\n[Withdrawal Feasibility Diagnostics]\n  Confidence level: 95% (\u03b5=5%)\n  \u2713 Period 11, Account 0 (Emergency Fund):\n    Withdrawal D_11:      500,000\n    Wealth W_11:        1,234,567\n    Violation rate:    2.30% (max: 5.00%)\n    CVaR value:          -5678.90 (target: \u2264 0)\n</code></pre>"},{"location":"optimization/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>1. Infeasible problem: <pre><code>Status: infeasible\n</code></pre> Solutions: - Increase <code>T_max</code> (extend planning horizon) - Reduce goal thresholds - Increase <code>epsilon</code> (lower confidence: 0.90 \u2192 0.85) - Increase contributions - Reduce withdrawal amounts</p> <p>2. Numerical instability: <pre><code>Max |\u03a3x_t - 1|: 1.23e-04\n\u26a0\ufe0f  Minor simplex violations detected\n</code></pre> Solutions: - Tighten solver tolerances: <code>abstol=1e-8, reltol=1e-7</code> - Switch solver: <code>CLARABEL</code> \u2192 <code>SCS</code> - Check for extreme returns</p> <p>3. Binary search failure: <pre><code>InfeasibleError: Binary search failed: T=87 infeasible\nMonotonicity assumption may be violated\n</code></pre> Solutions: - Switch to linear search: <code>search_method=\"linear\"</code> - Inspect contribution schedule for sudden drops - Verify goal configuration</p> <p>4. Withdrawal infeasibility: <pre><code>Withdrawal constraint violated at T=12\n</code></pre> Solutions: - Increase <code>withdrawal_epsilon</code> (0.05 \u2192 0.10) - Reduce withdrawal amount - Extend horizon to allow more accumulation - Prioritize liquidity in allocation</p>"},{"location":"optimization/#complete-examples","title":"Complete Examples","text":""},{"location":"optimization/#basic-optimization-with-goals","title":"Basic Optimization with Goals","text":"<pre><code>from datetime import date\nfrom finopt.src.optimization import CVaROptimizer, GoalSeeker\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.portfolio import Account\nimport numpy as np\n\n# Setup accounts\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05, initial_wealth=1_000_000),\n    Account.from_annual(\"Housing\", 0.07, 0.12, initial_wealth=500_000)\n]\ninitial_wealth = np.array([1_000_000, 500_000])\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=2_000_000, confidence=0.95),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\n# Create optimizer\noptimizer = CVaROptimizer(\n    n_accounts=len(accounts),\n    objective='balanced',\n    account_names=[a.name for a in accounts]\n)\n\n# Generator functions\ndef A_gen(T, n, s):\n    return np.full((n, T), 500_000)  # $500K/month\n\ndef R_gen(T, n, s):\n    np.random.seed(s)\n    return np.random.normal(0.005, 0.02, (n, T, 2))\n\n# Find minimum horizon\nseeker = GoalSeeker(optimizer, T_max=120, verbose=True)\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\"\n)\n\nprint(result.summary())\n</code></pre>"},{"location":"optimization/#optimization-with-withdrawals","title":"Optimization with Withdrawals","text":"<pre><code># Define withdrawal schedule\ndef D_gen(T, n_sims, seed):\n    \"\"\"$1M withdrawal from Housing account at month 24.\"\"\"\n    D = np.zeros((T, 2))\n    if T &gt; 24:\n        D[24, 1] = 1_000_000  # Account 1 = Housing\n    return D\n\n# Seek with withdrawals\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\",\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05  # 95% confidence\n)\n</code></pre>"},{"location":"optimization/#custom-objective-with-turnover-penalty","title":"Custom Objective with Turnover Penalty","text":"<pre><code>optimizer = CVaROptimizer(\n    n_accounts=3,\n    objective='risky_turnover',\n    objective_params={'lambda': 10000},  # Turnover penalty weight\n    account_names=[\"Emergency\", \"Housing\", \"Retirement\"]\n)\n</code></pre>"},{"location":"optimization/#theoretical-guarantees","title":"Theoretical Guarantees","text":"<p>Theorem 1 (Affine Wealth Representation): For any allocation policy \\(X \\in \\mathcal{X}_T\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter), enabling convex programming.</p> <p>Theorem 2 (CVaR Epigraphic Convexity): The epigraphic reformulation defines a convex constraint in \\(X\\) when \\(W(X)\\) is affine.</p> <p>Theorem 3 (Global Optimality): CVXPY interior-point solvers return global optimum for convex programs. No local minima exist.</p> <p>Theorem 4 (Bilevel Optimality): - Linear search: Finds true \\(T^*\\) if inner solver succeeds - Binary search: Finds \\(T^*\\) under monotonicity assumption \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p>"},{"location":"optimization/#exceptions","title":"Exceptions","text":"<p>The module raises <code>InfeasibleError</code> when no feasible solution is found:</p> <pre><code>from finopt.src.exceptions import InfeasibleError\n\ntry:\n    result = seeker.seek(...)\nexcept InfeasibleError as e:\n    print(f\"Optimization failed: {e}\")\n    # Suggestions: increase T_max, relax goals, increase contributions\n</code></pre>"},{"location":"optimization/#references","title":"References","text":"<p>Rockafellar, R.T. and Uryasev, S. (2000). Optimization of conditional value-at-risk. Journal of Risk, 2, 21-42.</p> <p>Markowitz, H. (1952). Portfolio Selection. The Journal of Finance, 7(1), 77-91.</p>"},{"location":"portfolio/","title":"<code>portfolio</code> \u2014 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Execute wealth dynamics under allocation policies, providing the mathematical foundation for optimization-driven portfolio construction. <code>portfolio.py</code> is the executor layer: it receives pre-generated contributions <code>A</code> (from <code>income.py</code>), returns <code>R</code> (from <code>returns.py</code>), and withdrawals <code>D</code>, applies allocation policy <code>X</code>, and computes wealth trajectories <code>W</code> via recursive or closed-form methods.</p>"},{"location":"portfolio/#why-a-dedicated-portfolio-module","title":"Why a dedicated portfolio module?","text":"<p>Financial optimization requires separating concerns: - <code>income.py</code> \u2192 cash availability (contributions <code>A</code>) - <code>returns.py</code> \u2192 stochastic return generation (<code>R</code>) - <code>portfolio.py</code> \u2192 wealth evolution given allocations (<code>W</code>) - <code>goals.py</code> \u2192 goal specifications - <code>optimization.py</code> \u2192 policy search</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to <code>ReturnModel</code>) - Optimization-ready: Affine wealth representation exposes analytical gradients - Batch processing: Vectorized Monte Carlo execution (no Python loops) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion - Withdrawal support: Handles scheduled or stochastic withdrawals <code>D</code></p>"},{"location":"portfolio/#design-principles","title":"Design principles","text":"<ol> <li>Separation of concerns</li> <li>Portfolio executes dynamics, does NOT generate stochastic processes</li> <li> <p>Returns/contributions/withdrawals are external inputs (not embedded models)</p> </li> <li> <p>Vectorized computation</p> </li> <li>Full batch processing: <code>(n_sims, T, M)</code> arrays without Python-level loops</li> <li> <p>Matches <code>income.py</code> pattern: <code>n_sims</code> parameter for Monte Carlo generation</p> </li> <li> <p>Optimization-first design</p> </li> <li>Affine wealth formula enables analytical gradients: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\)</li> <li> <p>Direct integration with convex solvers (CVXPY)</p> </li> <li> <p>Annual parameters by default</p> </li> <li>User-facing API uses intuitive annual returns/volatility</li> <li>Internal storage in monthly space (canonical form)</li> <li> <p>Properties provide dual temporal views without conversions</p> </li> <li> <p>Flexible naming</p> </li> <li>Short <code>name</code> for goal specification (e.g., \"RN\", \"CC\")</li> <li>Optional <code>display_name</code> for plots (e.g., \"Risky Norris (Fintual)\")</li> <li><code>label</code> property returns display_name if set, otherwise name</li> </ol>"},{"location":"portfolio/#the-two-core-surfaces","title":"The two core surfaces","text":""},{"location":"portfolio/#1-account","title":"1) <code>Account</code>","text":"<p>Frozen dataclass metadata container for investment account with dual temporal parameter access and flexible naming.</p> <p>Parameters: - <code>name</code>: Short account identifier for goal references (e.g., \"RN\", \"CC\", \"SLV\") - <code>initial_wealth</code>: Starting balance \\(W_0^m\\) (non-negative) - <code>return_strategy</code>: dict with monthly parameters <code>{\"mu\": float, \"sigma\": float}</code> - <code>display_name</code>: Optional long descriptive name for plots (e.g., \"Risky Norris (Fintual)\")</p> <p>Constructor methods (recommended): <pre><code># With display_name (recommended for clarity)\nAccount.from_annual(\n    name=\"RN\",\n    annual_return=0.12,\n    annual_volatility=0.15,\n    initial_wealth=0.0,\n    display_name=\"Risky Norris (Fintual)\"\n)\n\n# Without display_name (backward compatible)\nAccount.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05)\n\n# From monthly parameters (advanced)\nAccount.from_monthly(\"TAC\", monthly_mu=0.0058, monthly_sigma=0.0347)\n</code></pre></p> <p>Properties: - <code>label</code>: Display name for plots (returns <code>display_name</code> if set, otherwise <code>name</code>) - <code>monthly_params</code>: Canonical storage format <code>{\"mu\": float, \"sigma\": float}</code> - <code>annual_params</code>: User-friendly view <code>{\"return\": float, \"volatility\": float}</code></p> <p>Parameter conversion: $$ \\begin{aligned} \\mu_{\\text{monthly}} &amp;= (1 + r_{\\text{annual}})^{1/12} - 1 \\quad \\text{[geometric compounding]} \\ \\sigma_{\\text{monthly}} &amp;= \\frac{\\sigma_{\\text{annual}}}{\\sqrt{12}} \\quad \\text{[time scaling]} \\end{aligned} $$</p> <p>Example with display_name: <pre><code># Short name for goal specification\nrisky = Account.from_annual(\"RN\", annual_return=0.12, annual_volatility=0.15,\n                            display_name=\"Risky Norris (Fintual)\")\n\nprint(risky.name)   # 'RN' - used in goals\nprint(risky.label)  # 'Risky Norris (Fintual)' - shown in plots\n\n# Goal uses short name\ngoal = TerminalGoal(account=\"RN\", threshold=5_000_000, confidence=0.8)\n</code></pre></p>"},{"location":"portfolio/#2-portfolio","title":"2) <code>Portfolio</code>","text":"<p>Multi-account wealth dynamics executor with allocation policy and withdrawal support.</p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects (metadata only, no return models)</p> <p>Properties: - <code>M</code>: Number of accounts - <code>account_names</code>: List of account names - <code>initial_wealth_vector</code>: Initial wealth array <code>W0</code> from accounts</p> <p>Method signature: <pre><code>def simulate(\n    self,\n    A: np.ndarray,      # Contributions: (T,) or (n_sims, T)\n    R: np.ndarray,      # Returns: (n_sims, T, M)\n    X: np.ndarray,      # Allocations: (T, M)\n    D: np.ndarray = None,  # Withdrawals: (T, M) or (n_sims, T, M)\n    method: Literal[\"recursive\", \"affine\"] = \"recursive\",\n    initial_wealth: np.ndarray = None  # Override W0\n) -&gt; dict\n</code></pre></p> <p>Core wealth dynamics (with withdrawals): $$ W_{t+1}^m = \\big(W_t^m + A_t^m - D_t^m\\big)(1 + R_t^m) $$ where: - \\(A_t^m = x_t^m \\cdot A_t\\) (allocated contribution) - \\(D_t^m\\) = withdrawal from account \\(m\\) at time \\(t\\) - \\(\\sum_{m=1}^M x_t^m = 1\\), \\(x_t^m \\geq 0\\) (budget constraint)</p> <p>Returns: <pre><code>{\n    \"wealth\": np.ndarray,        # (n_sims, T+1, M)\n    \"total_wealth\": np.ndarray   # (n_sims, T+1)\n}\n</code></pre></p> <p>Computation methods:</p> Method Default Time Memory Use Case <code>\"recursive\"</code> \u2713 \\(O(n \\cdot T \\cdot M)\\) \\(O(n \\cdot T \\cdot M)\\) Simulation, large T <code>\"affine\"</code> \\(O(T^2 \\cdot M \\cdot n)\\) \\(O(n \\cdot T^2 \\cdot M)\\) Optimization, gradients"},{"location":"portfolio/#withdrawal-support","title":"Withdrawal Support","text":"<p>Withdrawals <code>D</code> can be provided as: - Deterministic: Shape <code>(T, M)</code> \u2014 same withdrawal schedule across all scenarios - Stochastic: Shape <code>(n_sims, T, M)</code> \u2014 per-scenario withdrawals - None: No withdrawals (default)</p> <p>Example: <pre><code># Deterministic: $500K from Housing account at month 12\nD = np.zeros((T, M))\nD[12, 1] = 500_000  # Account 1 = Housing\n\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre></p> <p>In optimization: Withdrawals are treated as parameters (not decision variables), preserving convexity: $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s x_s^m - D_s^m\\big) F_{s,t}^m $$</p>"},{"location":"portfolio/#affine-wealth-representation","title":"Affine wealth representation","text":""},{"location":"portfolio/#closed-form-formula","title":"Closed-form formula","text":"<p>The recursive dynamics admit a closed-form solution:</p> \\[ \\boxed{ W_t^m(X) = W_0^m \\cdot F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\, x_s^m - D_s^m\\big) \\, F_{s,t}^m } \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Convention: \\(F_{s,s}^m = 1\\) (no accumulation over empty interval).</p>"},{"location":"portfolio/#mathematical-properties","title":"Mathematical properties","text":"<ol> <li> <p>Affine in \\(X\\):    Since \\(D\\) is a parameter (not decision variable), wealth remains affine in \\(X\\):    $$    W_t^m(\\alpha X + \\beta Y) = \\alpha W_t^m(X) + \\beta W_t^m(Y) + \\text{const}    $$</p> </li> <li> <p>Analytical gradient:    $$    \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s \\, F_{s,t}^m, \\quad s &lt; t    $$    Enables gradient-based optimization without numerical differentiation.</p> </li> <li> <p>Monotonicity:    If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m\\) is strictly increasing in \\(x_s^m\\).</p> </li> </ol>"},{"location":"portfolio/#accumulation-factors-computation","title":"Accumulation factors computation","text":"<p>Method signature: <pre><code>def compute_accumulation_factors(self, R: np.ndarray) -&gt; np.ndarray\n</code></pre></p> <p>Input: Returns matrix <code>R</code> of shape <code>(n_sims, T, M)</code> Output: Factors tensor <code>F</code> of shape <code>(n_sims, T+1, T+1, M)</code></p> <p>Memory estimates: - <code>n_sims=500, T=24, M=2</code>: ~115 MB - <code>n_sims=500, T=120, M=5</code>: ~14 GB - <code>n_sims=1000, T=240, M=10</code>: ~221 GB (infeasible)</p> <p>For \\(T &gt; 100\\), consider: - Using <code>method=\"recursive\"</code> (no \\(F\\) precomputation) - Batching simulations (chunking <code>n_sims</code>) - On-the-fly gradient computation</p>"},{"location":"portfolio/#initial-wealth-override","title":"Initial Wealth Override","text":"<p>The <code>initial_wealth</code> parameter allows overriding the initial wealth vector without creating temporary Account objects:</p> <pre><code># Accounts have initial_wealth=0, but optimization needs non-zero W0\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05, initial_wealth=0),\n    Account.from_annual(\"Housing\", 0.07, 0.12, initial_wealth=0)\n]\nportfolio = Portfolio(accounts)\n\n# Override W0 for optimization scenario\nW0_scenario = np.array([5_000_000, 2_000_000])\nresult = portfolio.simulate(A=A, R=R, X=X, initial_wealth=W0_scenario)\n\n# Verify override\nassert np.allclose(result[\"wealth\"][:, 0, :], W0_scenario)\n</code></pre>"},{"location":"portfolio/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"portfolio/#workflow","title":"Workflow","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.returns import ReturnModel\nfrom finopt.src.income import IncomeModel, FixedIncome\n\n# 1. Define accounts (annual parameters + display names)\naccounts = [\n    Account.from_annual(\"EM\", annual_return=0.04, annual_volatility=0.05,\n                        display_name=\"Emergency Fund\"),\n    Account.from_annual(\"HS\", annual_return=0.07, annual_volatility=0.12,\n                        display_name=\"Housing Savings\")\n]\n\n# 2. Create portfolio executor\nportfolio = Portfolio(accounts)\n\n# 3. Generate stochastic inputs externally\nincome = IncomeModel(fixed=FixedIncome(base=1_400_000, annual_growth=0.03))\nreturns = ReturnModel(accounts, default_correlation=np.eye(2))\n\nT, n_sims = 24, 500\nA = income.contributions(T, start=date(2025, 1, 1), n_sims=n_sims)  # (500, 24)\nR = returns.generate(T, n_sims=n_sims, seed=42)                      # (500, 24, 2)\n\n# 4. Define allocation policy\nX = np.tile([0.6, 0.4], (T, 1))  # 60-40 split\n\n# 5. Execute wealth dynamics (with optional withdrawals)\nD = np.zeros((T, 2))\nD[12, 0] = 500_000  # $500K withdrawal from Emergency at month 12\n\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\nW = result[\"wealth\"]              # (500, 25, 2)\nW_total = result[\"total_wealth\"]  # (500, 25)\n\n# 6. Visualize with goals\nfrom finopt.src.goals import TerminalGoal, IntermediateGoal\n\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"EM\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"HS\", threshold=20_000_000, confidence=0.90)\n]\n\nportfolio.plot(result=result, X=X, start=date(2025, 1, 1), goals=goals)\n</code></pre>"},{"location":"portfolio/#data-flow","title":"Data flow","text":"<pre><code>income.py          returns.py\n    \u2193                  \u2193\n    A                  R          (external generation)\n    \u2193                  \u2193\n    \u2514\u2500\u2500\u25ba portfolio.simulate(A, R, X, D) \u2500\u2500\u25ba W\n                       \u2191        \u2191\n                       X        D    (from user or optimizer)\n</code></pre>"},{"location":"portfolio/#visualization","title":"Visualization","text":"<p>Method signature: <pre><code>def plot(\n    self,\n    result: dict,           # from simulate()\n    X: np.ndarray,          # allocation policy\n    start: date = None,     # calendar start date\n    goals: list = None,     # Goal objects to visualize\n    figsize: tuple = (16, 10),\n    title: str = None,\n    save_path: str = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.05,\n    colors: dict = None,\n    hist_bins: int = 30,\n    hist_color: str = 'mediumseagreen'\n)\n</code></pre></p> <p>Panel layout: 1. Top-left: Wealth per account (time series with Monte Carlo trajectories + goal markers) 2. Top-right: Total portfolio wealth + lateral histogram of final wealth distribution 3. Bottom-left: Portfolio composition (stacked area chart) 4. Bottom-right: Allocation policy (stacked bar chart)</p> <p>Goal visualization: - TerminalGoal: Horizontal dashed line at threshold across entire horizon - IntermediateGoal: Dotted line up to goal month with diamond marker</p> <p>Calendar-aware x-axis: When <code>start</code> is provided, the x-axis shows calendar dates instead of month indices.</p>"},{"location":"portfolio/#usage-patterns","title":"Usage patterns","text":""},{"location":"portfolio/#a-basic-simulation-deterministic-contributions","title":"A) Basic simulation (deterministic contributions)","text":"<pre><code>A = np.full(24, 100_000.0)                      # (24,)\nR = returns.generate(T=24, n_sims=500, seed=42) # (500, 24, 2)\nX = np.tile([0.5, 0.5], (24, 1))                # equal split\n\nresult = portfolio.simulate(A, R, X)\nW = result[\"wealth\"]  # (500, 25, 2)\n</code></pre>"},{"location":"portfolio/#b-stochastic-contributions-returns","title":"B) Stochastic contributions + returns","text":"<pre><code>A = income.contributions(24, start=date(2025, 1, 1), n_sims=500)  # (500, 24)\nR = returns.generate(T=24, n_sims=500, seed=42)                    # (500, 24, 2)\nX = np.tile([0.7, 0.3], (24, 1))\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#c-with-withdrawals","title":"C) With withdrawals","text":"<pre><code># $1M withdrawal from Housing at month 18\nD = np.zeros((T, 2))\nD[18, 1] = 1_000_000\n\nresult = portfolio.simulate(A, R, X, D=D)\n</code></pre>"},{"location":"portfolio/#d-time-varying-allocation-policy-glide-path","title":"D) Time-varying allocation policy (glide path)","text":"<pre><code>T = 60\nequity_fractions = np.linspace(0.8, 0.4, T)\nX = np.column_stack([equity_fractions, 1 - equity_fractions])  # (60, 2)\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#e-optimization-ready-gradient-computation","title":"E) Optimization-ready gradient computation","text":"<pre><code># Compute accumulation factors once\nF = portfolio.compute_accumulation_factors(R)  # (n_sims, T+1, T+1, M)\n\n# Gradient of E[W_24^0] w.r.t. X[10, 0]\nt_goal, s_contrib, m_account = 24, 10, 0\nA_val = A[:, 10].mean() if A.ndim == 2 else A[10]\ngrad = A_val * F[:, s_contrib, t_goal, m_account].mean()\n</code></pre>"},{"location":"portfolio/#f-method-selection-heuristic","title":"F) Method selection heuristic","text":"<p>Use <code>method=\"recursive\"</code> (default) when: - Pure simulation (no optimization) - Large horizons (\\(T &gt; 100\\)) - Memory-constrained environments - No need for gradients</p> <p>Use <code>method=\"affine\"</code> when: - Integrating with optimizer - Need analytical gradients - Moderate horizons (\\(T \\leq 100\\)) - Sufficient RAM for \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) storage</p>"},{"location":"portfolio/#exceptions","title":"Exceptions","text":"<p>The module raises <code>AllocationConstraintError</code> when allocation policy violates constraints:</p> <pre><code>from finopt.src.exceptions import AllocationConstraintError\n\ntry:\n    result = portfolio.simulate(A, R, X)\nexcept AllocationConstraintError as e:\n    print(f\"Invalid allocation: {e}\")\n    # Fix: ensure X[t, :].sum() == 1 and X &gt;= 0\n</code></pre>"},{"location":"portfolio/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter).</p> <p>Corollary 1 (Linear Constraints): If goals are specified as \\(W_t^m(X) \\geq b_t^m\\) (deterministic), the feasible allocation set is a convex polytope.</p> <p>Proposition 2 (Gradient): The sensitivity of wealth to allocation at month \\(s\\) is: $$ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t $$</p> <p>Corollary 2 (Monotonicity): If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m(X)\\) is strictly increasing in \\(x_s^m\\).</p> <p>Proposition 3 (Withdrawal Independence): Withdrawals \\(D\\) do not affect gradients \\(\\frac{\\partial W_t^m}{\\partial x_s^m}\\) since they are parameters, not decision variables. This preserves convexity for CVaR optimization.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with FinOpt in under 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"Conda (Recommended)Pip <pre><code>conda env create -f environment.yml\nconda activate finance\npip install cvxpy\n</code></pre> <pre><code>pip install numpy pandas cvxpy matplotlib\n</code></pre>"},{"location":"quickstart/#step-1-define-your-income","title":"Step 1: Define Your Income","text":"<p>FinOpt models your cash flows\u2014both fixed salary and variable bonuses.</p> <pre><code>from finopt import IncomeModel, FixedIncome, VariableIncome\nfrom datetime import date\n\n# Fixed salary with 3% annual growth\nfixed = FixedIncome(\n    base=1_500_000,        # Monthly base salary (CLP)\n    annual_growth=0.03,    # 3% annual raise\n    start_date=date(2025, 1, 1)\n)\n\n# Variable income (bonuses) with seasonality\nvariable = VariableIncome(\n    expected=500_000,      # Expected monthly bonus\n    volatility=0.3,        # 30% standard deviation\n    seasonality=[0.5, 0.5, 1.0, 0.5, 0.5, 2.0,   # Jan-Jun\n                 0.5, 0.5, 1.0, 0.5, 0.5, 3.0],  # Jul-Dec (Dec = 3x)\n    seed=42\n)\n\nincome = IncomeModel(fixed=fixed, variable=variable)\n</code></pre>"},{"location":"quickstart/#step-2-set-up-investment-accounts","title":"Step 2: Set Up Investment Accounts","text":"<p>Define your portfolio accounts with expected returns and volatility.</p> <pre><code>from finopt import Account\n\naccounts = [\n    Account.from_annual(\n        name=\"Conservative\",\n        annual_return=0.08,      # 8% expected annual return\n        annual_volatility=0.09,  # 9% volatility\n        initial_wealth=1_000_000\n    ),\n    Account.from_annual(\n        name=\"Aggressive\",\n        annual_return=0.14,      # 14% expected annual return\n        annual_volatility=0.18,  # 18% volatility\n        initial_wealth=500_000\n    )\n]\n</code></pre> <p>Always use <code>from_annual()</code></p> <p>The <code>from_annual()</code> constructor automatically converts annual parameters to monthly equivalents, which is required for simulation.</p>"},{"location":"quickstart/#step-3-create-the-model","title":"Step 3: Create the Model","text":"<p>Combine income and accounts into a unified model.</p> <pre><code>from finopt import FinancialModel\n\nmodel = FinancialModel(\n    income=income,\n    accounts=accounts,\n    correlation=0.3  # Correlation between account returns\n)\n</code></pre>"},{"location":"quickstart/#step-4-define-your-goals","title":"Step 4: Define Your Goals","text":"<p>Specify what you want to achieve and by when.</p> <pre><code>from finopt.goals import TerminalGoal, IntermediateGoal\nfrom datetime import date\n\ngoals = [\n    # Emergency fund: $3M in conservative account by month 12\n    IntermediateGoal(\n        account=\"Conservative\",\n        threshold=3_000_000,\n        confidence=0.90,        # 90% probability of success\n        date=date(2026, 1, 1)\n    ),\n    # Long-term wealth: $10M at end of planning horizon\n    TerminalGoal(\n        account=\"Aggressive\",\n        threshold=10_000_000,\n        confidence=0.80         # 80% probability of success\n    )\n]\n</code></pre>"},{"location":"quickstart/#step-5-optimize","title":"Step 5: Optimize","text":"<p>Find the minimum time horizon and optimal allocation policy.</p> <pre><code>from finopt.optimization import CVaROptimizer\n\noptimizer = CVaROptimizer(\n    n_accounts=2,\n    objective=\"balanced\"  # Minimizes allocation changes\n)\n\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,      # Maximum 10-year horizon\n    n_sims=500,     # Monte Carlo scenarios\n    seed=42\n)\n\nprint(f\"Minimum horizon: {result.T} months\")\nprint(f\"Goal satisfaction: {result.validate_goals()}\")\n</code></pre>"},{"location":"quickstart/#step-6-visualize-results","title":"Step 6: Visualize Results","text":"<pre><code># Wealth trajectories\nmodel.plot(\"wealth\", result=result, show_trajectories=True)\n\n# Allocation policy heatmap\nmodel.plot(\"allocation\", result=result)\n\n# Combined dashboard\nmodel.plot(\"combined\", result=result)\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Framework Overview: Understand the mathematical foundations</li> <li>Optimization Guide: Learn about CVaR reformulation and different objectives</li> <li>Goals Framework: Advanced goal configuration with chance constraints</li> </ul>"},{"location":"returns/","title":"<code>returns</code> \u2014 Stochastic Return Generation for FinOpt","text":"<p>Purpose: Generate correlated stochastic returns under lognormal assumptions, providing the probabilistic foundation for Monte Carlo simulation and optimization under uncertainty. <code>returns.py</code> is the stochastic engine: it consumes account metadata (from <code>portfolio.py</code>) and produces vectorized return samples that drive wealth dynamics in <code>portfolio.simulate()</code>.</p>"},{"location":"returns/#why-a-dedicated-returns-module","title":"Why a dedicated returns module?","text":"<p>Financial planning under uncertainty requires explicit stochastic modeling: - <code>income.py</code> \u2192 cash flow uncertainty (seasonal + noise) - <code>returns.py</code> \u2192 market return uncertainty (correlated assets) - <code>portfolio.py</code> \u2192 wealth evolution executor - <code>optimization.py</code> \u2192 policy search under constraints</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to ReturnModel) - Correlation modeling: Cross-sectional dependence between accounts - Lognormal guarantee: \\(R_t &gt; -1\\) (no catastrophic losses) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion - Flexible correlation: Matrix or group-based specification</p>"},{"location":"returns/#mathematical-framework","title":"Mathematical framework","text":""},{"location":"returns/#lognormal-return-model","title":"Lognormal return model","text":"<p>Gross returns follow a correlated lognormal distribution:</p> \\[ 1 + R_t^m \\sim \\text{LogNormal}(\\mu_{\\text{log}}^m, \\Sigma) \\] <p>where the covariance matrix is constructed as:</p> \\[ \\Sigma = D \\rho D \\] <p>with: - \\(D = \\text{diag}(\\sigma_{\\text{log}}^1, \\ldots, \\sigma_{\\text{log}}^M)\\) (log-volatilities) - \\(\\rho \\in \\mathbb{R}^{M \\times M}\\) (correlation matrix, symmetric PSD with diagonal = 1)</p>"},{"location":"returns/#parameter-conversion","title":"Parameter conversion","text":"<p>Given arithmetic parameters \\((\\mu_{\\text{arith}}, \\sigma_{\\text{arith}})\\), convert to log-space:</p> \\[ \\begin{aligned} \\sigma_{\\text{log}} &amp;= \\sqrt{\\log\\left(1 + \\frac{\\sigma_{\\text{arith}}^2}{(1 + \\mu_{\\text{arith}})^2}\\right)} \\\\[8pt] \\mu_{\\text{log}} &amp;= \\log(1 + \\mu_{\\text{arith}}) - \\frac{\\sigma_{\\text{log}}^2}{2} \\end{aligned} \\] <p>Rationale: The adjustment \\(-\\sigma_{\\text{log}}^2/2\\) ensures:</p> \\[ \\mathbb{E}[1 + R_t^m] = \\exp\\left(\\mu_{\\text{log}} + \\frac{\\sigma_{\\text{log}}^2}{2}\\right) = 1 + \\mu_{\\text{arith}} \\]"},{"location":"returns/#generation-algorithm","title":"Generation algorithm","text":"<ol> <li>Sample log-returns: \\(Z \\sim \\mathcal{N}(\\mu_{\\text{log}}, \\Sigma)\\) with shape \\((n_{\\text{sims}}, T, M)\\)</li> <li>Transform to arithmetic: \\(R = \\exp(Z) - 1\\)</li> <li>Guarantee: \\(R_t^m &gt; -1\\) for all realizations (lognormal property)</li> </ol> <p>Complexity: \\(O(n_{\\text{sims}} \\cdot T \\cdot M^3)\\) dominated by Cholesky decomposition of \\(\\Sigma\\) (one-time cost).</p>"},{"location":"returns/#design-principles","title":"Design principles","text":"<ol> <li>Lognormal constraint</li> <li>Ensures \\(R_t &gt; -1\\) (realistic: no portfolio loses more than 100%)</li> <li> <p>Alternative to Normal (which allows \\(R_t &lt; -1\\)) or Bootstrap (limited to historical support)</p> </li> <li> <p>Correlation modeling</p> </li> <li>Default: uncorrelated accounts (\\(\\rho = I\\))</li> <li>Override per <code>generate()</code> call for sensitivity analysis</li> <li>Supports both matrix and group-based specification</li> <li> <p>Validation: symmetric, PSD, diagonal = 1</p> </li> <li> <p>Dual temporal representation</p> </li> <li>User-facing: annual parameters (intuitive)</li> <li>Internal: monthly log-space (canonical for sampling)</li> <li> <p>Properties provide views without conversion overhead</p> </li> <li> <p>No portfolio dependency</p> </li> <li>Consumes <code>Account</code> metadata (loose coupling)</li> <li>Never imports <code>Portfolio</code> (inverted dependency)</li> <li> <p>Testable in isolation</p> </li> <li> <p>IID assumption</p> </li> <li>Returns are independent across time (no GARCH/AR)</li> <li>Extension to time-series models is straightforward (see Extensions section)</li> </ol>"},{"location":"returns/#the-core-surface-returnmodel","title":"The core surface: <code>ReturnModel</code>","text":""},{"location":"returns/#constructor","title":"Constructor","text":"<p>Signature: <pre><code>ReturnModel(\n    accounts: List[Account],\n    default_correlation: Optional[Union[np.ndarray, Dict[Tuple[str, ...], float]]] = None\n)\n</code></pre></p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects with <code>return_strategy</code> metadata - <code>default_correlation</code>: Correlation specification (see below)</p> <p>Correlation specification options:</p> <ol> <li> <p>None (default): Identity matrix \\(\\rho = I_M\\) (uncorrelated)</p> </li> <li> <p>Matrix (np.ndarray): Full \\(M \\times M\\) correlation matrix    <pre><code>rho = np.array([[1.0, 0.5], [0.5, 1.0]])\nreturns = ReturnModel(accounts, default_correlation=rho)\n</code></pre></p> </li> <li> <p>Groups (Dict): Account groups with shared correlation    <pre><code>groups = {\n    (\"Emergency\", \"Housing\"): 0.3,        # Pair correlation\n    (\"Stock1\", \"Stock2\", \"Stock3\"): 0.6,  # Group correlation (all pairs)\n}\nreturns = ReturnModel(accounts, default_correlation=groups)\n</code></pre></p> </li> </ol> <p>Group semantics: - Tuple of 2 accounts: Single pair correlation - Tuple of 3+ accounts: All pairwise combinations get the same correlation - Unspecified pairs default to 0.0 - Diagonal always 1.0</p> <p>Initialization: 1. Validate correlation matrix (symmetric, PSD, diagonal = 1) 2. Extract arithmetic parameters from <code>accounts</code> 3. Precompute log-space parameters \\((\\mu_{\\text{log}}, \\sigma_{\\text{log}})\\)</p>"},{"location":"returns/#properties","title":"Properties","text":"<p>Dual temporal access:</p> <pre><code>@property\ndef monthly_params(self) -&gt; List[Dict[str, float]]\n    # [{\"mu\": float, \"sigma\": float}, ...]\n\n@property\ndef annual_params(self) -&gt; List[Dict[str, float]]\n    # [{\"return\": float, \"volatility\": float}, ...]\n</code></pre> <p>Legacy properties (backward compatible): <pre><code>@property\ndef mean_returns(self) -&gt; np.ndarray   # Expected arithmetic returns (monthly)\n\n@property\ndef volatilities(self) -&gt; np.ndarray   # Arithmetic volatilities (monthly)\n\n@property\ndef account_names(self) -&gt; List[str]   # Account names\n</code></pre></p> <p>Introspection: <pre><code>returns.params_table()  # DataFrame with monthly vs annual comparison\nprint(returns)          # Human-readable summary\n</code></pre></p> <p>Example output: <pre><code>ReturnModel(M=2, \u03c1=eye, accounts=['Emergency': 4.0%/year, 'Growth': 12.0%/year])\n</code></pre></p>"},{"location":"returns/#core-generation-method","title":"Core generation method","text":"<p>Signature: <pre><code>def generate(\n    self,\n    T: int,\n    n_sims: int = 1,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None\n) -&gt; np.ndarray\n</code></pre></p> <p>Parameters: - <code>T</code>: time horizon (months) - <code>n_sims</code>: number of Monte Carlo trajectories - <code>correlation</code>: override default correlation (sensitivity analysis) - <code>seed</code>: RNG seed for reproducibility</p> <p>Returns: - <code>R</code>: shape \\((n_{\\text{sims}}, T, M)\\) with \\(R_{i,t,m} &gt; -1\\) for all \\((i,t,m)\\)</p> <p>Raises: - <code>ValidationError</code>: If \\(T \\leq 0\\) - <code>ValueError</code>: If correlation matrix is invalid</p> <p>Algorithm: <pre><code># 1. Use correlation override or default\nrho = correlation if correlation is not None else self.default_correlation\n\n# 2. Build \u03a3 = D @ \u03c1 @ D\ncov = diag(\u03c3_log) @ rho @ diag(\u03c3_log)\n\n# 3. Sample log-returns\nrng = np.random.default_rng(seed)\nZ = rng.multivariate_normal(\u03bc_log, cov, size=(n_sims, T))  # (n_sims, T, M)\n\n# 4. Transform to arithmetic\nR = np.exp(Z) - 1.0\n</code></pre></p>"},{"location":"returns/#visualization-methods","title":"Visualization methods","text":""},{"location":"returns/#1-plot-distribution-analysis","title":"1) <code>plot()</code> \u2014 Distribution analysis","text":"<p>Signature: <pre><code>def plot(\n    self,\n    T: int = 32,\n    n_sims: int = 300,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,  # Calendar-aware x-axis\n    figsize: tuple = (16, 8),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.05\n)\n</code></pre></p> <p>Panel layout: 1. Top-left: Return trajectories (Monte Carlo paths) 2. Top-right: Marginal histograms (monthly distribution) 3. Bottom: Summary statistics table (monthly + annualized)</p> <p>Calendar-aware plotting: When <code>start</code> is provided, the x-axis shows calendar dates instead of numeric month indices: <pre><code>from datetime import date\nreturns.plot(T=24, n_sims=500, seed=42, start=date(2025, 1, 1))\n</code></pre></p>"},{"location":"returns/#2-plot_cumulative-wealth-evolution","title":"2) <code>plot_cumulative()</code> \u2014 Wealth evolution","text":"<p>Signature: <pre><code>def plot_cumulative(\n    self,\n    T: int = 24,\n    n_sims: int = 1000,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,  # Calendar-aware x-axis\n    figsize: tuple = (14, 6),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.08,\n    show_percentiles: bool = True,\n    percentiles: tuple = (5, 95),\n    hist_bins: int = 40,\n    hist_color: str = 'red'\n)\n</code></pre></p> <p>Visualization: - Cumulative returns: \\(\\left(\\prod_{s=0}^{t-1}(1+R_s^m)\\right) - 1\\) - Lateral histogram of final returns - Percentile bands (default: 5th-95th)</p> <p>Modes: - M=1: Single plot with lateral histogram - M&gt;1: Separate subplot per account</p> <p>Theoretical validation (annotation box): - Simulation mean vs theoretical: \\(\\mathbb{E}[(1+\\mu)^T - 1]\\) - Jensen's inequality: sample mean &gt; theoretical (convexity)</p>"},{"location":"returns/#3-plot_horizon_analysis-time-diversification","title":"3) <code>plot_horizon_analysis()</code> \u2014 Time diversification","text":"<p>Signature: <pre><code>def plot_horizon_analysis(\n    self,\n    horizons: np.ndarray = np.array([1, 2, 3, 5, 10, 15, 20]),\n    figsize: tuple = (15, 5),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_table: bool = True\n)\n</code></pre></p> <p>Analysis across investment horizons (default: 1, 2, 3, 5, 10, 15, 20 years):</p> <p>Panel 1: Return vs Volatility - Expected return: \\((1+\\mu_{\\text{monthly}})^{T_{\\text{months}}} - 1\\) - Volatility: \\(\\sigma_{\\text{monthly}} \\sqrt{T_{\\text{months}}}\\) (time scaling) - Signal-to-noise ratio: \\(\\text{SNR} = \\mathbb{E}[R] / \\sigma[R]\\)</p> <p>Panel 2: Probability of Loss - \\(P(R_T &lt; 0)\\) via Normal approximation - Risk reduction annotation</p> <p>Printed table (when <code>show_table=True</code>): <pre><code>HORIZON ANALYSIS - Emergency\n================================================================================\nHorizon (years) | Expected Return (%) | Volatility (%) | P(Loss) (%) | SNR\n--------------------------------------------------------------------------------\n            1.0 |                 4.0 |            5.0 |        21.2 | 0.80\n            5.0 |                21.7 |           11.2 |         2.6 | 1.94\n           20.0 |               119.1 |           22.4 |         0.0 | 5.32\n================================================================================\n</code></pre></p>"},{"location":"returns/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"returns/#workflow","title":"Workflow","text":"<pre><code>from datetime import date\n\n# 1. Define accounts (annual parameters + display names)\naccounts = [\n    Account.from_annual(\"EM\", annual_return=0.04, annual_volatility=0.05,\n                        display_name=\"Emergency Fund\"),\n    Account.from_annual(\"HS\", annual_return=0.07, annual_volatility=0.12,\n                        display_name=\"Housing Savings\")\n]\n\n# 2. Create return generator with group correlation\ngroups = {(\"EM\", \"HS\"): 0.3}\nreturns = ReturnModel(accounts, default_correlation=groups)\n\n# 3. Generate samples\nR = returns.generate(T=24, n_sims=500, seed=42)  # (500, 24, 2)\n\n# 4. Feed to portfolio\nresult = portfolio.simulate(A=A, R=R, X=X)\n</code></pre>"},{"location":"returns/#data-flow","title":"Data flow","text":"<pre><code>Account metadata \u2192 ReturnModel \u2192 R \u2192 Portfolio.simulate() \u2192 W\n                        \u2191\n                   correlation\n                   (matrix or groups)\n</code></pre>"},{"location":"returns/#optimization-integration","title":"Optimization integration","text":"<p>Chance constraint evaluation: <pre><code># Generate scenario ensemble\nR_scenarios = returns.generate(T=24, n_sims=500, seed=42)\n\n# Evaluate constraint: P(W_T^m &gt;= b) &gt;= 1-\u03b5\nW = portfolio.simulate(A, R_scenarios, X)[\"wealth\"]\nW_T_m = W[:, -1, m]\nviolation_rate = (W_T_m &lt; b).mean()\nfeasible = (violation_rate &lt;= epsilon)\n</code></pre></p> <p>Sensitivity analysis: <pre><code># Test correlation impact\ncorrelations = [np.eye(2), np.array([[1, 0.5], [0.5, 1]])]\n\nfor rho in correlations:\n    R = returns.generate(T=24, n_sims=500, correlation=rho, seed=42)\n    result = portfolio.simulate(A, R, X)\n    print(f\"\u03c1={rho[0,1]}: mean W_T = {result['total_wealth'][:, -1].mean():,.0f}\")\n</code></pre></p>"},{"location":"returns/#usage-patterns","title":"Usage patterns","text":""},{"location":"returns/#a-basic-generation-uncorrelated","title":"A) Basic generation (uncorrelated)","text":"<pre><code>accounts = [\n    Account.from_annual(\"Conservative\", 0.04, 0.05),\n    Account.from_annual(\"Aggressive\", 0.12, 0.20)\n]\nreturns = ReturnModel(accounts)  # default: \u03c1 = I\n\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#b-correlated-accounts-matrix","title":"B) Correlated accounts (matrix)","text":"<pre><code>rho = np.array([\n    [1.00, 0.30],\n    [0.30, 1.00]\n])\n\nreturns = ReturnModel(accounts, default_correlation=rho)\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#c-correlated-accounts-groups","title":"C) Correlated accounts (groups)","text":"<pre><code># Define accounts\naccounts = [\n    Account.from_annual(\"Stock1\", 0.10, 0.18),\n    Account.from_annual(\"Stock2\", 0.12, 0.20),\n    Account.from_annual(\"Stock3\", 0.08, 0.15),\n    Account.from_annual(\"Bond\", 0.04, 0.05)\n]\n\n# Stocks are correlated with each other, bonds uncorrelated\ngroups = {\n    (\"Stock1\", \"Stock2\", \"Stock3\"): 0.6,  # All stock pairs get 0.6\n    # Bond not mentioned \u2192 0 correlation with everything\n}\n\nreturns = ReturnModel(accounts, default_correlation=groups)\n</code></pre>"},{"location":"returns/#d-correlation-override-sensitivity","title":"D) Correlation override (sensitivity)","text":"<pre><code># Default: \u03c1 = 0.3\nreturns = ReturnModel(accounts, default_correlation=rho_low)\n\n# Test high correlation without recreating model\nrho_high = np.array([[1.0, 0.8], [0.8, 1.0]])\nR_high = returns.generate(T=24, n_sims=500, correlation=rho_high, seed=42)\n</code></pre>"},{"location":"returns/#e-introspection-and-validation","title":"E) Introspection and validation","text":"<pre><code># Parameter table\nprint(returns.params_table())\n#            \u03bc (monthly)  \u03bc (annual)  \u03c3 (monthly)  \u03c3 (annual)\n# Emergency       0.0033       4.00%       0.0144       5.00%\n# Growth          0.0095      12.00%       0.0577      20.00%\n\n# Generate and validate\nR = returns.generate(T=240, n_sims=1000, seed=42)\n\n# Check lognormal property\nassert np.all(R &gt; -1.0)  # guaranteed by construction\n\n# Check empirical moments\nmu_empirical = R.mean(axis=(0, 1))  # average over sims and time\nmu_theoretical = returns.mean_returns  # from properties\nnp.testing.assert_allclose(mu_empirical, mu_theoretical, rtol=0.05)\n</code></pre>"},{"location":"returns/#f-calendar-aware-visualization","title":"F) Calendar-aware visualization","text":"<pre><code>from datetime import date\n\n# Plot with calendar dates on x-axis\nreturns.plot(T=24, n_sims=500, seed=42, start=date(2025, 1, 1))\nreturns.plot_cumulative(T=36, n_sims=500, seed=42, start=date(2025, 1, 1))\n</code></pre>"},{"location":"returns/#key-design-decisions","title":"Key design decisions","text":""},{"location":"returns/#1-lognormal-vs-normal-vs-bootstrap","title":"1. Lognormal vs Normal vs Bootstrap","text":"Method Pros Cons Lognormal (chosen) Guarantees \\(R_t &gt; -1\\), closed-form moments, positive skewness Assumes IID Normal Simpler mathematics Allows \\(R_t &lt; -1\\) (unrealistic) Bootstrap Matches historical distribution Limited to observed range"},{"location":"returns/#2-correlation-as-parameter-not-covariance","title":"2. Correlation as parameter (not covariance)","text":"<p>Rationale: - Correlation is scale-invariant (easier to specify) - Natural interpretation: \\(\\rho_{12} = 0.5\\) means \"moderate positive dependence\" - Covariance mixes magnitude and correlation (confusing)</p> <p>Construction: \\(\\Sigma = D\\rho D\\) separates scale (volatility) from dependence (correlation).</p>"},{"location":"returns/#3-group-based-correlation","title":"3. Group-based correlation","text":"<p>Rationale: - Financial intuition: \"these three stocks are correlated\" - Easier than building full matrix for many accounts - Automatic validation and symmetry</p>"},{"location":"returns/#4-precomputed-log-parameters","title":"4. Precomputed log-parameters","text":"<p>Performance: Conversion formulas involve <code>log</code>, <code>sqrt</code> (expensive). Precompute once in <code>__init__</code>.</p>"},{"location":"returns/#5-correlation-override-per-generate-call","title":"5. Correlation override per <code>generate()</code> call","text":"<p>Use case: Sensitivity analysis without recreating the model.</p>"},{"location":"returns/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Lognormal Moments): If \\(1 + R \\sim \\text{LogNormal}(\\mu_{\\log}, \\sigma_{\\log}^2)\\), then:</p> \\[ \\begin{aligned} \\mathbb{E}[R] &amp;= \\exp\\left(\\mu_{\\log} + \\frac{\\sigma_{\\log}^2}{2}\\right) - 1 \\\\[6pt] \\text{Var}[R] &amp;= \\left(\\exp(\\sigma_{\\log}^2) - 1\\right) \\exp(2\\mu_{\\log} + \\sigma_{\\log}^2) \\end{aligned} \\] <p>Proposition 2 (Return Bound): For lognormal returns, \\(R_t^m &gt; -1\\) almost surely.</p> <p>Proof: \\(1 + R_t^m = \\exp(Z_t^m)\\) where \\(Z_t^m \\in \\mathbb{R}\\). Since \\(\\exp(z) &gt; 0\\) for all \\(z \\in \\mathbb{R}\\), we have \\(R_t^m &gt; -1\\). \u220e</p> <p>Proposition 3 (Correlation Preservation): If \\((Z_1, Z_2)\\) are bivariate normal with correlation \\(\\rho\\), then \\(\\text{Corr}(\\exp(Z_1), \\exp(Z_2))\\) is a monotone increasing function of \\(\\rho\\).</p> <p>Proposition 4 (Time Diversification): For IID returns with \\(\\mu &gt; 0\\), the probability of loss decreases exponentially:</p> \\[ P\\left(\\prod_{t=1}^T (1+R_t) &lt; 1\\right) \\approx \\Phi\\left(-\\frac{\\mu \\sqrt{T}}{\\sigma}\\right) \\xrightarrow{T \\to \\infty} 0 \\]"},{"location":"returns/#extensions-temporal-dependence-roadmap","title":"Extensions: Temporal Dependence (Roadmap)","text":"<p>Note: This section describes potential future extensions. The current implementation only supports IID returns.</p>"},{"location":"returns/#motivation","title":"Motivation","text":"<p>The current IID assumption (\\(R_t^m \\perp R_s^m\\) for \\(t \\neq s\\)) is appropriate for monthly horizons and typical investment periods (\\(T = 24-60\\) months), where empirical autocorrelation is weak (\\(|\\rho_1| &lt; 0.1\\)). However, temporal structure becomes relevant for:</p> <ol> <li>Long horizons: \\(T &gt; 120\\) months where autocorrelation accumulates</li> <li>Momentum strategies: Assets with persistent trends (\\(\\phi &gt; 0.2\\))</li> <li>Volatility clustering: Crisis periods with persistent high volatility</li> </ol>"},{"location":"returns/#proposed-ar1-extension","title":"Proposed AR(1) Extension","text":"\\[ R_t^m = \\phi^m R_{t-1}^m + \\epsilon_t^m, \\quad \\epsilon_t^m \\sim \\text{LogNormal}(\\mu_\\epsilon, \\sigma_\\epsilon) \\] <p>Key insight: Preserves affine wealth representation because returns remain exogenous (not dependent on policy \\(X\\)).</p>"},{"location":"returns/#proposed-api","title":"Proposed API","text":"<pre><code>class ReturnModel:\n    def __init__(\n        self,\n        accounts: List[Account],\n        default_correlation: Optional[np.ndarray] = None,\n        temporal_model: Literal[\"iid\", \"ar1\", \"garch\"] = \"iid\",  # Future\n        temporal_params: Optional[Dict] = None  # {\"phi\": [...], ...}\n    ):\n        ...\n</code></pre> <p>Backward compatibility: Default <code>temporal_model=\"iid\"</code> preserves existing behavior.</p>"},{"location":"returns/#when-to-implement","title":"When to Implement","text":"<p>Signals that temporal structure matters: 1. Backtesting shows systematic bias 2. Long-horizon planning (\\(T &gt; 120\\) months) 3. Ljung-Box test rejects IID at 5% significance</p>"},{"location":"returns/#exceptions","title":"Exceptions","text":"<p>The module raises <code>ValidationError</code> for invalid parameters:</p> <pre><code>from finopt.src.exceptions import ValidationError\n\ntry:\n    R = returns.generate(T=-1, n_sims=500)\nexcept ValidationError as e:\n    print(f\"Invalid parameters: {e}\")\n</code></pre>"},{"location":"serialization/","title":"<code>serialization</code> \u2014 Model Persistence for FinOpt","text":"<p>Core idea: Provide JSON serialization and deserialization for FinOpt models, enabling configuration persistence, sharing, version control, and reproducibility. <code>serialization.py</code> bridges the gap between Python objects and human-readable files, allowing models to be saved, loaded, and shared across sessions.</p>"},{"location":"serialization/#why-a-dedicated-serialization-module","title":"Why a dedicated serialization module?","text":"<ul> <li>Persistence: Save model configurations and optimization results to disk</li> <li>Reproducibility: Capture all parameters needed to recreate experiments</li> <li>Sharing: Exchange configurations between users or systems</li> <li>Version control: Track model changes with git-friendly JSON format</li> <li>Validation: Type-safe loading via Pydantic configs</li> </ul>"},{"location":"serialization/#design-principles","title":"Design principles","text":"<ol> <li>Type-safe serialization</li> <li>Uses Pydantic configs from <code>config.py</code> for validation during loading</li> <li> <p>Catches malformed or invalid configurations early</p> </li> <li> <p>Human-readable format</p> </li> <li>JSON output with pretty-printing (2-space indentation)</li> <li> <p>Date fields stored as ISO format strings (<code>\"2025-06-01\"</code>)</p> </li> <li> <p>Reproducibility first</p> </li> <li>Includes seeds, all parameters, and contribution rates</li> <li> <p>Schema versioning for backward compatibility tracking</p> </li> <li> <p>Modular architecture</p> </li> <li>Individual serializers for each component (accounts, income, goals, withdrawals)</li> <li> <p>Composable into full model or scenario serialization</p> </li> <li> <p>Backward compatible</p> </li> <li>Schema version checking with warnings</li> <li>Supports legacy formats (e.g., <code>month</code> \u2192 <code>date</code> conversion for goals)</li> </ol>"},{"location":"serialization/#schema-version","title":"Schema Version","text":"<pre><code>SCHEMA_VERSION = \"0.2.0\"\n</code></pre> <p>All serialized files include a <code>schema_version</code> field. When loading files with different versions, a warning is issued but loading proceeds.</p>"},{"location":"serialization/#core-functions","title":"Core Functions","text":""},{"location":"serialization/#model-serialization","title":"Model Serialization","text":""},{"location":"serialization/#save_modelmodel-path-include_correlationtrue","title":"<code>save_model(model, path, include_correlation=True)</code>","text":"<p>Saves <code>FinancialModel</code> configuration to JSON file.</p> <pre><code>from pathlib import Path\nfrom finopt.serialization import save_model\n\nsave_model(model, Path(\"config.json\"))\n</code></pre> <p>Parameters: - <code>model</code>: <code>FinancialModel</code> instance to save - <code>path</code>: Output file path (creates parent directories if needed) - <code>include_correlation</code>: Whether to include return correlation matrix (default: <code>True</code>)</p> <p>Output format: <pre><code>{\n  \"schema_version\": \"0.2.0\",\n  \"income\": {\n    \"fixed\": {\n      \"base\": 1400000.0,\n      \"annual_growth\": 0.03,\n      \"salary_raises\": {\n        \"2025-07-01\": 200000.0\n      }\n    },\n    \"variable\": {\n      \"base\": 200000.0,\n      \"sigma\": 0.15,\n      \"annual_growth\": 0.02,\n      \"seasonality\": [1.0, 0.95, 1.05, ...],\n      \"floor\": 50000.0,\n      \"cap\": 400000.0,\n      \"seed\": 42\n    },\n    \"contribution_rate_fixed\": 0.3,\n    \"contribution_rate_variable\": 1.0\n  },\n  \"accounts\": [\n    {\n      \"name\": \"Conservador\",\n      \"annual_return\": 0.06,\n      \"annual_volatility\": 0.08,\n      \"initial_wealth\": 1000000.0,\n      \"display_name\": \"Fondo Conservador\"\n    },\n    {\n      \"name\": \"Agresivo\",\n      \"annual_return\": 0.12,\n      \"annual_volatility\": 0.15,\n      \"initial_wealth\": 500000.0\n    }\n  ],\n  \"correlation\": [\n    [1.0, 0.3],\n    [0.3, 1.0]\n  ]\n}\n</code></pre></p>"},{"location":"serialization/#load_modelpath-financialmodel","title":"<code>load_model(path) -&gt; FinancialModel</code>","text":"<p>Reconstructs <code>FinancialModel</code> from JSON configuration file.</p> <pre><code>from pathlib import Path\nfrom finopt.serialization import load_model\n\nmodel = load_model(Path(\"config.json\"))\n</code></pre> <p>Parameters: - <code>path</code>: Input file path</p> <p>Returns: - <code>FinancialModel</code>: Fully reconstructed model instance</p> <p>Notes: - Validates configuration using Pydantic configs - Issues warning if schema version differs from current - Automatically sets correlation matrix if present</p>"},{"location":"serialization/#optimization-result-serialization","title":"Optimization Result Serialization","text":""},{"location":"serialization/#save_optimization_resultresult-path-include_policytrue","title":"<code>save_optimization_result(result, path, include_policy=True)</code>","text":"<p>Saves <code>OptimizationResult</code> to JSON file.</p> <pre><code>from pathlib import Path\nfrom finopt.serialization import save_optimization_result\n\nsave_optimization_result(result, Path(\"optimal_policy.json\"))\n</code></pre> <p>Parameters: - <code>result</code>: <code>OptimizationResult</code> instance - <code>path</code>: Output file path - <code>include_policy</code>: Whether to include full allocation policy matrix <code>X</code> (default: <code>True</code>)</p> <p>Output format: <pre><code>{\n  \"schema_version\": \"0.2.0\",\n  \"T\": 36,\n  \"objective_value\": 0.0023,\n  \"feasible\": true,\n  \"solve_time\": 1.234,\n  \"n_iterations\": 5,\n  \"X\": [\n    [0.4, 0.6],\n    [0.35, 0.65],\n    ...\n  ],\n  \"goals\": [\n    {\n      \"type\": \"intermediate\",\n      \"threshold\": 5000000.0,\n      \"confidence\": 0.9,\n      \"account\": \"Conservador\",\n      \"date\": \"2025-07-01\"\n    },\n    {\n      \"type\": \"terminal\",\n      \"threshold\": 30000000.0,\n      \"confidence\": 0.85,\n      \"account\": \"Agresivo\",\n      \"date\": null\n    }\n  ]\n}\n</code></pre></p>"},{"location":"serialization/#load_optimization_resultpath-dictstr-any","title":"<code>load_optimization_result(path) -&gt; Dict[str, Any]</code>","text":"<p>Loads optimization result from JSON file.</p> <pre><code>from pathlib import Path\nimport numpy as np\nfrom finopt.serialization import load_optimization_result\n\nresult_data = load_optimization_result(Path(\"optimal_policy.json\"))\nX = result_data[\"X\"]  # Already converted to np.ndarray\nT = result_data[\"T\"]\n</code></pre> <p>Parameters: - <code>path</code>: Input file path</p> <p>Returns: - <code>dict</code>: Dictionary with optimization result data (not full <code>OptimizationResult</code> object)</p> <p>Note: Returns dictionary instead of <code>OptimizationResult</code> because full reconstruction requires <code>SimulationResult</code> context.</p>"},{"location":"serialization/#scenario-serialization","title":"Scenario Serialization","text":"<p>A scenario captures everything needed to reproduce an optimization: model configuration (or reference), goals, withdrawals, and simulation/optimization parameters.</p>"},{"location":"serialization/#save_scenario","title":"<code>save_scenario(...)</code>","text":"<p>Saves a complete optimization scenario to JSON file.</p> <pre><code>from pathlib import Path\nfrom datetime import date\nfrom finopt.serialization import save_scenario\nfrom finopt.goals import TerminalGoal, IntermediateGoal\n\ngoals = [\n    IntermediateGoal(account=\"Conservador\", threshold=5_000_000,\n                     confidence=0.9, date=date(2025, 7, 1)),\n    TerminalGoal(account=\"Agresivo\", threshold=30_000_000, confidence=0.85)\n]\n\n# Option 1: Embed model in scenario\nsave_scenario(\n    scenario_name=\"Plan de Retiro\",\n    goals=goals,\n    path=Path(\"scenarios/retirement.json\"),\n    model=my_model,\n    withdrawals=my_withdrawals,\n    start_date=date(2025, 1, 1),\n    description=\"Escenario base para jubilaci\u00f3n\",\n    n_sims=1000,\n    seed=42,\n    T_max=120,\n    solver=\"CLARABEL\",\n    objective=\"balanced\"\n)\n\n# Option 2: Reference external model file\nsave_scenario(\n    scenario_name=\"Plan de Retiro\",\n    goals=goals,\n    path=Path(\"scenarios/retirement.json\"),\n    model_path=\"profiles/my_profile.json\",  # relative to scenario file\n    start_date=date(2025, 1, 1)\n)\n</code></pre> <p>Parameters: | Parameter | Type | Description | |-----------|------|-------------| | <code>scenario_name</code> | <code>str</code> | Human-readable scenario name | | <code>goals</code> | <code>List[Goal]</code> | Financial goals for the scenario | | <code>path</code> | <code>Path</code> | Output file path | | <code>model</code> | <code>FinancialModel</code> | Embed full model (mutually exclusive with <code>model_path</code>) | | <code>model_path</code> | <code>str</code> | Reference external model file (mutually exclusive with <code>model</code>) | | <code>withdrawals</code> | <code>WithdrawalModel</code> | Scheduled and stochastic withdrawals | | <code>start_date</code> | <code>date</code> | Simulation start date (default: today) | | <code>description</code> | <code>str</code> | Optional scenario description | | <code>n_sims</code> | <code>int</code> | Number of Monte Carlo simulations (default: 500) | | <code>seed</code> | <code>int</code> | Random seed for reproducibility | | <code>T_max</code> | <code>int</code> | Maximum optimization horizon (default: 240) | | <code>solver</code> | <code>str</code> | CVXPY solver backend (default: <code>\"ECOS\"</code>) | | <code>objective</code> | <code>str</code> | Optimization objective (default: <code>\"balanced\"</code>) |</p> <p>Output format: <pre><code>{\n  \"schema_version\": \"0.2.0\",\n  \"name\": \"Plan de Retiro\",\n  \"description\": \"Escenario base para jubilaci\u00f3n\",\n  \"start_date\": \"2025-01-01\",\n  \"model\": {\n    \"income\": {...},\n    \"accounts\": [...],\n    \"correlation\": [...]\n  },\n  \"intermediate_goals\": [\n    {\"account\": \"Conservador\", \"threshold\": 5000000.0, \"confidence\": 0.9, \"date\": \"2025-07-01\"}\n  ],\n  \"terminal_goals\": [\n    {\"account\": \"Agresivo\", \"threshold\": 30000000.0, \"confidence\": 0.85}\n  ],\n  \"withdrawals\": {\n    \"scheduled\": [...],\n    \"stochastic\": [...]\n  },\n  \"simulation\": {\n    \"n_sims\": 1000,\n    \"seed\": 42,\n    \"cache_enabled\": true,\n    \"verbose\": true\n  },\n  \"optimization\": {\n    \"T_max\": 120,\n    \"solver\": \"CLARABEL\",\n    \"objective\": \"balanced\"\n  }\n}\n</code></pre></p>"},{"location":"serialization/#load_scenariopath-load_model_from_pathtrue-dictstr-any","title":"<code>load_scenario(path, load_model_from_path=True) -&gt; Dict[str, Any]</code>","text":"<p>Loads a scenario from JSON file.</p> <pre><code>from pathlib import Path\nfrom finopt.serialization import load_scenario\n\nscenario = load_scenario(Path(\"scenarios/retirement.json\"))\n\n# Access components\nmodel = scenario[\"model\"]           # FinancialModel\ngoals = scenario[\"goals\"]           # List[IntermediateGoal | TerminalGoal]\nwithdrawals = scenario[\"withdrawals\"]  # WithdrawalModel or None\nstart_date = scenario[\"start_date\"]    # date\nsim_config = scenario[\"simulation\"]    # SimulationConfig\nopt_config = scenario[\"optimization\"]  # OptimizationConfig\n</code></pre> <p>Parameters: - <code>path</code>: Input file path - <code>load_model_from_path</code>: If scenario has <code>model_path</code>, load the model from that file (default: <code>True</code>)</p> <p>Returns: - <code>dict</code> with keys:   - <code>name</code>: <code>str</code>   - <code>description</code>: <code>str</code>   - <code>start_date</code>: <code>date</code>   - <code>model</code>: <code>FinancialModel</code> (if embedded or loaded from path)   - <code>model_path</code>: <code>str</code> (if referenced)   - <code>goals</code>: <code>List[IntermediateGoal | TerminalGoal]</code>   - <code>withdrawals</code>: <code>WithdrawalModel</code> or <code>None</code>   - <code>simulation</code>: <code>SimulationConfig</code>   - <code>optimization</code>: <code>OptimizationConfig</code></p>"},{"location":"serialization/#component-serializers","title":"Component Serializers","text":""},{"location":"serialization/#account-serialization","title":"Account Serialization","text":"<pre><code>from finopt.serialization import account_to_dict, account_from_dict\n\n# Serialize\ndata = account_to_dict(account)\n# {\"name\": \"Conservador\", \"annual_return\": 0.06, \"annual_volatility\": 0.08, ...}\n\n# Deserialize\naccount = account_from_dict(data)\n</code></pre>"},{"location":"serialization/#income-serialization","title":"Income Serialization","text":"<pre><code>from finopt.serialization import income_to_dict, income_from_dict\n\n# Serialize\ndata = income_to_dict(income_model)\n\n# Deserialize\nincome = income_from_dict(data)\n</code></pre> <p>Features: - Handles <code>None</code> components (fixed-only or variable-only) - Converts <code>salary_raises</code> dates to ISO strings - Supports both scalar and 12-element array contribution rates</p>"},{"location":"serialization/#withdrawal-serialization","title":"Withdrawal Serialization","text":"<pre><code>from finopt.serialization import withdrawal_to_dict, withdrawal_from_dict\n\n# Serialize\ndata = withdrawal_to_dict(withdrawal_model)\n# {\n#   \"scheduled\": [{\"account\": \"...\", \"amount\": 100000, \"date\": \"2025-06-01\"}],\n#   \"stochastic\": [{\"account\": \"...\", \"base_amount\": 200000, \"sigma\": 50000, ...}]\n# }\n\n# Deserialize\nwithdrawals = withdrawal_from_dict(data)\n</code></pre> <p>Features: - Handles both scheduled (<code>WithdrawalEvent</code>) and stochastic (<code>StochasticWithdrawal</code>) - Supports <code>month</code> or <code>date</code> timing for stochastic withdrawals</p>"},{"location":"serialization/#goal-serialization","title":"Goal Serialization","text":"<pre><code>from finopt.serialization import goals_to_dict, goals_from_dict\n\n# Serialize\ndata = goals_to_dict(goals)\n# {\n#   \"intermediate\": [{\"account\": \"...\", \"threshold\": 5000000, \"confidence\": 0.9, \"date\": \"2025-07-01\"}],\n#   \"terminal\": [{\"account\": \"...\", \"threshold\": 30000000, \"confidence\": 0.85}]\n# }\n\n# Deserialize\ngoals = goals_from_dict(data, start_date=date(2025, 1, 1))\n</code></pre> <p>Features: - Separates intermediate and terminal goals - Backward compatible: converts legacy <code>month</code> format to <code>date</code> with deprecation warning</p>"},{"location":"serialization/#integration-with-config-module","title":"Integration with Config Module","text":"<p>The serialization module relies on Pydantic configs from <code>config.py</code> for validation:</p> Serializer Config Class <code>account_from_dict</code> <code>AccountConfig</code> <code>income_from_dict</code> <code>IncomeConfig</code>, <code>FixedIncomeConfig</code>, <code>VariableIncomeConfig</code> <code>withdrawal_from_dict</code> <code>WithdrawalConfig</code>, <code>WithdrawalEventConfig</code>, <code>StochasticWithdrawalConfig</code> <code>goals_from_dict</code> <code>IntermediateGoalConfig</code>, <code>TerminalGoalConfig</code> <code>load_scenario</code> <code>SimulationConfig</code>, <code>OptimizationConfig</code> <p>This ensures all loaded configurations are validated against defined schemas before being used to construct Python objects.</p>"},{"location":"serialization/#usage-patterns","title":"Usage Patterns","text":""},{"location":"serialization/#a-save-and-load-model-configuration","title":"A) Save and load model configuration","text":"<pre><code>from pathlib import Path\nfrom finopt import FinancialModel, Account, IncomeModel, FixedIncome\nfrom finopt.serialization import save_model, load_model\n\n# Create model\nincome = IncomeModel(fixed=FixedIncome(base=1_500_000, annual_growth=0.03))\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15)\n]\nmodel = FinancialModel(income, accounts)\n\n# Save\nsave_model(model, Path(\"configs/my_profile.json\"))\n\n# Load in another session\nloaded_model = load_model(Path(\"configs/my_profile.json\"))\n</code></pre>"},{"location":"serialization/#b-save-optimization-results-for-later-analysis","title":"B) Save optimization results for later analysis","text":"<pre><code>from pathlib import Path\nfrom finopt.serialization import save_optimization_result, load_optimization_result\n\n# After optimization\nresult = model.optimize(goals=goals, ...)\n\n# Save\nsave_optimization_result(result, Path(\"results/optimal_policy.json\"))\n\n# Load later\ndata = load_optimization_result(Path(\"results/optimal_policy.json\"))\nX = data[\"X\"]  # np.ndarray\nT = data[\"T\"]  # int\n</code></pre>"},{"location":"serialization/#c-create-reproducible-experiment-scenarios","title":"C) Create reproducible experiment scenarios","text":"<pre><code>from pathlib import Path\nfrom datetime import date\nfrom finopt.serialization import save_scenario, load_scenario\nfrom finopt.goals import TerminalGoal\nfrom finopt.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\n# Define scenario\ngoals = [TerminalGoal(account=\"Agresivo\", threshold=50_000_000, confidence=0.85)]\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule([\n        WithdrawalEvent(\"Conservador\", 5_000_000, date(2027, 1, 1), \"Pie departamento\")\n    ])\n)\n\n# Save complete scenario\nsave_scenario(\n    scenario_name=\"Casa + Jubilaci\u00f3n\",\n    goals=goals,\n    path=Path(\"scenarios/casa_jubilacion.json\"),\n    model=model,\n    withdrawals=withdrawals,\n    start_date=date(2025, 1, 1),\n    n_sims=1000,\n    seed=42,\n    T_max=120\n)\n\n# Load and run\nscenario = load_scenario(Path(\"scenarios/casa_jubilacion.json\"))\nresult = scenario[\"model\"].optimize(\n    goals=scenario[\"goals\"],\n    start=scenario[\"start_date\"],\n    withdrawals=scenario[\"withdrawals\"],\n    n_sims=scenario[\"simulation\"].n_sims,\n    seed=scenario[\"simulation\"].seed,\n    T_max=scenario[\"optimization\"].T_max\n)\n</code></pre>"},{"location":"serialization/#d-reference-external-model-files","title":"D) Reference external model files","text":"<pre><code>from pathlib import Path\nfrom finopt.serialization import save_scenario, load_scenario\n\n# Save scenario referencing external model\nsave_scenario(\n    scenario_name=\"Variante Conservadora\",\n    goals=goals,\n    path=Path(\"scenarios/conservative.json\"),\n    model_path=\"../profiles/my_profile.json\"  # relative path\n)\n\n# Load resolves the reference automatically\nscenario = load_scenario(Path(\"scenarios/conservative.json\"))\nmodel = scenario[\"model\"]  # Loaded from referenced file\n</code></pre>"},{"location":"serialization/#backward-compatibility","title":"Backward Compatibility","text":""},{"location":"serialization/#schema-versioning","title":"Schema versioning","text":"<pre><code># When loading files with different schema versions\n&gt;&gt;&gt; model = load_model(Path(\"old_config.json\"))\nUserWarning: Config schema version 0.1.0 differs from current version 0.2.0.\nMay encounter compatibility issues.\n</code></pre>"},{"location":"serialization/#legacy-goal-format","title":"Legacy goal format","text":"<p>The <code>month</code> field in intermediate goals is deprecated in favor of <code>date</code>:</p> <pre><code># Old format (deprecated)\n{\"account\": \"Savings\", \"threshold\": 1000000, \"confidence\": 0.9, \"month\": 6}\n\n# New format\n{\"account\": \"Savings\", \"threshold\": 1000000, \"confidence\": 0.9, \"date\": \"2025-07-01\"}\n</code></pre> <p>When loading old format, a deprecation warning is issued and the month is converted to a date.</p>"},{"location":"serialization/#api-summary","title":"API Summary","text":"Function Purpose <code>save_model(model, path)</code> Save <code>FinancialModel</code> to JSON <code>load_model(path)</code> Load <code>FinancialModel</code> from JSON <code>save_optimization_result(result, path)</code> Save <code>OptimizationResult</code> to JSON <code>load_optimization_result(path)</code> Load optimization result as dict <code>save_scenario(...)</code> Save complete scenario with all parameters <code>load_scenario(path)</code> Load scenario with reconstructed objects <code>account_to_dict(account)</code> Serialize single <code>Account</code> <code>account_from_dict(data)</code> Deserialize single <code>Account</code> <code>income_to_dict(income_model)</code> Serialize <code>IncomeModel</code> <code>income_from_dict(data)</code> Deserialize <code>IncomeModel</code> <code>withdrawal_to_dict(withdrawal_model)</code> Serialize <code>WithdrawalModel</code> <code>withdrawal_from_dict(data)</code> Deserialize <code>WithdrawalModel</code> <code>goals_to_dict(goals)</code> Serialize list of goals <code>goals_from_dict(data)</code> Deserialize list of goals <p>Constants: - <code>SCHEMA_VERSION = \"0.2.0\"</code> \u2014 Current schema version for all serialized files</p>"},{"location":"utils/","title":"<code>utils</code> \u2014 Shared Utilities for FinOpt","text":"<p>Core idea: Provide common helper functions used across all FinOpt modules. <code>utils.py</code> centralizes validation, rate conversions, array handling, financial metrics, and formatting utilities to avoid code duplication and ensure consistency.</p>"},{"location":"utils/#why-a-dedicated-utils-module","title":"Why a dedicated utils module?","text":"<ul> <li>DRY principle: Common operations defined once, used everywhere</li> <li>Consistency: Standardized rate conversions and formatting across modules</li> <li>Robustness: Edge case handling (division by zero, empty arrays) in one place</li> <li>Testability: Isolated functions that are easy to unit test</li> </ul>"},{"location":"utils/#contents-overview","title":"Contents Overview","text":"Category Functions Validation <code>check_non_negative</code> Rate conversions <code>annual_to_monthly</code>, <code>monthly_to_annual</code> Array/Series helpers <code>ensure_1d</code>, <code>to_series</code>, <code>month_index</code>, <code>align_index_like</code>, <code>normalize_start_month</code> Finance helpers <code>drawdown</code>, <code>compute_cagr</code> Scenario helpers <code>set_random_seed</code>, <code>rescale_returns</code>, <code>bootstrap_returns</code> Reporting <code>summary_metrics</code> Matplotlib formatters <code>millions_formatter</code>, <code>format_currency</code> Return generators <code>fixed_rate_path</code>, <code>lognormal_iid</code> Metrics <code>PortfolioMetrics</code>, <code>compute_metrics</code>"},{"location":"utils/#validation-helpers","title":"Validation Helpers","text":""},{"location":"utils/#check_non_negativename-value","title":"<code>check_non_negative(name, value)</code>","text":"<p>Raises <code>ValueError</code> if value is negative.</p> <pre><code>from finopt.utils import check_non_negative\n\ncheck_non_negative(\"base\", 1_000_000)  # OK\ncheck_non_negative(\"sigma\", -0.1)      # Raises ValueError\n</code></pre> <p>Used by: <code>FixedIncome</code>, <code>VariableIncome</code>, <code>Account</code></p>"},{"location":"utils/#rate-conversions","title":"Rate Conversions","text":""},{"location":"utils/#annual_to_monthlyr_annual-float","title":"<code>annual_to_monthly(r_annual) -&gt; float</code>","text":"<p>Convert nominal annual rate to equivalent compounded monthly rate.</p> \\[ r_m = (1 + r_a)^{1/12} - 1 \\] <pre><code>from finopt.utils import annual_to_monthly\n\nmonthly = annual_to_monthly(0.12)  # 0.12 annual \u2192 0.00949 monthly\n</code></pre> <p>Note: Accepts negative values (for modeling deflation or decay).</p>"},{"location":"utils/#monthly_to_annualr_monthly-float","title":"<code>monthly_to_annual(r_monthly) -&gt; float</code>","text":"<p>Convert nominal monthly rate to equivalent compounded annual rate.</p> \\[ r_a = (1 + r_m)^{12} - 1 \\] <pre><code>from finopt.utils import monthly_to_annual\n\nannual = monthly_to_annual(0.01)  # 0.01 monthly \u2192 0.1268 annual (12.68%)\n</code></pre>"},{"location":"utils/#array-series-helpers","title":"Array / Series Helpers","text":""},{"location":"utils/#ensure_1da-namearray-npndarray","title":"<code>ensure_1d(a, name=\"array\") -&gt; np.ndarray</code>","text":"<p>Convert input to a 1-D float NumPy array with validation.</p> <pre><code>from finopt.utils import ensure_1d\n\narr = ensure_1d([1.0, 2.0, 3.0], name=\"returns\")\n# Returns: array([1., 2., 3.])\n\nensure_1d([[1, 2], [3, 4]])  # Raises ValueError: must be 1-D\nensure_1d([1.0, np.nan])     # Raises ValueError: must contain only finite values\n</code></pre> <p>Checks: - Shape is 1-D - All values are finite (no NaN or Inf)</p>"},{"location":"utils/#to_seriesa-index-namevalue-pdseries","title":"<code>to_series(a, index, name=\"value\") -&gt; pd.Series</code>","text":"<p>Create pandas Series from array-like with optional index.</p> <pre><code>from finopt.utils import to_series\n\nseries = to_series([100, 200, 300], index=pd.date_range(\"2025-01-01\", periods=3, freq=\"MS\"))\n</code></pre>"},{"location":"utils/#month_indexstart-months-pddatetimeindex","title":"<code>month_index(start, months) -&gt; pd.DatetimeIndex</code>","text":"<p>Construct a first-of-month DatetimeIndex for given number of periods.</p> <pre><code>from datetime import date\nfrom finopt.utils import month_index\n\nidx = month_index(start=date(2025, 1, 1), months=6)\n# DatetimeIndex(['2025-01-01', '2025-02-01', '2025-03-01',\n#                '2025-04-01', '2025-05-01', '2025-06-01'], freq='MS')\n\nidx = month_index(start=None, months=6)  # Uses current month as start\n</code></pre> <p>Used by: <code>IncomeModel.project()</code>, <code>IncomeModel.contributions()</code>, plotting methods</p>"},{"location":"utils/#align_index_likemonths-like-pddatetimeindex","title":"<code>align_index_like(months, like) -&gt; pd.DatetimeIndex</code>","text":"<p>Infer DatetimeIndex from an existing Series/DataFrame if possible.</p> <pre><code>from finopt.utils import align_index_like\n\n# Reuse index from existing data\nidx = align_index_like(months=12, like=existing_series)\n\n# Falls back to month_index(None, months) if like is None or incompatible\n</code></pre>"},{"location":"utils/#normalize_start_monthstart-int","title":"<code>normalize_start_month(start) -&gt; int</code>","text":"<p>Map start date or month integer to 0-indexed offset (0=Jan, 11=Dec).</p> <pre><code>from datetime import date\nfrom finopt.utils import normalize_start_month\n\nnormalize_start_month(date(2025, 3, 15))  # \u2192 2 (March)\nnormalize_start_month(9)                   # \u2192 8 (September)\nnormalize_start_month(None)                # \u2192 0 (January default)\n</code></pre> <p>Used by: Seasonality rotation in <code>VariableIncome</code>, contribution fraction rotation</p>"},{"location":"utils/#finance-helpers","title":"Finance Helpers","text":""},{"location":"utils/#drawdownseries-pdseries","title":"<code>drawdown(series) -&gt; pd.Series</code>","text":"<p>Compute drawdown series: \\((W - \\text{cummax}(W)) / \\text{cummax}(W)\\).</p> <pre><code>from finopt.utils import drawdown\n\nwealth = pd.Series([100, 120, 110, 130, 115])\ndd = drawdown(wealth)\n# Returns: [0.0, 0.0, -0.0833, 0.0, -0.1154]\n</code></pre> <p>Features: - Returns zeros for non-positive running maxima (avoids division by zero) - Preserves Series name</p>"},{"location":"utils/#compute_cagrwealth-periods_per_year12-float","title":"<code>compute_cagr(wealth, periods_per_year=12) -&gt; float</code>","text":"<p>Compute Compound Annual Growth Rate from a wealth series.</p> \\[ \\text{CAGR} = \\left(\\frac{W_T}{W_0}\\right)^{1/\\text{years}} - 1 \\] <pre><code>from finopt.utils import compute_cagr\n\nwealth = pd.Series([1_000_000, 1_050_000, 1_100_000, ..., 1_500_000])  # 24 months\ncagr = compute_cagr(wealth, periods_per_year=12)  # ~22.5% annual\n</code></pre> <p>Features: - Uses first strictly-positive observation as starting base - Handles \\(W_0 = 0\\) gracefully (contribution-driven processes) - Returns 0.0 for empty or invalid series</p>"},{"location":"utils/#scenario-helpers","title":"Scenario Helpers","text":""},{"location":"utils/#set_random_seedseed","title":"<code>set_random_seed(seed)</code>","text":"<p>Set NumPy and Python random seeds for reproducibility.</p> <pre><code>from finopt.utils import set_random_seed\n\nset_random_seed(42)  # Sets both np.random and random module\nset_random_seed(None)  # No-op (non-deterministic)\n</code></pre>"},{"location":"utils/#rescale_returnspath-target_mean-target_vol-npndarray","title":"<code>rescale_returns(path, target_mean, target_vol) -&gt; np.ndarray</code>","text":"<p>Rescale an arithmetic-returns path to match target mean and volatility.</p> <pre><code>from finopt.utils import rescale_returns\n\nhistorical = np.array([0.01, -0.02, 0.03, 0.015, -0.01])\nrescaled = rescale_returns(historical, target_mean=0.008, target_vol=0.04)\n</code></pre> <p>Use case: Normalize historical returns to match model assumptions.</p>"},{"location":"utils/#bootstrap_returnshistory-months-seednone-npndarray","title":"<code>bootstrap_returns(history, months, seed=None) -&gt; np.ndarray</code>","text":"<p>Simple IID bootstrap of arithmetic returns from historical sample.</p> <pre><code>from finopt.utils import bootstrap_returns\n\nhistorical = np.array([0.01, -0.02, 0.03, 0.015, -0.01, 0.02])\nbootstrapped = bootstrap_returns(historical, months=24, seed=42)\n# Returns: 24 randomly sampled returns (with replacement)\n</code></pre> <p>Use case: Generate synthetic return scenarios from historical data.</p>"},{"location":"utils/#reporting-helpers","title":"Reporting Helpers","text":""},{"location":"utils/#summary_metricsresults-pddataframe","title":"<code>summary_metrics(results) -&gt; pd.DataFrame</code>","text":"<p>Build a metrics table from a dict of ScenarioResult-like objects.</p> <pre><code>from finopt.utils import summary_metrics\n\nresults = {\n    \"Conservative\": scenario_a,\n    \"Aggressive\": scenario_b,\n}\ndf = summary_metrics(results)\n#                    final_wealth  total_contributions    cagr     vol  max_drawdown\n# Conservative       25_000_000            15_000_000  0.085   0.045        -0.12\n# Aggressive         35_000_000            15_000_000  0.125   0.095        -0.25\n</code></pre> <p>Duck-typing: Each value must have <code>.metrics</code> with attributes: <code>final_wealth</code>, <code>total_contributions</code>, <code>cagr</code>, <code>vol</code>, <code>max_drawdown</code>.</p>"},{"location":"utils/#matplotlib-formatters","title":"Matplotlib Formatters","text":""},{"location":"utils/#millions_formatterx-pos-str","title":"<code>millions_formatter(x, pos) -&gt; str</code>","text":"<p>Format axis values as millions for matplotlib FuncFormatter.</p> <pre><code>from matplotlib.ticker import FuncFormatter\nfrom finopt.utils import millions_formatter\n\nax.yaxis.set_major_formatter(FuncFormatter(millions_formatter))\n# 25_000_000 \u2192 \"25M\"\n# 12_500_000 \u2192 \"12.5M\"\n</code></pre>"},{"location":"utils/#format_currencyvalue-decimals1-symbol-unitm-str","title":"<code>format_currency(value, decimals=1, symbol='$', unit='M') -&gt; str</code>","text":"<p>Format currency values for text annotations and labels.</p> <pre><code>from finopt.utils import format_currency\n\nformat_currency(25_000_000)              # \u2192 '$25.0M'\nformat_currency(25_000_000, decimals=0)  # \u2192 '$25M'\nformat_currency(5_500_000, decimals=2)   # \u2192 '$5.50M'\n</code></pre> <p>Use case: Text annotations, legends, titles where FuncFormatter cannot be applied.</p>"},{"location":"utils/#return-path-generators","title":"Return-Path Generators","text":""},{"location":"utils/#fixed_rate_pathmonths-r_monthly-npndarray","title":"<code>fixed_rate_path(months, r_monthly) -&gt; np.ndarray</code>","text":"<p>Return a constant arithmetic monthly return path.</p> <pre><code>from finopt.utils import fixed_rate_path\n\npath = fixed_rate_path(months=12, r_monthly=0.005)\n# Returns: array([0.005, 0.005, ..., 0.005])  # 12 elements\n</code></pre> <p>Use case: Deterministic scenarios for testing or benchmarking.</p>"},{"location":"utils/#lognormal_iidmonths-mu-sigma-seednone-npndarray","title":"<code>lognormal_iid(months, mu, sigma, seed=None) -&gt; np.ndarray</code>","text":"<p>IID arithmetic returns derived from lognormal gross returns.</p> \\[ G_t \\sim \\text{LogNormal}(\\mu, \\sigma), \\quad r_t = G_t - 1 \\] <pre><code>from finopt.utils import lognormal_iid\n\nreturns = lognormal_iid(months=24, mu=0.005, sigma=0.04, seed=42)\n# Returns: 24 arithmetic returns, all &gt; -1 (guaranteed)\n</code></pre> <p>Guarantee: \\(r_t &gt; -1\\) always (no impossible bankruptcies).</p> <p>Note: <code>mu</code> and <code>sigma</code> are parameters of the normal distribution in log-gross space, not arithmetic mean/volatility.</p>"},{"location":"utils/#metrics","title":"Metrics","text":""},{"location":"utils/#portfoliometrics-frozen-dataclass","title":"<code>PortfolioMetrics</code> (frozen dataclass)","text":"<p>Container for portfolio performance metrics.</p> <pre><code>@dataclass(frozen=True)\nclass PortfolioMetrics:\n    final_wealth: float\n    total_contributions: float\n    cagr: float\n    vol: float\n    max_drawdown: float\n</code></pre>"},{"location":"utils/#compute_metricswealth-contributionsnone-periods_per_year12-portfoliometrics","title":"<code>compute_metrics(wealth, contributions=None, periods_per_year=12) -&gt; PortfolioMetrics</code>","text":"<p>Compute key metrics for a simulated wealth path.</p> <pre><code>from finopt.utils import compute_metrics\n\nmetrics = compute_metrics(wealth_series, contributions=contrib_series)\nprint(f\"Final wealth: {metrics.final_wealth:,.0f}\")\nprint(f\"CAGR: {metrics.cagr:.2%}\")\nprint(f\"Max drawdown: {metrics.max_drawdown:.2%}\")\n</code></pre> <p>Computed metrics: | Metric | Description | |--------|-------------| | <code>final_wealth</code> | \\(W_T\\) (terminal wealth) | | <code>total_contributions</code> | \\(\\sum A_t\\) (if provided) | | <code>cagr</code> | Compound annual growth rate | | <code>vol</code> | Standard deviation of approximate monthly returns | | <code>max_drawdown</code> | Minimum of drawdown series |</p> <p>Note: When wealth includes contributions, <code>vol</code> based on \\(\\Delta W / W_{t-1}\\) is approximate. For pure risk analysis, use exogenous returns instead.</p>"},{"location":"utils/#usage-examples","title":"Usage Examples","text":""},{"location":"utils/#a-rate-conversion-for-account-setup","title":"A) Rate conversion for account setup","text":"<pre><code>from finopt.utils import annual_to_monthly, monthly_to_annual\n\n# User specifies annual, internally we use monthly\nannual_return = 0.08\nmonthly_return = annual_to_monthly(annual_return)  # 0.00643\n\n# Verify round-trip\nassert abs(monthly_to_annual(monthly_return) - annual_return) &lt; 1e-10\n</code></pre>"},{"location":"utils/#b-calendar-aware-index-construction","title":"B) Calendar-aware index construction","text":"<pre><code>from datetime import date\nfrom finopt.utils import month_index\n\n# Generate 24-month projection index starting September 2025\nidx = month_index(start=date(2025, 9, 1), months=24)\n# ['2025-09-01', '2025-10-01', ..., '2027-08-01']\n</code></pre>"},{"location":"utils/#c-portfolio-metrics-after-simulation","title":"C) Portfolio metrics after simulation","text":"<pre><code>from finopt.utils import compute_metrics, format_currency\n\nresult = model.simulate(T=36, n_sims=1)\nmetrics = compute_metrics(\n    wealth=result.wealth.iloc[:, 0],  # First simulation, total wealth\n    contributions=result.contributions\n)\n\nprint(f\"Final: {format_currency(metrics.final_wealth)}\")\nprint(f\"CAGR: {metrics.cagr:.1%}\")\nprint(f\"Max DD: {metrics.max_drawdown:.1%}\")\n</code></pre>"},{"location":"utils/#d-consistent-plot-formatting","title":"D) Consistent plot formatting","text":"<pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nfrom finopt.utils import millions_formatter, format_currency\n\nfig, ax = plt.subplots()\nax.plot(dates, wealth)\nax.yaxis.set_major_formatter(FuncFormatter(millions_formatter))\nax.set_title(f\"Wealth projection (Final: {format_currency(wealth[-1])})\")\n</code></pre>"},{"location":"utils/#module-usage-in-finopt","title":"Module Usage in FinOpt","text":"Module Utils Used <code>income.py</code> <code>check_non_negative</code>, <code>annual_to_monthly</code>, <code>month_index</code>, <code>normalize_start_month</code>, <code>millions_formatter</code>, <code>format_currency</code> <code>portfolio.py</code> <code>check_non_negative</code>, <code>annual_to_monthly</code>, <code>monthly_to_annual</code> <code>returns.py</code> <code>annual_to_monthly</code>, <code>monthly_to_annual</code> <code>model.py</code> <code>month_index</code>, <code>millions_formatter</code>, <code>format_currency</code>, <code>compute_metrics</code> <code>goals.py</code> <code>month_index</code> <code>withdrawal.py</code> <code>month_index</code>"},{"location":"utils/#api-summary","title":"API Summary","text":"Function Purpose <code>check_non_negative(name, value)</code> Validate non-negative values <code>annual_to_monthly(r)</code> Annual \u2192 monthly rate conversion <code>monthly_to_annual(r)</code> Monthly \u2192 annual rate conversion <code>ensure_1d(a, name)</code> Convert to validated 1-D array <code>to_series(a, index, name)</code> Create pandas Series <code>month_index(start, months)</code> Build first-of-month DatetimeIndex <code>align_index_like(months, like)</code> Infer index from existing data <code>normalize_start_month(start)</code> Map date/int to 0-11 offset <code>drawdown(series)</code> Compute drawdown series <code>compute_cagr(wealth)</code> Compute CAGR from wealth path <code>set_random_seed(seed)</code> Set RNG seeds for reproducibility <code>rescale_returns(path, mean, vol)</code> Normalize returns to target stats <code>bootstrap_returns(history, months)</code> IID bootstrap from historical data <code>summary_metrics(results)</code> Build comparison DataFrame <code>millions_formatter(x, pos)</code> Matplotlib axis formatter <code>format_currency(value)</code> Text currency formatting <code>fixed_rate_path(months, r)</code> Constant return path <code>lognormal_iid(months, mu, sigma)</code> Lognormal IID returns <code>compute_metrics(wealth)</code> Compute PortfolioMetrics"},{"location":"withdrawal/","title":"<code>withdrawal</code> \u2014 Scheduled Cash Outflows for FinOpt","text":"<p>Core idea: Model planned withdrawals (retiros) from investment accounts as parameters in the wealth dynamics equation. <code>withdrawal.py</code> captures cash outflows such as purchases, emergency expenses, or periodic distributions, producing arrays that downstream modules (<code>portfolio</code>, <code>optimization</code>) consume to adjust wealth trajectories.</p>"},{"location":"withdrawal/#why-a-dedicated-withdrawal-module","title":"Why a dedicated withdrawal module?","text":"<ul> <li>Explicit cash outflows: Withdrawals are first-class citizens, not hidden adjustments</li> <li>Optimization-compatible: Withdrawals are parameters (not decision variables), preserving convexity</li> <li>Calendar-aware: Dates are resolved to month offsets, matching <code>goals.py</code> and <code>income.py</code> patterns</li> <li>Dual mode: Supports both deterministic schedules and stochastic (uncertain) withdrawals</li> </ul>"},{"location":"withdrawal/#design-philosophy","title":"Design philosophy","text":"<ol> <li>Immutable specifications</li> <li><code>WithdrawalEvent</code> and <code>StochasticWithdrawal</code> are frozen dataclasses</li> <li> <p>Safe to hash, cache, and use as dict keys</p> </li> <li> <p>Calendar-aware resolution</p> </li> <li>Dates converted to month offsets via <code>resolve_month(start_date)</code></li> <li> <p>1-indexed months (matching <code>IntermediateGoal</code>)</p> </li> <li> <p>Pattern matching</p> </li> <li><code>WithdrawalEvent</code> \u2192 analogous to <code>IntermediateGoal</code> (fixed date, single amount)</li> <li><code>StochasticWithdrawal</code> \u2192 analogous to <code>VariableIncome</code> (base + sigma + floor/cap)</li> <li> <p><code>WithdrawalModel</code> \u2192 analogous to <code>IncomeModel</code> (facade combining deterministic + stochastic)</p> </li> <li> <p>Backward compatible</p> </li> <li><code>D=None</code> in <code>portfolio.simulate()</code> preserves existing behavior (no withdrawals)</li> </ol>"},{"location":"withdrawal/#mathematical-framework","title":"Mathematical Framework","text":""},{"location":"withdrawal/#wealth-dynamics-with-withdrawals","title":"Wealth dynamics with withdrawals","text":"\\[ W_{t+1}^m = \\big(W_t^m + A_t \\cdot x_t^m - D_t^m\\big)(1 + R_t^m) \\] <p>where: - \\(W_t^m\\) = wealth in account \\(m\\) at start of month \\(t\\) - \\(A_t\\) = total contribution at month \\(t\\) - \\(x_t^m\\) = allocation fraction to account \\(m\\) - \\(D_t^m\\) = withdrawal from account \\(m\\) during month \\(t\\) - \\(R_t^m\\) = return of account \\(m\\) during month \\(t\\)</p> <p>Timing convention: Withdrawal occurs at start of month (before returns applied). The withdrawn amount does not earn returns that month \u2014 this is the conservative assumption.</p>"},{"location":"withdrawal/#affine-representation-critical-for-optimization","title":"Affine representation (critical for optimization)","text":"\\[ \\boxed{ W_t^m(X) = W_0^m \\cdot F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\cdot x_s^m - D_s^m\\big) \\cdot F_{s,t}^m } \\] <p>Key insight: \\(D\\) is a parameter (not a decision variable), so wealth remains affine in \\(X\\), preserving convexity for CVaR optimization.</p>"},{"location":"withdrawal/#key-components","title":"Key components","text":""},{"location":"withdrawal/#1-withdrawalevent-frozen-dataclass","title":"1) <code>WithdrawalEvent</code> (frozen dataclass)","text":"<p>Single scheduled withdrawal from an investment account.</p> <pre><code>from datetime import date\nfrom finopt.src.withdrawal import WithdrawalEvent\n\nevent = WithdrawalEvent(\n    account=\"Conservador\",       # Account name or index\n    amount=400_000,              # Withdrawal amount (must be positive)\n    date=date(2025, 6, 1),       # Calendar date\n    description=\"Compra bicicleta\"  # Optional description\n)\n\n# Month resolution (1-indexed)\nmonth = event.resolve_month(date(2025, 1, 1))  # \u2192 6\n</code></pre> <p>Parameters: - <code>account</code>: Target account identifier (int index or str name) - <code>amount</code>: Withdrawal amount (must be positive) - <code>date</code>: Calendar date of the withdrawal - <code>description</code>: Optional human-readable description</p> <p>Month resolution: Same as <code>IntermediateGoal.resolve_month()</code> \u2014 returns 1-indexed month offset.</p>"},{"location":"withdrawal/#2-withdrawalschedule-dataclass","title":"2) <code>WithdrawalSchedule</code> (dataclass)","text":"<p>Collection of scheduled withdrawals for portfolio simulation.</p> <pre><code>from finopt.src.withdrawal import WithdrawalSchedule\n\nschedule = WithdrawalSchedule(events=[\n    WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1), \"Bicicleta\"),\n    WithdrawalEvent(\"Agresivo\", 2_000_000, date(2026, 12, 1), \"Vacaciones\")\n])\n\n# Convert to array for simulation\nD = schedule.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts\n)\n# D.shape \u2192 (36, 2)\n# D[5, 0] \u2192 400000.0 (June withdrawal from account 0)\n</code></pre> <p>Methods:</p> Method Returns Description <code>to_array(T, start_date, accounts)</code> <code>(T, M)</code> array Convert events to numpy array <code>total_by_account(accounts)</code> <code>Dict[str, float]</code> Sum of withdrawals per account <code>get_events_for_account(account)</code> <code>List[WithdrawalEvent]</code> Filter events by account <code>to_dict()</code> <code>dict</code> Serialize to dictionary <code>from_dict(payload)</code> <code>WithdrawalSchedule</code> Deserialize from dictionary <p>Behavior: - Events outside simulation horizon are ignored with a warning - Multiple events on the same month/account are summed - Empty events list is valid (returns zeros)</p>"},{"location":"withdrawal/#3-stochasticwithdrawal-frozen-dataclass","title":"3) <code>StochasticWithdrawal</code> (frozen dataclass)","text":"<p>Withdrawal with variability/uncertainty. Models withdrawals that have a base expected amount but may vary across scenarios (e.g., variable medical expenses, emergency costs).</p> <pre><code>from finopt.src.withdrawal import StochasticWithdrawal\n\nwithdrawal = StochasticWithdrawal(\n    account=\"Conservador\",\n    base_amount=300_000,      # Expected amount (mean)\n    sigma=50_000,             # Standard deviation\n    date=date(2025, 9, 1),    # Calendar date (or use month=9)\n    floor=200_000,            # Minimum amount\n    cap=500_000,              # Maximum amount\n    seed=42                   # Random seed\n)\n\n# Generate samples\nsamples = withdrawal.sample(n_sims=1000, start_date=date(2025, 1, 1))\n# samples.shape \u2192 (1000,)\n# All samples in [200_000, 500_000]\n</code></pre> <p>Parameters: - <code>account</code>: Target account identifier - <code>base_amount</code>: Expected withdrawal amount (mean of distribution) - <code>sigma</code>: Standard deviation - <code>month</code> or <code>date</code>: Timing (mutually exclusive, one required) - <code>floor</code>: Minimum withdrawal (default 0.0) - <code>cap</code>: Maximum withdrawal (None = no cap) - <code>seed</code>: Random seed for reproducibility</p> <p>Sampling: Truncated Gaussian distribution \\(\\mathcal{N}(\\text{base}, \\sigma^2)\\) clamped to \\([\\text{floor}, \\text{cap}]\\).</p>"},{"location":"withdrawal/#4-withdrawalmodel-dataclass","title":"4) <code>WithdrawalModel</code> (dataclass)","text":"<p>Unified facade combining scheduled and stochastic withdrawals.</p> <pre><code>from finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, StochasticWithdrawal\n\nmodel = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1))\n    ]),\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=300_000,\n            sigma=50_000,\n            date=date(2025, 9, 1),\n            seed=42\n        )\n    ]\n)\n\n# Generate combined withdrawal array\nD = model.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts,\n    n_sims=500,\n    seed=42\n)\n# D.shape \u2192 (500, 36, 2)\n\n# Check expected totals\nmodel.total_expected(accounts)\n# \u2192 {'Conservador': 700000.0, 'Agresivo': 0.0}\n</code></pre> <p>Methods:</p> Method Returns Description <code>to_array(T, start_date, accounts, n_sims, seed)</code> <code>(n_sims, T, M)</code> array Combined withdrawal scenarios <code>total_expected(accounts)</code> <code>Dict[str, float]</code> Expected total per account <code>to_dict()</code> <code>dict</code> Serialize to dictionary <code>from_dict(payload)</code> <code>WithdrawalModel</code> Deserialize from dictionary <p>Behavior: - Scheduled withdrawals: broadcast to all scenarios (same values) - Stochastic withdrawals: independent sampling per scenario - Empty model returns zeros</p>"},{"location":"withdrawal/#month-resolution","title":"Month Resolution","text":"<p>Withdrawals use 1-indexed months, matching <code>IntermediateGoal</code>:</p> Date <code>resolve_month()</code> Array Index Interpretation January 1, 2025 (start) 1 0 Withdrawal during month 0 February 1, 2025 2 1 Withdrawal during month 1 June 1, 2025 6 5 Withdrawal during month 5 December 1, 2026 24 23 Withdrawal during month 23 <p>Example: <pre><code>event = WithdrawalEvent(\"Account\", 100_000, date(2025, 6, 1))\nmonth = event.resolve_month(date(2025, 1, 1))  # \u2192 6\n# Array index = month - 1 = 5\n# D[5, m] receives the withdrawal\n</code></pre></p>"},{"location":"withdrawal/#integration-with-portfolio","title":"Integration with Portfolio","text":""},{"location":"withdrawal/#basic-usage","title":"Basic usage","text":"<pre><code>from datetime import date\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.withdrawal import WithdrawalSchedule, WithdrawalEvent\n\n# Define accounts\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15)\n]\nportfolio = Portfolio(accounts)\n\n# Define withdrawals\nschedule = WithdrawalSchedule(events=[\n    WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1)),\n    WithdrawalEvent(\"Agresivo\", 2_000_000, date(2026, 12, 1))\n])\n\n# Convert to array\nD = schedule.to_array(T=36, start_date=date(2025, 1, 1), accounts=accounts)\n\n# Simulate with withdrawals\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre>"},{"location":"withdrawal/#with-stochastic-withdrawals","title":"With stochastic withdrawals","text":"<pre><code>from finopt.src.withdrawal import WithdrawalModel, StochasticWithdrawal\n\nmodel = WithdrawalModel(\n    scheduled=schedule,\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=200_000,\n            sigma=30_000,\n            date=date(2025, 9, 1),\n            floor=100_000,\n            cap=400_000\n        )\n    ]\n)\n\n# Generate stochastic withdrawal scenarios\nD = model.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts,\n    n_sims=500,\n    seed=42\n)\n# D.shape \u2192 (500, 36, 2)\n\n# Simulate\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre>"},{"location":"withdrawal/#integration-with-optimization","title":"Integration with Optimization","text":""},{"location":"withdrawal/#cvaroptimizer-with-withdrawals","title":"CVaROptimizer with withdrawals","text":"<pre><code>from finopt.src.optimization import CVaROptimizer, GoalSeeker\n\noptimizer = CVaROptimizer(n_accounts=2, objective='balanced')\n\n# Define D_generator for GoalSeeker\ndef D_gen(T, n_sims, seed):\n    return model.to_array(\n        T=T,\n        start_date=date(2025, 1, 1),\n        accounts=accounts,\n        n_sims=n_sims,\n        seed=seed\n    )\n\nseeker = GoalSeeker(optimizer, T_max=120)\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05  # 95% confidence for withdrawal feasibility\n)\n</code></pre>"},{"location":"withdrawal/#withdrawal-feasibility-constraints","title":"Withdrawal feasibility constraints","text":"<p>The optimizer adds CVaR constraints to ensure sufficient wealth before each withdrawal:</p> \\[ \\mathbb{P}(W_t^m \\geq D_t^m) \\geq 1 - \\epsilon \\] <p>CVaR reformulation: $$ \\text{CVaR}_\\epsilon(D_t^m - W_t^m) \\leq 0 $$</p> <p>Default: <code>withdrawal_epsilon=0.05</code> (95% confidence of meeting withdrawals)</p>"},{"location":"withdrawal/#complete-example","title":"Complete Example","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.withdrawal import (\n    WithdrawalEvent, WithdrawalSchedule,\n    StochasticWithdrawal, WithdrawalModel\n)\nfrom finopt.src.goals import TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer, GoalSeeker\n\n# 1. Define accounts\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08,\n                        display_name=\"Fondo Conservador\"),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15,\n                        display_name=\"Fondo Agresivo\")\n]\n\n# 2. Define withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\n            account=\"Conservador\",\n            amount=400_000,\n            date=date(2025, 6, 1),\n            description=\"Compra bicicleta\"\n        ),\n        WithdrawalEvent(\n            account=\"Agresivo\",\n            amount=5_000_000,\n            date=date(2027, 1, 1),\n            description=\"Pie departamento\"\n        )\n    ]),\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=200_000,\n            sigma=50_000,\n            date=date(2025, 12, 1),\n            floor=100_000,\n            cap=400_000\n        )\n    ]\n)\n\n# 3. Define goals\ngoals = [\n    TerminalGoal(account=\"Conservador\", threshold=10_000_000, confidence=0.90),\n    TerminalGoal(account=\"Agresivo\", threshold=30_000_000, confidence=0.85)\n]\n\n# 4. Setup optimization\nstart_date = date(2025, 1, 1)\ninitial_wealth = np.array([2_000_000, 5_000_000])\n\ndef A_gen(T, n_sims, seed):\n    return np.full((n_sims, T), 500_000)\n\ndef R_gen(T, n_sims, seed):\n    np.random.seed(seed)\n    return np.random.normal(0.005, 0.02, (n_sims, T, 2))\n\ndef D_gen(T, n_sims, seed):\n    return withdrawals.to_array(T, start_date, accounts, n_sims, seed)\n\n# 5. Optimize\noptimizer = CVaROptimizer(n_accounts=2, objective='balanced')\nseeker = GoalSeeker(optimizer, T_max=60, verbose=True)\n\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=start_date,\n    n_sims=500,\n    seed=42,\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(f\"Expected withdrawals: {withdrawals.total_expected(accounts)}\")\n</code></pre>"},{"location":"withdrawal/#serialization","title":"Serialization","text":"<p>Both <code>WithdrawalSchedule</code> and <code>WithdrawalModel</code> support JSON serialization:</p> <pre><code># Serialize\ndata = model.to_dict()\n# {\n#     \"scheduled\": {\"events\": [...]},\n#     \"stochastic\": [...]\n# }\n\n# Save to file\nimport json\nwith open(\"withdrawals.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\n# Load from file\nwith open(\"withdrawals.json\", \"r\") as f:\n    data = json.load(f)\nmodel = WithdrawalModel.from_dict(data)\n</code></pre>"},{"location":"withdrawal/#comparison-with-other-modules","title":"Comparison with Other Modules","text":"Module Concept Pattern <code>income.py</code> <code>FixedIncome</code> Deterministic contributions <code>withdrawal.py</code> <code>WithdrawalEvent</code> Deterministic withdrawals <code>income.py</code> <code>VariableIncome</code> Stochastic contributions <code>withdrawal.py</code> <code>StochasticWithdrawal</code> Stochastic withdrawals <code>income.py</code> <code>IncomeModel</code> Facade (fixed + variable) <code>withdrawal.py</code> <code>WithdrawalModel</code> Facade (scheduled + stochastic) <code>goals.py</code> <code>IntermediateGoal</code> Fixed-date constraint <code>withdrawal.py</code> <code>WithdrawalEvent</code> Fixed-date withdrawal"},{"location":"withdrawal/#api-summary","title":"API Summary","text":"Class Type Purpose <code>WithdrawalEvent</code> frozen dataclass Single scheduled withdrawal <code>WithdrawalSchedule</code> dataclass Collection of scheduled withdrawals <code>StochasticWithdrawal</code> frozen dataclass Withdrawal with uncertainty <code>WithdrawalModel</code> dataclass Unified facade <p>Key methods: - <code>resolve_month(start_date)</code> \u2014 Convert date to 1-indexed month offset - <code>to_array(T, start_date, accounts, ...)</code> \u2014 Generate numpy array for simulation - <code>total_by_account(accounts)</code> / <code>total_expected(accounts)</code> \u2014 Summarize withdrawals - <code>to_dict()</code> / <code>from_dict(payload)</code> \u2014 Serialization</p>"}]}