{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to FinOpt","text":"<p>FinOpt is a modular Python framework designed for intelligent financial planning. It combines stochastic simulation of income and investment returns with convex optimization to help users achieve their financial goals under uncertainty.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stochastic Income Modeling: Simulate fixed and variable income with growth, seasonality, and noise.</li> <li>Wealth Dynamics: Model the evolution of investment accounts using affine wealth representations.</li> <li>Goal-Oriented Optimization: Find the minimum time to achieve multiple financial goals (e.g., emergency funds, housing) with a specified level of confidence.</li> <li>Bilevel Optimization: Solve complex problems that minimize time while maximizing terminal wealth.</li> <li>Extensible Architecture: Modular design allows for custom return models, optimizers, and goal types.</li> </ul>"},{"location":"#documentation-roadmap","title":"Documentation Roadmap","text":"<p>Explore the technical components of the FinOpt framework:</p>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Stochastic Returns: Generating correlated lognormal returns for simulation.</li> <li>Income Module: Modeling fixed and variable cash flows with growth and seasonality.</li> <li>Portfolio Dynamics: The mathematics of wealth evolution and affine representations.</li> <li>Scheduled Withdrawals: Integration of planned cash outflows into the wealth equation.</li> </ul>"},{"location":"#optimization-logic","title":"Optimization &amp; Logic","text":"<ul> <li>Goals Framework: Defining financial milestones as probabilistic chance constraints.</li> <li>Optimization: Technical details on CVaR reformulation and Sample Average Approximation (SAA) solvers.</li> </ul>"},{"location":"#integration-architecture","title":"Integration &amp; Architecture","text":"<ul> <li>Unified Model: The <code>FinancialModel</code> facade that orchestrates all system components.</li> <li>Technical Framework: A deep dive into the system architecture, design principles, and mathematical foundations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre> <p>(Refer to the repository for more details on setup and usage)</p>"},{"location":"framework/","title":"FinOpt \u2014 Technical Framework","text":"<p>Tagline: Intelligent financial planning through stochastic simulation and convex optimization under uncertainty.</p> <p>This document describes the theoretical and technical framework of FinOpt, a modular system that connects user objectives (emergency funds, housing, retirement) with optimal investment strategies under stochastic income and returns via chance-constrained optimization.</p>"},{"location":"framework/#0-system-architecture","title":"0. System Architecture","text":"<p>FinOpt is composed of six core modules:</p> Module Purpose Key Abstractions <code>income.py</code> Cash flow modeling <code>FixedIncome</code>, <code>VariableIncome</code>, <code>IncomeModel</code> <code>portfolio.py</code> Wealth dynamics <code>Account</code>, <code>Portfolio</code> (affine wealth executor) <code>returns.py</code> Stochastic returns <code>ReturnModel</code> (correlated lognormal) <code>goals.py</code> Goal specification <code>IntermediateGoal</code>, <code>TerminalGoal</code>, <code>GoalSet</code> <code>optimization.py</code> Solvers <code>SAAOptimizer</code>, <code>CVaROptimizer</code>, <code>GoalSeeker</code> <code>model.py</code> Orchestration <code>FinancialModel</code> (unified facade) <p>Dependency graph: <pre><code>model.py (FinancialModel)\n    \u251c\u2500\u2192 income.py (IncomeModel)\n    \u251c\u2500\u2192 portfolio.py (Portfolio)\n    \u251c\u2500\u2192 returns.py (ReturnModel)\n    \u2514\u2500\u2192 optimization.py (GoalSeeker)\n            \u251c\u2500\u2192 goals.py (GoalSet)\n            \u2514\u2500\u2192 AllocationOptimizer (SAAOptimizer)\n</code></pre></p> <p>Design principles: - Loose coupling: Each module usable independently - Lazy imports: Optimization only loaded when needed (TYPE_CHECKING) - Separation of concerns: Portfolio executes dynamics, doesn't generate returns - Reproducibility: Explicit seed management with automatic propagation</p>"},{"location":"framework/#1-income-module","title":"1. Income Module","text":"<p>Total monthly income at time \\(t\\) is composed of fixed and variable parts:</p> \\[ Y_t = y_t^{\\text{fixed}} + Y_t^{\\text{variable}} \\]"},{"location":"framework/#11-fixed-income","title":"1.1 Fixed Income","text":"<p>The fixed component, \\(y_t^{\\text{fixed}}\\), reflects baseline salary subject to compounded annual growth \\(g\\) and scheduled raises \\(\\{(d_k, \\Delta_k)\\}\\):</p> \\[ y_t^{\\text{fixed}} = \\text{current\\_salary}(t) \\cdot (1+m)^{\\Delta t} \\] <p>where \\(m = (1 + g)^{1/12} - 1\\) is the monthly compounded rate, and \\(\\Delta t\\) represents time since the last raise.</p> <p>API: <pre><code>fixed = FixedIncome(\n    base=1_400_000,           # Current monthly salary\n    annual_growth=0.03,       # 3% annual raises\n    raises=[(12, 100_000)]    # +100k at month 12\n)\n</code></pre></p>"},{"location":"framework/#12-variable-income","title":"1.2 Variable Income","text":"<p>The variable component, \\(Y_t^{\\text{variable}}\\), models irregular income (freelance, bonuses) with:</p> <ul> <li>Seasonality: \\(s \\in \\mathbb{R}^{12}\\) (multiplicative monthly factors)</li> <li>Noise: \\(\\epsilon_t \\sim \\mathcal{N}(0, \\sigma^2)\\) (Gaussian shocks)</li> <li>Growth: same compounded rate \\(m\\) applied to base income</li> <li>Boundaries: optional floor and cap constraints</li> </ul> <p>The underlying stochastic projection:</p> \\[ \\tilde{Y}_t = \\max(\\text{floor},\\ \\mu_t (1 + \\epsilon_t)), \\quad \\text{where } \\mu_t = \\text{base} \\cdot (1 + m)^t \\cdot s_{(t \\bmod 12)} \\] <p>Then, guardrails:</p> \\[ Y_t^{\\text{variable}} = \\begin{cases} 0 &amp; \\text{if } \\tilde{Y}_t &lt; 0 \\\\ \\tilde{Y}_t &amp; \\text{if } 0 \\leq \\tilde{Y}_t \\leq \\text{cap} \\\\ \\text{cap} &amp; \\text{if } \\tilde{Y}_t &gt; \\text{cap} \\end{cases} \\] <p>API: <pre><code>variable = VariableIncome(\n    base=200_000,                   # Average monthly variable income\n    sigma=0.10,                     # 10% volatility\n    seasonality=[1.2, 0.8, ...],   # 12-month cycle\n    seed=42                         # Reproducibility\n)\n</code></pre></p>"},{"location":"framework/#13-contributions","title":"1.3 Contributions","text":"<p>A fraction of income is allocated monthly via calendar-rotating schedules:</p> \\[ A_t = \\alpha_{(t \\bmod 12)}^{f} \\cdot y_t^{\\text{fixed}} + \\alpha_{(t \\bmod 12)}^{v} \\cdot Y_t^{\\text{variable}} \\] <p>where \\(\\alpha^f, \\alpha^v \\in [0,1]^{12}\\) control fixed/variable contribution rates, rotated according to <code>start</code> date.</p> <p>API: <pre><code>income = IncomeModel(fixed=fixed, variable=variable)\nA = income.contributions(\n    months=24,\n    start=date(2025, 1, 1),\n    n_sims=500,\n    seed=42\n)  # \u2192 (500, 24) array\n</code></pre></p>"},{"location":"framework/#2-portfolio-dynamics","title":"2. Portfolio Dynamics","text":""},{"location":"framework/#21-wealth-evolution","title":"2.1 Wealth Evolution","text":"<p>Multiple accounts \\(m \\in \\mathcal{M} = \\{1,\\dots,M\\}\\) evolve via:</p> \\[ W_{t+1}^m = \\big(W_t^m + A_t x_t^m\\big)(1 + R_t^m) \\] <p>where: - \\(W_t^m\\) = wealth in account \\(m\\) at month \\(t\\) - \\(A_t x_t^m\\) = allocated contribution (\\(x_t^m\\) fraction of total contribution \\(A_t\\)) - \\(R_t^m\\) = stochastic return of account \\(m\\)</p> <p>API: <pre><code>accounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, \n                        annual_volatility=0.05, initial_wealth=0),\n    Account.from_annual(\"Housing\", annual_return=0.07, \n                        annual_volatility=0.12, initial_wealth=0)\n]\nportfolio = Portfolio(accounts)\n</code></pre></p>"},{"location":"framework/#22-allocation-policy","title":"2.2 Allocation Policy","text":"<p>Contributions allocated via decision variables \\(x_t^m \\in [0,1]\\) satisfying:</p> \\[ \\sum_{m=1}^M x_t^m = 1, \\quad x_t^m \\ge 0, \\quad \\forall t \\] <p>The allocation simplex at horizon \\(T\\) is:</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} :  \\begin{aligned} &amp; x_t^m \\ge 0 &amp;&amp; \\text{(non-negativity)} \\\\ &amp; \\sum_{m=1}^M x_t^m = 1 &amp;&amp; \\text{(budget constraint)} \\\\ &amp; \\forall t = 0, \\dots, T-1 \\end{aligned} \\right\\} \\] <p>representing all budget-feasible allocation policies (full contribution deployment each month).</p> <p>Geometric interpretation: \\(\\mathcal{X}_T\\) is the Cartesian product of \\(T\\) probability simplices: $$ \\mathcal{X}T = \\underbrace{\\Delta^{M-1} \\times \\cdots \\times \\Delta^{M-1}}{T \\text{ times}}, \\quad \\Delta^{M-1} = \\left{x \\in \\mathbb{R}+^M : \\sum{m=1}^M x^m = 1\\right} $$</p> <p>API: <pre><code>X = np.tile([0.6, 0.4], (T, 1))  # 60-40 split \u2208 \ud835\udcb3_T\n</code></pre></p>"},{"location":"framework/#23-affine-wealth-representation","title":"2.3 Affine Wealth Representation","text":"<p>Recursive wealth can be expressed in closed-form:</p> \\[ \\boxed{ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s \\, x_s^m \\, F_{s,t}^m } \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Key properties: 1. \\(W_t^m(X)\\) is affine in allocation policy \\(X\\) (linearity immediately visible) 2. Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) (analytical!) 3. Enables gradient-based convex optimization</p> <p>Implementation: <pre><code>result = portfolio.simulate(A=A, R=R, X=X, method=\"affine\")\nW = result[\"wealth\"]  # (n_sims, T+1, M)\n</code></pre></p>"},{"location":"framework/#3-goals-framework","title":"3. Goals Framework","text":""},{"location":"framework/#31-goal-types","title":"3.1 Goal Types","text":"<p>FinOpt supports two goal primitives:</p> <p>Intermediate Goal (fixed time): <pre><code>IntermediateGoal(\n    month=12,                    # Or date(2026, 1, 1)\n    account=\"Emergency\",\n    threshold=5_500_000,         # 5.5M CLP\n    confidence=0.90              # 90% probability\n)\n</code></pre></p> <p>Mathematical constraint: $$ \\mathbb{P}\\big(W_{t}^m \\ge b\\big) \\ge 1-\\varepsilon $$</p> <p>Terminal Goal (variable time): <pre><code>TerminalGoal(\n    account=\"Housing\",\n    threshold=20_000_000,        # 20M CLP\n    confidence=0.90\n)\n</code></pre></p> <p>Mathematical constraint: $$ \\mathbb{P}\\big(W_{T}^m \\ge b\\big) \\ge 1-\\varepsilon $$</p> <p>where \\(T\\) is the optimization horizon (decision variable).</p>"},{"location":"framework/#32-goal-set","title":"3.2 Goal Set","text":"<p>The goal set \\(\\mathcal{G}\\) is partitioned into:</p> \\[ \\mathcal{G} = \\mathcal{G}_{\\text{int}} \\cup \\mathcal{G}_{\\text{term}} \\] <p>where: - \\(\\mathcal{G}_{\\text{int}}\\): intermediate goals (constrain \\(T_{\\min}\\)) - \\(\\mathcal{G}_{\\text{term}}\\): terminal goals (determine \\(T^*\\))</p> <p>Properties:</p> <ol> <li> <p>Minimum horizon constraint:    $$    T \\geq T_{\\min} := \\max_{g \\in \\mathcal{G}_{\\text{int}}} t_g    $$</p> </li> <li> <p>Goal resolution: Month indices resolved via <code>start</code> date for calendar alignment</p> </li> <li> <p>Account mapping: Names \u2192 indices via <code>account_names</code> parameter</p> </li> </ol> <p>API: <pre><code>from datetime import date\n\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"Emergency\",\n                    threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\",\n                threshold=20_000_000, confidence=0.90)\n]\n\ngoal_set = GoalSet(goals, account_names=[\"Emergency\", \"Housing\"],\n                   start_date=date(2025, 1, 1))\n</code></pre></p>"},{"location":"framework/#33-horizon-estimation-heuristic","title":"3.3 Horizon Estimation Heuristic","text":"<p>For terminal-only goals (\\(\\mathcal{G}_{\\text{int}} = \\emptyset\\)), naive linear search starts at \\(T=1\\), wasting iterations. Instead, FinOpt uses a conservative heuristic:</p> \\[ T_{\\text{start}} = \\max_{g \\in \\mathcal{G}_{\\text{term}}} \\left\\lceil \\frac{b_g - W_0^m \\cdot (1 + \\mu)^{T_{\\min}}}{A_{\\text{avg}} \\cdot x_{\\min}^m \\cdot (1 + \\mu - \\sigma)} \\right\\rceil \\] <p>where: - \\(A_{\\text{avg}}\\): average monthly contribution (sampled) - \\(\\mu, \\sigma\\): expected return and volatility of account \\(m\\) - \\(x_{\\min}^m\\): minimum allocation fraction (conservative: 0.1) - Safety margin: multiply by 0.8 to start early</p> <p>Implementation: <code>GoalSet.estimate_minimum_horizon()</code></p>"},{"location":"framework/#4-optimization-framework","title":"4. Optimization Framework","text":""},{"location":"framework/#41-bilevel-problem","title":"4.1 Bilevel Problem","text":"<p>Find the minimum time \\(T^*\\) to achieve all goals while optimizing an objective \\(f(X)\\):</p> \\[ \\boxed{ \\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\max_{X \\in \\mathcal{F}_T} f(X) &gt; -\\infty } \\] <p>where the goal-feasible set at horizon \\(T\\) is:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\mathbb{P}\\big(W_t^m(X) \\ge b_t^m\\big) \\ge 1-\\varepsilon_t^m, \\; \\forall g \\in \\mathcal{G}_{\\text{int}}, \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\ge b^m\\big) \\ge 1-\\varepsilon^m, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\end{aligned} \\right\\} \\] <p>Equivalent decomposition:</p> <ul> <li>Outer problem: Find minimum horizon \\(T \\in [T_{\\text{start}}, T_{\\max}]\\) with non-empty feasible set</li> <li>Inner problem: For fixed \\(T\\), solve: $$ \\begin{aligned} \\max_{X \\in \\mathcal{X}_T} \\;\\; &amp; f(X) \\[0.5em] \\text{s.t.} \\;\\; &amp; X \\in \\mathcal{F}_T \\end{aligned} $$</li> </ul>"},{"location":"framework/#42-inner-problem-fixed-horizon","title":"4.2 Inner Problem (Fixed Horizon)","text":"<p>For given horizon \\(T\\), solve:</p> \\[ \\begin{aligned} \\max_{X \\in \\mathcal{X}_T} \\;\\; &amp; f(X) \\\\[0.5em] \\text{s.t.} \\;\\; &amp; \\mathbb{P}\\big(W_t^m(X) \\ge b_t^m\\big) \\ge 1-\\varepsilon_t^m, \\quad \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\ge b^m\\big) \\ge 1-\\varepsilon^m, \\quad \\forall g \\in \\mathcal{G}_{\\text{term}} \\end{aligned} \\] <p>Objective functions: - <code>\"terminal_wealth\"</code>: \\(f(X) = \\mathbb{E}\\big[\\sum_m W_T^m(X)\\big]\\) (default) - <code>\"low_turnover\"</code>: \\(f(X) = \\mathbb{E}[W_T] - \\lambda \\sum_{t,m} |x_{t+1,m} - x_t^m|\\) - <code>\"risk_adjusted\"</code>: \\(f(X) = \\mathbb{E}[W_T] - \\lambda \\cdot \\text{Std}(W_T)\\) - Custom: user-provided callable</p>"},{"location":"framework/#43-chance-constraint-reformulation","title":"4.3 Chance Constraint Reformulation","text":"<p>Challenge: Indicator function \\(\\mathbb{1}\\{W \\geq b\\}\\) is discontinuous.</p>"},{"location":"framework/#sample-average-approximation-saa","title":"Sample Average Approximation (SAA)","text":"<p>Discrete approximation with \\(N\\) scenarios \\(\\omega^{(i)}\\):</p> \\[ \\frac{1}{N}\\sum_{i=1}^N \\mathbb{1}\\{W_t^m(X; \\omega^{(i)}) \\ge b_t^m\\} \\ge 1-\\varepsilon_t^m \\] <p>Issue: Non-smooth, no gradient.</p>"},{"location":"framework/#sigmoid-smoothing-saaoptimizer","title":"Sigmoid Smoothing (SAAOptimizer)","text":"<p>Replace indicator with sigmoid \\(\\sigma(z) = 1/(1 + e^{-z})\\):</p> \\[ \\boxed{ \\frac{1}{N} \\sum_{i=1}^N \\sigma\\left(\\frac{W_t^m(X; \\omega^{(i)}) - b_t^m}{\\tau}\\right) \\ge 1-\\varepsilon_t^m } \\] <p>Properties: 1. Differentiability: \\(\\sigma'(z) = \\sigma(z)(1 - \\sigma(z))\\) \u2192 analytical gradient 2. Approximation quality: controlled by temperature \\(\\tau\\)    - Small \\(\\tau\\) (0.01): \\(\\sigma \\approx \\mathbb{1}\\) (sharp, harder to optimize)    - Large \\(\\tau\\) (1.0): \\(\\sigma \\approx 0.5\\) (smooth, loose approximation)    - Balanced \\(\\tau\\) (0.1): trade-off for practical optimization 3. Convexity: smoothed constraint is convex in \\(X\\) (via affine wealth)</p> <p>Gradient computation:</p> \\[ \\frac{\\partial}{\\partial x_s^m} \\left[\\frac{1}{N} \\sum_{i=1}^N \\sigma\\left(\\frac{W_t^m(X; \\omega^{(i)}) - b}{\\tau}\\right)\\right] = \\frac{1}{N\\tau} \\sum_{i=1}^N \\sigma'(z^{(i)}) \\cdot A_s^{(i)} \\cdot F_{s,t}^{m,(i)} \\] <p>where \\(z^{(i)} = (W_t^m(X; \\omega^{(i)}) - b)/\\tau\\).</p> <p>API: <pre><code>from finopt.src.optimization import SAAOptimizer\n\noptimizer = SAAOptimizer(\n    n_accounts=2,\n    tau=0.1,                      # Sigmoid temperature\n    objective=\"terminal_wealth\",\n    account_names=[\"Emergency\", \"Housing\"]\n)\n</code></pre></p>"},{"location":"framework/#cvar-reformulation-cvaroptimizer-stub","title":"CVaR Reformulation (CVaROptimizer - Stub)","text":"<p>Risk-adjusted objective via Conditional Value-at-Risk:</p> \\[ \\max \\; \\mathbb{E}[W_T] - \\lambda \\cdot \\text{CVaR}_{\\alpha}(-W_T) \\] <p>subject to goal constraints. Requires CVXPY for implementation.</p>"},{"location":"framework/#44-solution-strategy-goalseeker","title":"4.4 Solution Strategy (GoalSeeker)","text":"<p>Bilevel solver with linear search and warm start:</p> <pre><code>class GoalSeeker:\n    def seek(goals, A_generator, R_generator, W0, ...):\n        # Estimate intelligent starting horizon\n        T_start = estimate_horizon(goals, A_generator, W0)\n\n        X_prev = None  # Warm start\n        for T in range(T_start, T_max + 1):\n            # Generate scenarios for current horizon\n            A = A_generator(T, n_sims, seed)\n            R = R_generator(T, n_sims, seed+1)\n\n            # Solve inner problem\n            result = optimizer.solve(T, A, R, W0, goals, X_init=X_prev)\n\n            # Check feasibility (exact SAA validation)\n            if result.feasible:\n                return result  # Found T*\n\n            # Warm start: extend X for next iteration\n            X_prev = extend_policy(result.X)\n\n        raise ValueError(\"No feasible solution in [T_start, T_max]\")\n</code></pre> <p>Key features: 1. Intelligent start: Skips infeasible horizons via heuristic 2. Warm start: Extends previous \\(X\\) policy for faster convergence 3. Exact validation: Final feasibility check uses non-smoothed SAA</p> <p>API: <pre><code>from finopt.src.optimization import GoalSeeker\n\nseeker = GoalSeeker(optimizer, T_max=240, verbose=True)\nresult = seeker.seek(goals, A_generator, R_generator, W0, \n                    start_date=date(2025,1,1), n_sims=500, seed=42)\n</code></pre></p>"},{"location":"framework/#5-integration-financialmodel","title":"5. Integration: FinancialModel","text":""},{"location":"framework/#51-unified-facade","title":"5.1 Unified Facade","text":"<p><code>FinancialModel</code> orchestrates all components:</p> <pre><code>from finopt.src.model import FinancialModel\n\nmodel = FinancialModel(\n    income=income,              # IncomeModel\n    accounts=accounts,          # List[Account]\n    default_correlation=None,   # Return correlation matrix\n    enable_cache=True           # Simulation caching\n)\n</code></pre> <p>Attributes: - <code>model.income</code>: IncomeModel instance - <code>model.returns</code>: ReturnModel instance (auto-created) - <code>model.portfolio</code>: Portfolio instance (auto-created) - <code>model.M</code>: Number of accounts</p>"},{"location":"framework/#52-core-methods","title":"5.2 Core Methods","text":""},{"location":"framework/#simulation","title":"Simulation","text":"<pre><code>result = model.simulate(\n    T=24,\n    X=X,                        # (24, 2) allocation policy\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    use_cache=True\n)\n# Returns: SimulationResult with wealth, contributions, returns\n</code></pre> <p>Features: - Automatic seed propagation (income: seed, returns: seed+1) - SHA256 cache keying for instant re-runs - Affine wealth computation for optimization readiness</p>"},{"location":"framework/#optimization","title":"Optimization","text":"<pre><code>result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    verbose=True\n)\n# Returns: OptimizationResult with X*, T*, feasibility, diagnostics\n</code></pre> <p>Features: - Lazy import of optimization module (TYPE_CHECKING) - Duck typing validation of optimizer interface - Automatic generator construction for income/returns - Extracts <code>W0</code> from portfolio automatically</p>"},{"location":"framework/#validation","title":"Validation","text":"<pre><code>status = model.verify_goals(result, goals)\n# Returns: dict mapping each goal to violation metrics\n</code></pre> <p>Features: - Handles both <code>SimulationResult</code> and <code>OptimizationResult</code> - Auto-converts <code>OptimizationResult</code> \u2192 <code>SimulationResult</code> (500 fresh scenarios) - Computes empirical violation rates</p>"},{"location":"framework/#visualization","title":"Visualization","text":"<pre><code>model.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42, \n          start=date(2025,1,1))\n</code></pre> <p>Modes: - Pre-simulation: <code>\"income\"</code>, <code>\"contributions\"</code>, <code>\"returns\"</code> - Simulation-based: <code>\"wealth\"</code>, <code>\"comparison\"</code></p>"},{"location":"framework/#53-workflow-example","title":"5.3 Workflow Example","text":"<pre><code># 1. Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000, annual_growth=0.03),\n    variable=VariableIncome(base=200_000, sigma=0.10)\n)\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05),\n    Account.from_annual(\"Housing\", 0.07, 0.12)\n]\nmodel = FinancialModel(income, accounts)\n\n# 2. Define goals\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"Emergency\",\n                    threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\",\n                threshold=20_000_000, confidence=0.90)\n]\n\n# 3. Optimize\noptimizer = SAAOptimizer(n_accounts=2, tau=0.1)\nopt_result = model.optimize(goals, optimizer, T_max=120, seed=42)\n\nprint(f\"Optimal horizon: T*={opt_result.T} months\")\nprint(f\"Feasible: {opt_result.feasible}\")\n\n# 4. Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"{goal}: {metrics['satisfied']} \"\n          f\"(violation rate: {metrics['violation_rate']:.2%})\")\n\n# 5. Visualize\nmodel.plot(\"wealth\", result=sim_result, show_trajectories=True)\n</code></pre>"},{"location":"framework/#6-implementation-details","title":"6. Implementation Details","text":""},{"location":"framework/#61-calendar-alignment","title":"6.1 Calendar Alignment","text":"<p>All projections use <code>start: date</code> parameter: - Seasonality rotates via offset \\(= (\\text{start.month} - 1)\\) - Salary raises applied at specific dates relative to start - Contribution fractions rotate cyclically to match fiscal year - Temporal index: <code>month_index(start, T)</code> \u2192 DatetimeIndex</p>"},{"location":"framework/#62-seed-management","title":"6.2 Seed Management","text":"<p>Reproducibility architecture: <pre><code>User seed\n    \u251c\u2500\u2192 Income: seed\n    \u2514\u2500\u2192 Returns: seed + 1\n</code></pre></p> <p>Rationale: Statistical independence between income and return shocks.</p> <p>Implementation: <pre><code>A = income.contributions(months=T, seed=seed)\nR = returns.generate(T, seed=None if seed is None else seed + 1)\n</code></pre></p>"},{"location":"framework/#63-memory-management","title":"6.3 Memory Management","text":"<p>Accumulation factors: \\(F \\in \\mathbb{R}^{N \\times (T+1) \\times (T+1) \\times M}\\)</p> <p>Memory usage: \\(N \\cdot T^2 \\cdot M \\cdot 8\\) bytes</p> <p>Estimates: - \\(N=500, T=24, M=2\\): ~115 MB - \\(N=500, T=120, M=5\\): ~14 GB \u26a0\ufe0f - \\(N=1000, T=240, M=10\\): ~221 GB (infeasible)</p> <p>Mitigation strategies: - Use <code>method=\"recursive\"</code> for large \\(T\\) (no \\(F\\) precomputation) - Process simulations in batches (chunk \\(N\\)) - Compute gradients on-the-fly (store only needed \\(F_{s,t}\\) pairs) - Use sparse storage for intermediate-goal-only problems</p>"},{"location":"framework/#64-output-formats","title":"6.4 Output Formats","text":"<p>All methods support flexible output: - <code>output=\"array\"</code>: NumPy arrays (computational efficiency) - <code>output=\"series\"</code>: Pandas Series with calendar index (reporting) - <code>output=\"dataframe\"</code>: Component breakdown (analysis)</p>"},{"location":"framework/#65-type-safety","title":"6.5 Type Safety","text":"<p>Lazy imports for optimization: <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .optimization import AllocationOptimizer, OptimizationResult\n</code></pre></p> <p>Runtime validation: <pre><code># Duck typing (no import needed at runtime)\nif not hasattr(optimizer, 'solve') or not callable(optimizer.solve):\n    raise TypeError(\"optimizer must implement .solve() method\")\n</code></pre></p>"},{"location":"framework/#7-key-mathematical-results","title":"7. Key Mathematical Results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\) and return realization \\(\\{R_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m $$ is affine in \\(X\\).</p> <p>Corollary 1 (Convex Feasible Set): For deterministic constraints \\(W_t^m(X) \\ge b_t^m\\), the feasible allocation set is a convex polytope.</p> <p>Proposition 2 (Analytical Gradient): The sensitivity of wealth to allocation at month \\(s\\) is: $$ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t $$</p> <p>Corollary 2 (Monotonicity): If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m(X)\\) is strictly increasing in \\(x_s^m\\).</p> <p>Proposition 3 (Sigmoid Approximation Error): For temperature \\(\\tau &gt; 0\\): $$ \\left|\\sigma\\left(\\frac{z}{\\tau}\\right) - \\mathbb{1}{z \\geq 0}\\right| \\le \\frac{1}{2} $$ with error decaying exponentially in \\(|z|/\\tau\\).</p> <p>Proposition 4 (SAA Consistency): Under mild regularity conditions, as \\(N \\to \\infty\\): $$ \\frac{1}{N}\\sum_{i=1}^N \\mathbb{1}{W_t^m(X; \\omega^{(i)}) \\ge b} \\xrightarrow{a.s.} \\mathbb{P}(W_t^m(X) \\ge b) $$</p>"},{"location":"framework/#8-usage-examples","title":"8. Usage Examples","text":""},{"location":"framework/#81-basic-simulation","title":"8.1 Basic Simulation","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\nimport numpy as np\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000, annual_growth=0.03),\n    variable=VariableIncome(base=200_000, sigma=0.10, seed=42)\n)\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05),\n    Account.from_annual(\"Housing\", 0.07, 0.12)\n]\nmodel = FinancialModel(income, accounts)\n\n# Simulate with 60-40 allocation\nX = np.tile([0.6, 0.4], (24, 1))\nresult = model.simulate(T=24, X=X, n_sims=500, seed=42,\n                       start=date(2025, 1, 1))\n\n# Analyze\nprint(result.summary(confidence=0.95))\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"Mean Sharpe: {metrics['sharpe'].mean():.3f}\")\n</code></pre>"},{"location":"framework/#82-goal-driven-optimization","title":"8.2 Goal-Driven Optimization","text":"<pre><code>from finopt.src.optimization import SAAOptimizer\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\n\n# Define goals\ngoals = [\n    IntermediateGoal(\n        month=12, \n        account=\"Emergency\",\n        threshold=5_500_000,\n        confidence=0.90\n    ),\n    TerminalGoal(\n        account=\"Housing\",\n        threshold=20_000_000,\n        confidence=0.90\n    )\n]\n\n# Create optimizer\noptimizer = SAAOptimizer(\n    n_accounts=model.M,\n    tau=0.1,\n    objective=\"terminal_wealth\"\n)\n\n# Optimize\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    verbose=True\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(f\"Feasible: {result.feasible}\")\nprint(result.summary())\n</code></pre>"},{"location":"framework/#83-multi-goal-validation","title":"8.3 Multi-Goal Validation","text":"<pre><code># Simulate with optimal policy (fresh scenarios)\nsim_result = model.simulate_from_optimization(\n    result, \n    n_sims=1000, \n    seed=999\n)\n\n# Verify goal satisfaction\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"\\nGoal: {goal}\")\n    print(f\"  Satisfied: {metrics['satisfied']}\")\n    print(f\"  Violation rate: {metrics['violation_rate']:.2%}\")\n    print(f\"  Required rate: {metrics['required_rate']:.2%}\")\n    print(f\"  Margin: {metrics['margin']:.4f}\")\n    if not metrics['satisfied']:\n        print(f\"  Median shortfall: ${metrics['median_shortfall']:,.0f}\")\n</code></pre>"},{"location":"framework/#84-strategy-comparison","title":"8.4 Strategy Comparison","text":"<pre><code># Define multiple strategies\nX_conservative = np.tile([0.9, 0.1], (24, 1))  # 90% emergency\nX_balanced = np.tile([0.6, 0.4], (24, 1))      # 60-40\nX_aggressive = np.tile([0.3, 0.7], (24, 1))    # 30% emergency\n\n# Simulate each\nr1 = model.simulate(T=24, X=X_conservative, n_sims=500, seed=42)\nr2 = model.simulate(T=24, X=X_balanced, n_sims=500, seed=42)\nr3 = model.simulate(T=24, X=X_aggressive, n_sims=500, seed=42)\n\n# Compare\nmodel.plot(\"comparison\", results={\n    \"Conservative\": r1,\n    \"Balanced\": r2,\n    \"Aggressive\": r3\n})\n</code></pre>"},{"location":"framework/#9-extensions-and-future-work","title":"9. Extensions and Future Work","text":""},{"location":"framework/#91-implemented-features","title":"9.1 Implemented Features","text":"<p>\u2705 Multi-account portfolios with correlated returns \u2705 Intermediate and terminal goals with chance constraints \u2705 Sigmoid-smoothed SAA for gradient-based optimization \u2705 Intelligent horizon estimation for terminal-only goals \u2705 Warm start for faster bilevel convergence \u2705 Affine wealth for analytical gradients \u2705 Calendar alignment for seasonality and raises \u2705 Seed propagation for reproducibility  </p>"},{"location":"framework/#92-potential-extensions","title":"9.2 Potential Extensions","text":"<p>Optimization: - \ud83d\udd04 CVaR implementation (CVXPY-based, convex formulation) - \ud83d\udd04 Robust optimization (worst-case performance over scenarios) - \ud83d\udd04 Multi-period rebalancing (time-varying \\(x_t^m\\) with turnover penalty) - \ud83d\udd04 Dynamic programming (Bellman recursion for complex constraints)</p> <p>Portfolio features: - \ud83d\udd04 Transaction costs (\\(\\kappa \\|\\Delta x_t\\|_1\\) friction terms) - \ud83d\udd04 Tax-aware optimization (capital gains, withdrawal timing) - \ud83d\udd04 Minimum balance constraints (\\(W_t^m \\geq W_{\\min}^m\\)) - \ud83d\udd04 Leverage constraints (short-selling, margin limits)</p> <p>Income modeling: - \ud83d\udd04 Multi-source income (multiple jobs, rental, dividends) - \ud83d\udd04 Income shocks (unemployment, health events) - \ud83d\udd04 Non-Gaussian noise (fat tails, asymmetry)</p> <p>Risk management: - \ud83d\udd04 Downside protection (VaR/CVaR constraints) - \ud83d\udd04 Path-dependent goals (average wealth, peak wealth) - \ud83d\udd04 Correlation uncertainty (robust correlation estimation)</p> <p>Performance: - \ud83d\udd04 GPU acceleration (CuPy for large-scale Monte Carlo) - \ud83d\udd04 Sparse factorization (memory-efficient \\(F\\) storage) - \ud83d\udd04 Parallel simulation (multi-process scenario generation)</p>"},{"location":"framework/#10-references-and-resources","title":"10. References and Resources","text":""},{"location":"framework/#mathematical-foundations","title":"Mathematical Foundations","text":"<ul> <li>Rockafellar &amp; Uryasev (2000), \"Optimization of conditional value-at-risk\"</li> <li>Luedtke &amp; Ahmed (2008), \"A sample approximation approach for optimization with probabilistic constraints\"</li> <li>Nemirovski &amp; Shapiro (2006), \"Convex approximations of chance constrained programs\"</li> </ul>"},{"location":"framework/#implementation","title":"Implementation","text":"<ul> <li>GitHub: <code>github.com/maxliionel/finopt</code></li> <li>Documentation: Full API docs in module docstrings</li> <li>Tests: Comprehensive unit and integration tests</li> </ul>"},{"location":"framework/#related-tools","title":"Related Tools","text":"<ul> <li>CVXPY: Convex optimization modeling language</li> <li>Scipy: Scientific computing (optimize.minimize with SLSQP)</li> <li>NumPy/Pandas: Numerical computing and data analysis</li> </ul> <p>End of Framework Document</p>"},{"location":"framework/#appendix-quick-reference","title":"Appendix: Quick Reference","text":""},{"location":"framework/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>IncomeModel\n    \u251c\u2500 FixedIncome\n    \u2514\u2500 VariableIncome\n\nPortfolio\n    \u2514\u2500 Account\n\nReturnModel (uses Account metadata)\n\nFinancialModel (facade)\n    \u251c\u2500 income: IncomeModel\n    \u251c\u2500 portfolio: Portfolio\n    \u2514\u2500 returns: ReturnModel\n\nAllocationOptimizer (abstract)\n    \u251c\u2500 SAAOptimizer (sigmoid-smoothed)\n    \u2514\u2500 CVaROptimizer (stub)\n\nGoalSeeker (bilevel solver)\n    \u2514\u2500 optimizer: AllocationOptimizer\n</code></pre>"},{"location":"framework/#key-type-signatures","title":"Key Type Signatures","text":"<pre><code># Simulation\nSimulationResult = model.simulate(\n    T: int,\n    X: np.ndarray,  # (T, M)\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date]\n) -&gt; SimulationResult\n\n# Optimization\nOptimizationResult = model.optimize(\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    optimizer: AllocationOptimizer,\n    T_max: int,\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date]\n) -&gt; OptimizationResult\n\n# Validation\nDict[Goal, Dict[str, float]] = model.verify_goals(\n    result: Union[SimulationResult, OptimizationResult],\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    start: Optional[date]\n)\n</code></pre>"},{"location":"framework/#common-patterns","title":"Common Patterns","text":"<pre><code># Pattern 1: Simulation-only workflow\nmodel = FinancialModel(income, accounts)\nX = define_allocation_policy(T, M)\nresult = model.simulate(T, X, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result)\n\n# Pattern 2: Optimization workflow\ngoals = define_goals()\noptimizer = SAAOptimizer(n_accounts=M, tau=0.1)\nopt_result = model.optimize(goals, optimizer, T_max=120, seed=42)\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000)\nstatus = model.verify_goals(sim_result, goals)\n\n# Pattern 3: Comparison workflow\nresults = {name: model.simulate(T, X_i, ...) for name, X_i in strategies.items()}\nmodel.plot(\"comparison\", results=results)\n</code></pre>"},{"location":"goals/","title":"<code>goals</code> \u2014 Probabilistic Goal Specification for FinOpt","text":"<p>Core idea: translate financial goals into chance constraints that can be validated against Monte Carlo simulations and reformulated for convex optimization. <code>goals.py</code> connects what the user wants to achieve (e.g., \"$20M in account X with 90% confidence\") with the CVaR-based optimization framework that finds the minimum horizon and optimal allocation policy to satisfy these goals.</p>"},{"location":"goals/#why-a-dedicated-goals-module","title":"Why a dedicated goals module?","text":"<ul> <li>Probabilistic semantics: Goals are chance constraints \u2119(W_t^m \u2265 b) \u2265 1-\u03b5, not deterministic targets</li> <li>Two temporal flavors: Intermediate goals (fixed calendar date) vs. terminal goals (variable horizon T)</li> <li>Optimization-ready: Provides <code>GoalSet</code> abstraction consumed by <code>CVaROptimizer</code> and <code>GoalSeeker</code></li> <li>Validation utilities: Post-simulation functions to check goal satisfaction with detailed metrics</li> </ul>"},{"location":"goals/#design-philosophy","title":"Design philosophy","text":"<ol> <li>Immutable specifications</li> <li>Goals are <code>frozen</code> dataclasses \u2014 safe to hash, cache, and use as dict keys</li> <li> <p>No mutation after construction</p> </li> <li> <p>Dual temporal semantics</p> </li> <li><code>IntermediateGoal</code>: Fixed calendar checkpoint (independent of optimization horizon)</li> <li> <p><code>TerminalGoal</code>: Evaluated at variable T (the horizon being optimized)</p> </li> <li> <p>Account resolution</p> </li> <li>Goals reference accounts by name (<code>str</code>) or index (<code>int</code>)</li> <li> <p><code>GoalSet</code> validates and resolves references at construction time</p> </li> <li> <p>Calendar-aware month resolution</p> </li> <li>Dates converted to month offsets via <code>resolve_month(start_date)</code></li> <li>Results cached for O(1) lookup during optimization</li> </ol>"},{"location":"goals/#key-concepts","title":"Key concepts","text":""},{"location":"goals/#chance-constraints","title":"Chance constraints","text":"<p>Goals are formulated as probabilistic requirements:</p> <p>IntermediateGoal (fixed time t_fixed): <pre><code>\u2119(W_{t_fixed}^m \u2265 threshold) \u2265 confidence\n</code></pre></p> <p>TerminalGoal (variable horizon T): <pre><code>\u2119(W_T^m \u2265 threshold) \u2265 confidence\n</code></pre></p> <p>Where: - <code>W_t^m</code> = wealth in account m at time t - <code>threshold</code> = minimum required wealth (e.g., $5,500,000 CLP) - <code>confidence</code> = 1 - \u03b5 (e.g., 0.90 means 90% chance of success) - <code>\u03b5</code> = violation tolerance (e.g., 0.10 allows 10% failure rate)</p>"},{"location":"goals/#cvar-reformulation","title":"CVaR reformulation","text":"<p>The optimization module transforms these non-convex chance constraints into tractable convex form:</p> <pre><code>Original (non-convex):  \u2119(W_t \u2265 b) \u2265 1-\u03b5\nCVaR form (convex):     CVaR_\u03b5(b - W_t) \u2264 0\n</code></pre> <p>This enables globally optimal allocation policies via convex programming.</p>"},{"location":"goals/#main-api","title":"Main API","text":""},{"location":"goals/#1-intermediategoal-dataclass","title":"1) <code>IntermediateGoal</code> (dataclass)","text":"<p>Fixed-time financial checkpoint. Used for liquidity requirements, planned expenses, or milestone tracking.</p> <pre><code>from datetime import date\nfrom finopt.src.goals import IntermediateGoal\n\ngoal = IntermediateGoal(\n    date=date(2025, 7, 1),       # Target date (required)\n    account=\"Emergency\",          # Account name or index\n    threshold=5_500_000,          # Minimum wealth required\n    confidence=0.90               # 90% chance of success\n)\n\n# Month resolution (relative to simulation start)\nmonth = goal.resolve_month(date(2025, 1, 1))  # \u2192 6\n\n# Violation tolerance\nepsilon = goal.epsilon  # \u2192 0.10\n</code></pre> <p>Parameters: - <code>date</code>: Target date for evaluation (converted to month offset) - <code>account</code>: Account identifier (int index or str name) - <code>threshold</code>: Minimum required wealth (must be &gt; 0) - <code>confidence</code>: Required probability of success \u2208 (0, 1)</p> <p>Month resolution semantics: - <code>date=July 1, 2025</code> with <code>start_date=January 1, 2025</code> \u2192 month 6 - Checks wealth W_6 (wealth at start of period 6, i.e., July 1)</p>"},{"location":"goals/#2-terminalgoal-dataclass","title":"2) <code>TerminalGoal</code> (dataclass)","text":"<p>End-of-horizon target evaluated at variable T. Used for retirement targets, long-term savings, or final portfolio value.</p> <pre><code>from finopt.src.goals import TerminalGoal\n\ngoal = TerminalGoal(\n    account=\"Retirement\",         # Account name or index\n    threshold=20_000_000,         # Terminal wealth target\n    confidence=0.90               # 90% chance of success\n)\n</code></pre> <p>Parameters: - <code>account</code>: Account identifier (int index or str name) - <code>threshold</code>: Minimum required terminal wealth (must be &gt; 0) - <code>confidence</code>: Required probability of success \u2208 (0, 1)</p> <p>Key difference from IntermediateGoal: - No fixed <code>date</code> \u2014 evaluated at horizon T (the optimization variable) - Used by <code>GoalSeeker</code> to find minimum T* such that goal is feasible</p>"},{"location":"goals/#3-goalset-class","title":"3) <code>GoalSet</code> (class)","text":"<p>Validated collection of goals with account resolution and utilities for optimization.</p> <pre><code>from datetime import date\nfrom finopt.src.portfolio import Account\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal, GoalSet\n\n# Define accounts\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Housing\", annual_return=0.07, annual_volatility=0.12)\n]\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Emergency\", threshold=20_000_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=7_000_000, confidence=0.90)\n]\n\n# Create validated collection\ngoal_set = GoalSet(goals, accounts, start_date=date(2025, 1, 1))\n\n# Access properties\ngoal_set.T_min                    # \u2192 6 (from intermediate goal)\ngoal_set.M                        # \u2192 2 (number of accounts)\ngoal_set.intermediate_goals       # \u2192 [IntermediateGoal(...)]\ngoal_set.terminal_goals           # \u2192 [TerminalGoal(...), TerminalGoal(...)]\n\n# Resolve account index for a goal\nidx = goal_set.get_account_index(goals[0])  # \u2192 0\n\n# Get cached resolved month (O(1))\nmonth = goal_set.get_resolved_month(goals[0])  # \u2192 6\n</code></pre> <p>Validation rules: - Goals list cannot be empty - All account references must resolve to valid indices - No duplicate IntermediateGoal for same (month, account) pair - No duplicate TerminalGoal for same account</p> <p>Key methods: - <code>get_account_index(goal)</code>: Returns resolved 0-based account index - <code>get_resolved_month(goal)</code>: Returns cached month offset for IntermediateGoal - <code>estimate_minimum_horizon(...)</code>: Heuristic T estimate for terminal goals</p>"},{"location":"goals/#4-goal-validation-functions","title":"4) Goal validation functions","text":""},{"location":"goals/#check_goals-validate-goal-satisfaction","title":"<code>check_goals()</code> \u2014 Validate goal satisfaction","text":"<pre><code>from finopt.src.goals import check_goals\n\nstatus = check_goals(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n\nfor goal, metrics in status.items():\n    print(f\"{goal}: {'\u2713' if metrics['satisfied'] else '\u2717'}\")\n    print(f\"  Violation rate: {metrics['violation_rate']:.1%}\")\n    print(f\"  Required rate:  {metrics['required_rate']:.1%}\")\n    print(f\"  Margin:         {metrics['margin']:+.1%}\")\n</code></pre> <p>Returns dict with metrics for each goal: - <code>satisfied</code>: bool \u2014 True if empirical violation rate \u2264 \u03b5 - <code>violation_rate</code>: float \u2014 Empirical \u2119(W_t^m &lt; threshold) - <code>required_rate</code>: float \u2014 Goal's \u03b5 = 1 - confidence - <code>margin</code>: float \u2014 required_rate - violation_rate (positive = satisfied) - <code>median_shortfall</code>: float \u2014 Median shortfall over violated scenarios - <code>n_violations</code>: int \u2014 Count of scenarios violating threshold</p>"},{"location":"goals/#goal_progress-track-progress-toward-goals","title":"<code>goal_progress()</code> \u2014 Track progress toward goals","text":"<pre><code>from finopt.src.goals import goal_progress\n\nprogress = goal_progress(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n\nfor goal, pct in progress.items():\n    account = goal.account\n    print(f\"{account}: {pct:.1%} progress\")\n</code></pre> <p>Progress metric: <code>min(1, VaR_{1-\u03b5}(W_t^m) / threshold)</code></p> <ul> <li>0.0: VaR is zero (far from goal)</li> <li>0.5: VaR is 50% of threshold (halfway)</li> <li>1.0: VaR \u2265 threshold (goal achieved at confidence level)</li> </ul>"},{"location":"goals/#print_goal_status-pretty-print-goal-satisfaction","title":"<code>print_goal_status()</code> \u2014 Pretty-print goal satisfaction","text":"<pre><code>from finopt.src.goals import print_goal_status\n\nprint_goal_status(\n    result=simulation_result,\n    goals=goals,\n    accounts=accounts,\n    start_date=date(2025, 1, 1)\n)\n</code></pre> <p>Example output: <pre><code>=== Goal Status ===\n\n[\u2713] IntermediateGoal: Emergency Fund @ month 6\n    Target: $5,500,000 | Confidence: 90.0%\n    Status: SATISFIED (margin: +2.3%)\n    Violation rate: 7.7% (38 scenarios)\n\n[\u2717] TerminalGoal: Emergency Fund @ T=24\n    Target: $20,000,000 | Confidence: 90.0%\n    Status: VIOLATED (margin: -3.1%)\n    Violation rate: 13.1% (66 scenarios)\n    Median shortfall: $1,234,567\n</code></pre></p>"},{"location":"goals/#month-resolution-semantics","title":"Month resolution semantics","text":"<p>Goals and the wealth array use start-of-period indexing:</p> Date <code>resolve_month()</code> Wealth Index Interpretation January 1, 2025 (start) \u2014 W_0 Initial wealth February 1, 2025 1 W_1 Wealth at start of month 1 July 1, 2025 6 W_6 Wealth at start of month 6 January 1, 2026 (T=12) 12 W_12 Terminal wealth <p>Example with start_date = January 1, 2025: <pre><code>goal = IntermediateGoal(date=date(2025, 7, 1), ...)\nmonth = goal.resolve_month(date(2025, 1, 1))  # \u2192 6\n# Checks wealth[i, 6, m] which is W_6 (wealth at July 1)\n</code></pre></p>"},{"location":"goals/#integration-with-optimization","title":"Integration with optimization","text":""},{"location":"goals/#optimization-workflow","title":"Optimization workflow","text":"<pre><code>from finopt import FinancialModel\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.optimization import CVaROptimizer\n\n# 1. Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Retirement\", threshold=20_000_000, confidence=0.90)\n]\n\n# 2. Create optimizer\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\n\n# 3. Optimize (finds minimum T* and optimal X*)\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42\n)\n\n# 4. Validate goals\nresult.validate_goals()  # Uses stored goal_set\n</code></pre>"},{"location":"goals/#how-goals-flow-through-the-system","title":"How goals flow through the system","text":"<ol> <li>User defines goals \u2192 <code>IntermediateGoal</code> / <code>TerminalGoal</code> objects</li> <li><code>GoalSet</code> validates \u2192 Resolves accounts, caches months, computes T_min</li> <li><code>CVaROptimizer</code> reformulates \u2192 Chance constraints \u2192 CVaR \u2264 0</li> <li><code>GoalSeeker</code> searches \u2192 Binary search over T with warm-start</li> <li><code>check_goals</code> validates \u2192 Post-simulation verification</li> </ol>"},{"location":"goals/#complete-example","title":"Complete example","text":"<pre><code>from datetime import date\nfrom finopt import FinancialModel, Account, IncomeModel, FixedIncome\nfrom finopt.src.goals import (\n    IntermediateGoal, TerminalGoal, GoalSet,\n    check_goals, goal_progress, print_goal_status\n)\nfrom finopt.optimization import CVaROptimizer\n\n# Setup\nincome = IncomeModel(fixed=FixedIncome(base=1_500_000, annual_growth=0.03))\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Growth\", annual_return=0.12, annual_volatility=0.15)\n]\nmodel = FinancialModel(income, accounts)\n\n# Define goals\nstart_date = date(2025, 1, 1)\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"Growth\", threshold=50_000_000, confidence=0.80)\n]\n\n# Validate goal structure\ngoal_set = GoalSet(goals, accounts, start_date)\nprint(f\"Minimum horizon from intermediate goals: T_min = {goal_set.T_min}\")\n\n# Optimize\noptimizer = CVaROptimizer(n_accounts=2, objective=\"balanced\")\nresult = model.optimize(goals=goals, optimizer=optimizer, T_max=120, n_sims=500)\n\n# Check results\nprint_goal_status(result, goals, accounts, start_date)\n\n# Get detailed metrics\nstatus = check_goals(result, goals, accounts, start_date)\nprogress = goal_progress(result, goals, accounts, start_date)\n</code></pre>"},{"location":"goals/#comparison-with-legacy-api","title":"Comparison with legacy API","text":"Legacy (removed) Current <code>Goal</code> dataclass <code>IntermediateGoal</code>, <code>TerminalGoal</code> <code>target_amount</code> <code>threshold</code> <code>target_date</code> / <code>target_month_index</code> <code>date</code> (IntermediateGoal only) <code>evaluate_goal()</code> <code>check_goals()</code> <code>evaluate_goals()</code> \u2192 DataFrame <code>check_goals()</code> \u2192 Dict <code>GoalEvaluation</code> Dict with metrics <code>allocate_contributions_proportional()</code> Removed (use optimization) <code>required_constant_contribution()</code> <code>GoalSet.estimate_minimum_horizon()</code> Deterministic success/failure Probabilistic chance constraints"},{"location":"income/","title":"<code>income</code> \u2013 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Model where the money comes from (and how it evolves) so the rest of FinOpt can decide how to allocate and invest it. In FinOpt's pipeline, <code>income.py</code> is the entry point of cash flows: it turns assumptions about salary and variable earnings into a clean, reproducible monthly series that downstream modules consume for contributions and simulations.</p>"},{"location":"income/#why-a-dedicated-income-module","title":"Why a dedicated income module?","text":"<p>Financial planning hinges on cash availability per period. Any optimizer or simulator that ignores timing or volatility of income will produce plans that are hard to execute. <code>income.py</code> separates cash generation (what you earn) from capital dynamics (what you invest), giving you:</p> <ul> <li>Clarity: Incomes are modeled explicitly (fixed vs. variable).  </li> <li>Composability: Outputs plug directly into <code>simulation.py</code> and <code>investment.py</code>.  </li> <li>Reproducibility: Deterministic by default; any randomness is controlled by an explicit seed.  </li> <li>Extensibility: Easy to add expenses, taxes, or more streams without touching portfolio code.</li> </ul>"},{"location":"income/#design-principles","title":"Design principles","text":"<ol> <li>Deterministic baseline, controlled randomness</li> <li>Everything is deterministic unless you explicitly add noise to <code>VariableIncome</code> via <code>sigma</code> and <code>seed</code>.</li> <li>Calendar-first outputs</li> <li>Returns pandas Series/DataFrames indexed by the first day of each month (friendly for reporting and plotting).</li> <li>Minimal but expressive</li> <li>Two stream types cover common cases:<ul> <li><code>FixedIncome</code>: predictable salary with optional annual growth and scheduled raises.</li> <li><code>VariableIncome</code>: irregular stream with seasonality and Gaussian noise.</li> </ul> </li> <li>Single responsibility</li> <li><code>income.py</code> does not simulate returns or portfolios. It only projects income and derives contribution series from it.</li> </ol>"},{"location":"income/#the-three-core-surfaces","title":"The three core surfaces","text":""},{"location":"income/#1-fixedincome","title":"1) <code>FixedIncome</code>","text":"<p>A deterministic monthly base with compounded annual growth and optional salary raises:</p> <p>Parameters: - <code>base</code>: monthly base income at t=0 - <code>annual_growth</code>: nominal annual rate (converted internally to monthly compounding) - <code>salary_raises</code>: <code>Optional[Dict[date, float]]</code> \u2013 absolute raise amounts at specific dates - <code>name</code>: identifier for labeling outputs</p> <p>Method signature: <pre><code>def project(\n    self, \n    months: int, \n    *, \n    start: Optional[date] = None,\n    output: Literal[\"array\", \"series\"] = \"array\"\n) -&gt; np.ndarray | pd.Series\n</code></pre> - <code>start</code>: required when <code>salary_raises</code> is specified; used for calendar alignment - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</p> <p>Key behaviors: - Monthly projection uses the equivalent monthly rate: <code>m = (1 + annual_growth)^(1/12) - 1</code> - Salary raises are applied permanently from the month containing the specified date - Growth compounds on the updated base after each raise - Requires <code>start</code> date in <code>.project()</code> when <code>salary_raises</code> is specified - Guarantees non-negativity and well-formed arrays</p> <p>Interpretation: models a salary with contractual raises and inflation adjustments; simple and transparent.</p>"},{"location":"income/#2-variableincome","title":"2) <code>VariableIncome</code>","text":"<p>A variable stream with optional seasonality, noise, floor/cap, and annual growth:</p> <p>Parameters: - <code>base</code>: baseline monthly income before transformations - <code>seasonality</code>: 12 multiplicative factors (Jan\u2013Dec), must have length 12 - <code>sigma</code>: standard deviation of noise as a fraction of the month mean - <code>floor</code> / <code>cap</code>: guardrails applied after noise (e.g., minimum expected side income) - <code>annual_growth</code>: nominal annual rate applied before seasonality - <code>seed</code>: RNG seed for reproducible noise (can be overridden in <code>.project()</code>) - <code>name</code>: identifier for labeling outputs</p> <p>Method signature: <pre><code>def project(\n    self, \n    months: int, \n    *, \n    start: Optional[date | int] = None, \n    seed: Optional[int] = None,\n    output: Literal[\"array\", \"series\"] = \"array\"\n) -&gt; np.ndarray | pd.Series\n</code></pre> - <code>start</code>: can be <code>date</code> or <code>int</code> (month 1-12); determines seasonality rotation - <code>seed</code> in <code>project()</code> overrides instance-level seed if provided - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</p> <p>Interpretation: models tutoring, bonuses, or freelancing income whose level changes across the year and fluctuates each month.</p>"},{"location":"income/#3-incomemodel","title":"3) <code>IncomeModel</code>","text":"<p>A fa\u00e7ade that combines streams and produces projections, contributions, metrics, and visualizations.</p>"},{"location":"income/#core-projection-methods","title":"Core projection methods","text":"<p><code>project(months, start=None, output=\"series\", seed=None)</code> - Returns total income (optionally as DataFrame with [fixed, variable, total] columns) - Aligned to calendar via <code>start</code> date - <code>output</code>: <code>\"series\"</code> returns total as Series, <code>\"dataframe\"</code> returns breakdown with components - <code>seed</code>: controls reproducibility of variable income (overrides instance seed) - Example:   <pre><code># Total income as Series (default)\ntotal = income.project(months=24, start=date(2025, 9, 1))\n\n# Breakdown as DataFrame\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n</code></pre></p> <p><code>contributions(months, start=None, seed=None, output=\"series\")</code> - Computes monthly contributions using 12-month fractional arrays that rotate based on <code>start</code>:   $$   \\text{contrib}t = \\alpha^{\\text{fixed}}{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{fixed}}t + \\alpha^{\\text{variable}}{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{variable}}_t   $$   where <code>offset = normalize_start_month(start)</code>.</p> <ul> <li><code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</li> <li> <p><code>seed</code>: controls reproducibility of variable income (overrides instance seed)</p> </li> <li> <p>Default fractions (if <code>monthly_contribution</code> is <code>None</code>):</p> </li> <li>Fixed: 30% each month</li> <li> <p>Variable: 100% each month</p> </li> <li> <p>Custom fractions via attribute:   <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # Jan-Dec fractions\n    \"variable\": [1.0]*12\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> </li> <li> <p>Contributions are floored at zero (no negative values)</p> </li> <li>The 12-month arrays repeat cyclically for horizons &gt; 12 months</li> </ul>"},{"location":"income/#statistical-methods","title":"Statistical methods","text":"<p><code>income_metrics(months, start=None, variable_threshold=None)</code> - Returns <code>IncomeMetrics</code> dataclass with:   <pre><code>@dataclass\nclass IncomeMetrics:\n    months: int\n    total_fixed, total_variable, total_income: float\n    mean_fixed, mean_variable, mean_total: float\n    std_variable, coefvar_variable: float\n    fixed_share, variable_share: float\n    min_variable, max_variable: float\n    pct_variable_below_threshold: float  # NaN if threshold not provided\n</code></pre></p> <p><code>summary(months, start=None, variable_threshold=None, round_digits=2)</code> - Convenience wrapper that returns <code>income_metrics()</code> as a rounded pandas Series</p>"},{"location":"income/#visualization-methods","title":"Visualization methods","text":"<p><code>plot_income(months, start=None, ...)</code> - Plots fixed, variable, and total income streams - Dual-axis support: automatic when scales differ by <code>dual_axis_ratio</code> (default 3.0) - Monte Carlo trajectories: shows individual stochastic paths when <code>show_trajectories=True</code> and <code>sigma &gt; 0</code> - Confidence bands: statistical intervals when <code>show_confidence_band=True</code> and <code>sigma &gt; 0</code> - Key parameters:   - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code>   - <code>ylabel_left</code>, <code>ylabel_right</code>: axis labels   - <code>dual_axis</code>: <code>\"auto\"</code> | <code>True</code> | <code>False</code>   - <code>show_trajectories=True</code>, <code>trajectory_alpha=0.08</code>   - <code>show_confidence_band=False</code>, <code>confidence=0.9</code>, <code>n_simulations=500</code>   - <code>colors</code>: <code>{\"fixed\": \"blue\", \"variable\": \"orange\", \"total\": \"black\"}</code>   - <code>save_path</code>, <code>return_fig_ax</code> - Displays cumulative totals annotation</p> <p><code>plot_contributions(months, start=None, ...)</code> - Plots total monthly contributions with optional Monte Carlo trajectories and confidence bands - Single y-axis (no dual-axis) - Key parameters:   - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code>, <code>ylabel</code>   - <code>show_trajectories=True</code>, <code>trajectory_alpha=0.08</code>   - <code>show_confidence_band=False</code>, <code>confidence=0.9</code>, <code>n_simulations=500</code>   - <code>colors</code>: <code>{\"total\": \"blue\", \"ci\": \"orange\"}</code>   - <code>save_path</code>, <code>return_fig_ax</code> - Displays total contributions annotation</p> <p><code>plot(mode=\"income\"|\"contributions\", ...)</code> - Unified wrapper that dispatches to <code>plot_income()</code> or <code>plot_contributions()</code> - All parameters are forwarded to the appropriate method</p>"},{"location":"income/#serialization","title":"Serialization","text":"<p><code>to_dict()</code> / <code>from_dict(payload)</code> - Serialize/deserialize model configuration for persistence - Handles <code>salary_raises</code> date conversion (ISO format strings)</p>"},{"location":"income/#how-incomepy-powers-the-rest-of-finopt","title":"How <code>income.py</code> powers the rest of FinOpt","text":"<ul> <li> <p><code>simulation.py</code>   Uses <code>IncomeModel.contributions(...)</code> to generate the contribution series aligned to the simulation calendar, then combines it with deterministic or Monte Carlo returns to simulate wealth.</p> </li> <li> <p><code>investment.py</code>   Receives the contributions from <code>income.py</code> and applies capital accumulation:   $$   W_{t+1}=(W_t+A_t)(1+R_t).   $$   Metrics (CAGR, drawdown, volatility) are computed downstream on the resulting wealth path.</p> </li> <li> <p><code>utils.py</code>   Provides shared helpers used by <code>income.py</code> (e.g., rate conversions annual\u2194monthly, month index construction, validation).</p> </li> </ul>"},{"location":"income/#recommended-usage-patterns","title":"Recommended usage patterns","text":""},{"location":"income/#a-baseline-projection-deterministic","title":"A) Baseline projection (deterministic)","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\n\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000.0, annual_growth=0.00),\n    variable=VariableIncome(base=200_000.0, sigma=0.00)  # no noise\n)\n\n# 24-month calendar-aligned totals (and components if needed)\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n</code></pre>"},{"location":"income/#b-from-income-to-contributions","title":"B) From income to contributions","text":"<p>Option 1: Use defaults (30% fixed, 100% variable) <pre><code>contrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 2: Custom monthly fractions <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # 35% each month (Jan-Dec)\n    \"variable\": [1.0]*12     # 100% each month\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 3: Seasonal contribution patterns <pre><code># Higher contributions in bonus months\nincome.monthly_contribution = {\n    \"fixed\": [0.30]*12,\n    \"variable\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n                 1.0, 1.0, 1.0, 1.0, 1.0, 0.5]  # save 50% of Dec bonus\n}\n</code></pre></p>"},{"location":"income/#c-fixed-income-with-salary-raises","title":"C) Fixed income with salary raises","text":"<pre><code>fixed = FixedIncome(\n    base=1_400_000.0,\n    annual_growth=0.03,\n    salary_raises={\n        date(2025, 7, 1): 200_000,   # raise in July\n        date(2026, 1, 1): 150_000    # raise in January\n    }\n)\n# Requires start date when projecting\npath = fixed.project(months=24, start=date(2025, 1, 1))  # returns array by default\nseries = fixed.project(months=24, start=date(2025, 1, 1), output=\"series\")  # with calendar index\n</code></pre>"},{"location":"income/#d-variable-income-with-seasonality-noise","title":"D) Variable income with seasonality + noise","text":"<pre><code>seasonality = [1.00, 0.95, 1.05, 1.10, 1.15, 1.10, \n               1.00, 0.90, 0.95, 1.05, 1.10, 1.20]\n\nincome_var = VariableIncome(\n    base=200_000.0,\n    seasonality=seasonality,\n    sigma=0.15,\n    floor=50_000.0,\n    cap=400_000.0,\n    annual_growth=0.02,\n    seed=123\n)\n\n# Project as array (default)\npath = income_var.project(months=12)\n\n# Project as Series with calendar alignment\nseries = income_var.project(months=12, start=date(2025, 1, 1), output=\"series\")\n</code></pre>"},{"location":"income/#e-statistical-summary","title":"E) Statistical summary","text":"<pre><code># Detailed metrics as dataclass\nmetrics = income.income_metrics(\n    months=24, \n    start=date(2025, 1, 1),\n    variable_threshold=150_000.0\n)\n\n# Compact summary as Series\nsummary = income.summary(months=24, start=date(2025, 1, 1), round_digits=2)\nprint(summary)\n</code></pre>"},{"location":"income/#f-visualization-with-monte-carlo-trajectories","title":"F) Visualization with Monte Carlo trajectories","text":"<pre><code># Income streams with stochastic trajectories (default if sigma &gt; 0)\nincome.plot_income(\n    months=24, \n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    n_simulations=500,\n    dual_axis=\"auto\",\n    save_path=\"income_projection.png\"\n)\n\n# Legacy mode: confidence bands only\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=False,\n    show_confidence_band=True,\n    confidence=0.95\n)\n\n# Hybrid mode: trajectories + bands\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    show_confidence_band=True,\n    n_simulations=150,\n    trajectory_alpha=0.03\n)\n\n# Contributions with trajectories\nincome.plot_contributions(\n    months=24, \n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    title=\"Monthly Investment Contributions\"\n)\n\n# Using unified wrapper\nincome.plot(\n    mode=\"income\",  # or \"contributions\"\n    months=24,\n    start=date(2025, 1, 1)\n)\n</code></pre>"},{"location":"income/#key-design-decisions","title":"Key design decisions","text":""},{"location":"income/#1-monthly-fractions-are-12-element-arrays-not-scalars","title":"1. Monthly fractions are 12-element arrays, not scalars","text":"<p>This allows seasonal contribution strategies: save more during high-income months, less during lean months. The arrays rotate based on <code>start</code> and repeat cyclically.</p>"},{"location":"income/#2-salary-raises-are-date-based-not-month-offset-based","title":"2. Salary raises are date-based, not month-offset-based","text":"<p>You specify <code>{date(2025, 7, 1): 200_000}</code>, not <code>{6: 200_000}</code>. The conversion to month offsets happens internally relative to the projection <code>start</code> date, making the model calendar-aware.</p>"},{"location":"income/#3-flexible-output-formats-via-output-parameter","title":"3. Flexible output formats via <code>output</code> parameter","text":"<p>All projection methods (<code>FixedIncome.project()</code>, <code>VariableIncome.project()</code>, <code>IncomeModel.project()</code>, <code>IncomeModel.contributions()</code>) support an <code>output</code> parameter to control return type: - <code>\"array\"</code>: returns <code>np.ndarray</code> (default for streams, no calendar overhead) - <code>\"series\"</code>: returns <code>pd.Series</code> with calendar index (default for <code>IncomeModel</code>, user-friendly) - <code>\"dataframe\"</code>: returns <code>pd.DataFrame</code> with component breakdown (only <code>IncomeModel.project()</code>)</p>"},{"location":"income/#4-reproducibility-via-explicit-seed-parameter","title":"4. Reproducibility via explicit <code>seed</code> parameter","text":"<p>Variable income randomness is controlled at two levels: - Instance-level: <code>VariableIncome(seed=42)</code> sets default seed - Method-level: <code>project(..., seed=123)</code> overrides for specific realizations This enables reproducible stochastic projections without mutating the model state.</p>"},{"location":"income/#5-monte-carlo-trajectories-as-primary-visualization","title":"5. Monte Carlo trajectories as primary visualization","text":"<p>When <code>sigma &gt; 0</code>, plotting methods default to showing individual trajectories (<code>show_trajectories=True</code>) instead of confidence bands, providing more intuitive visualization of stochastic dynamics. Confidence bands remain available via <code>show_confidence_band=True</code>.</p>"},{"location":"income/#6-dual-axis-activation-is-automatic-by-default","title":"6. Dual-axis activation is automatic by default","text":"<p>When fixed and variable incomes differ by a factor &gt; <code>dual_axis_ratio</code>, the plot automatically uses separate y-axes to avoid visual compression. Override with <code>dual_axis=True|False</code>.</p>"},{"location":"income/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Rate conversion: <code>annual_to_monthly(g) = (1+g)^(1/12) - 1</code> ensures geometric compounding</li> <li>Calendar alignment: <code>month_index(start, months)</code> generates <code>pd.DatetimeIndex</code> of first-of-month dates</li> <li>Seasonality rotation: <code>normalize_start_month(start)</code> returns 0-indexed month offset (0=Jan, 11=Dec)</li> <li>Non-negativity: all income and contribution values are floored at zero after transformations</li> <li>Seed propagation: <code>seed=None</code> in methods uses instance seed; both <code>None</code> generates non-deterministic noise</li> </ul>"},{"location":"model/","title":"<code>model</code> \u2014 Unified Orchestration for FinOpt","text":"<p>Purpose: Unified orchestrator for Monte Carlo simulation, integrating income generation, return modeling, withdrawals, and portfolio dynamics into a single coherent interface with intelligent caching, reproducibility guarantees, and optimization-ready outputs. <code>model.py</code> is the facade layer: while <code>income.py</code> generates cash flows, <code>returns.py</code> produces stochastic returns, <code>withdrawal.py</code> models cash outflows, and <code>portfolio.py</code> executes wealth dynamics, <code>model.py</code> coordinates the entire pipeline and packages results for analysis and optimization.</p>"},{"location":"model/#why-a-dedicated-model-module","title":"Why a dedicated model module?","text":"<p>Financial planning requires end-to-end simulation with multiple moving parts. <code>model.py</code> provides:</p> <ul> <li>Single entry point: Unified <code>FinancialModel</code> class orchestrates all components</li> <li>Intelligent caching: Parameter-based memoization avoids redundant computation</li> <li>Reproducibility: Explicit seed management with automatic propagation</li> <li>Rich analytics: <code>SimulationResult</code> container with financial metrics computation</li> <li>Seamless visualization: Auto-simulation in <code>plot()</code> methods</li> <li>Optimization integration: Direct <code>optimize()</code> method for goal-seeking</li> <li>Withdrawal support: Scheduled and stochastic withdrawals via <code>WithdrawalModel</code></li> </ul>"},{"location":"model/#design-principles","title":"Design principles","text":"<ol> <li>Facade pattern: Coordinates but doesn't re-implement (loose coupling)</li> <li>Explicit reproducibility: Seed propagation ensures statistical independence:</li> <li>Income uses <code>seed</code></li> <li>Returns use <code>seed+1</code></li> <li>Withdrawals use <code>seed+2</code></li> <li>Type-safe results: <code>SimulationResult</code> as explicit dataclass (not <code>dict</code>)</li> <li>Zero-overhead visualization: <code>plot()</code> auto-simulates with caching</li> <li>Optimization-ready: <code>optimize()</code> method for bilevel goal-seeking</li> </ol>"},{"location":"model/#core-components","title":"Core components","text":""},{"location":"model/#1-simulationresult","title":"1) <code>SimulationResult</code>","text":"<p>Container for complete Monte Carlo simulation output with lazy-computed analytics.</p> <p>Attributes: <pre><code>@dataclass(frozen=False)\nclass SimulationResult:\n    # Primary outputs\n    wealth: np.ndarray              # (n_sims, T+1, M)\n    total_wealth: np.ndarray        # (n_sims, T+1)\n    contributions: np.ndarray       # (n_sims, T) or (T,)\n    returns: np.ndarray             # (n_sims, T, M)\n    income: dict                    # {\"fixed\", \"variable\", \"total\"}\n    allocation: np.ndarray          # (T, M)\n    withdrawals: np.ndarray         # (n_sims, T, M) or (T, M) or None\n\n    # Metadata for reproducibility\n    T, n_sims, M: int\n    start: date\n    seed: Optional[int]\n    account_names: List[str]\n</code></pre></p> <p>Analytical methods:</p>"},{"location":"model/#metricsaccountnone-pddataframe","title":"<code>metrics(account=None) \u2192 pd.DataFrame</code>","text":"<p>Computes per-simulation financial metrics:</p> \\[ \\begin{aligned} \\text{CAGR}_i &amp;= \\left(\\frac{W_{T,i}}{W_{0,i}}\\right)^{12/T} - 1 \\\\ \\text{Sharpe}_i &amp;= \\frac{\\bar{R}_i}{\\sigma_i} \\quad \\text{(assumes } r_f = 0\\text{)} \\\\ \\text{Sortino}_i &amp;= \\frac{\\bar{R}_i}{\\sigma^-_i}, \\quad \\sigma^-_i = \\sqrt{\\mathbb{E}[\\min(R_t, 0)^2]} \\\\ \\text{MDD}_i &amp;= \\min_{t} \\frac{W_{t,i} - \\max_{s \\leq t} W_{s,i}}{\\max_{s \\leq t} W_{s,i}} \\end{aligned} \\] <p>Returns: DataFrame with columns <code>['cagr', 'volatility', 'sharpe', 'sortino', 'max_drawdown']</code></p>"},{"location":"model/#aggregate_metricsaccountnone-pdseries-pddataframe","title":"<code>aggregate_metrics(account=None) \u2192 pd.Series | pd.DataFrame</code>","text":"<p>Computes distribution-level risk metrics:</p> \\[ \\begin{aligned} \\text{VaR}_{0.95}(W_T) &amp;= F_{W_T}^{-1}(0.05) \\quad \\text{(5th percentile)} \\\\ \\text{CVaR}_{0.95}(W_T) &amp;= \\mathbb{E}[W_T \\mid W_T \\leq \\text{VaR}_{0.95}] \\end{aligned} \\] <p>Plus summary statistics: mean, median, std, min, max of \\(W_T\\).</p>"},{"location":"model/#summaryconfidence095-pddataframe","title":"<code>summary(confidence=0.95) \u2192 pd.DataFrame</code>","text":"<p>Statistical summary with confidence intervals: $$ \\text{CI}{1-\\alpha}(W_T) = \\left[F^{-1}{W_T}(\\alpha/2), F^{-1}_{W_T}(1-\\alpha/2)\\right] $$</p>"},{"location":"model/#convergence_analysis-pddataframe","title":"<code>convergence_analysis() \u2192 pd.DataFrame</code>","text":"<p>Monte Carlo convergence diagnostics via standard error: \\(\\text{SE}(n) = \\frac{\\sigma_{W_T}}{\\sqrt{n}}\\)</p>"},{"location":"model/#2-financialmodel","title":"2) <code>FinancialModel</code>","text":"<p>Unified orchestrator coordinating the flow: <code>income \u2192 contributions (A) \u2192 returns (R) \u2192 withdrawals (D) \u2192 wealth (W)</code></p> <p>Constructor: <pre><code>FinancialModel(\n    income: IncomeModel,\n    accounts: List[Account],\n    default_correlation: Optional[np.ndarray] = None,\n    enable_cache: bool = True\n)\n</code></pre></p> <p>Internal components: <pre><code>self.returns = ReturnModel(accounts, default_correlation)\nself.portfolio = Portfolio(accounts)\n</code></pre></p> <p>Key methods:</p> Method Description <code>simulate(T, X, n_sims, ...)</code> Run Monte Carlo simulation <code>optimize(goals, optimizer, ...)</code> Find minimum-horizon policy <code>simulate_from_optimization(opt_result, ...)</code> Simulate with optimal policy <code>verify_goals(result, goals, ...)</code> Validate goal satisfaction <code>plot(mode, ...)</code> Unified visualization <code>cache_info()</code> Get cache statistics <code>clear_cache()</code> Free cached results"},{"location":"model/#simulation-workflow","title":"Simulation workflow","text":""},{"location":"model/#simulate-method","title":"<code>simulate()</code> method","text":"<pre><code>def simulate(\n    T: int,\n    X: np.ndarray,                    # (T, M)\n    n_sims: int = 1,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    use_cache: bool = True,\n    withdrawals: Optional[WithdrawalModel] = None\n) -&gt; SimulationResult\n</code></pre> <p>Pipeline execution:</p> <ol> <li>Cache lookup: SHA256 hash of <code>(T, X.tobytes(), n_sims, start, seed, withdrawals.to_dict())</code></li> <li>Seed propagation: <pre><code>A = income.contributions(T, start, seed=seed, n_sims=n_sims)\nR = returns.generate(T, n_sims, seed=None if seed is None else seed+1)\nD = withdrawals.to_array(T, start, accounts, n_sims, seed=seed+2)  # if provided\n</code></pre></li> <li>Wealth dynamics: <pre><code>portfolio_result = portfolio.simulate(A, R, X, D=D)\n</code></pre>    Uses wealth evolution:    $$    W_{t+1}^m = (W_t^m + A_t x_t^m - D_t^m)(1 + R_t^m)    $$</li> <li>Result packaging: Wrap arrays in <code>SimulationResult</code> dataclass</li> </ol> <p>Example: <pre><code>from datetime import date\nfrom finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\n# Basic simulation (no withdrawals)\nX = np.tile([0.7, 0.3], (24, 1))\nresult = model.simulate(T=24, X=X, n_sims=1000, seed=42)\n\n# With withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 2_000_000, date(2026, 6, 1), \"Vacation\")\n    ])\n)\nresult = model.simulate(T=24, X=X, n_sims=1000, seed=42, withdrawals=withdrawals)\n\n# Second call with same params: O(1) (cached)\nresult2 = model.simulate(T=24, X=X, n_sims=1000, seed=42, withdrawals=withdrawals)\nassert result is result2  # same object\n</code></pre></p>"},{"location":"model/#optimization-workflow","title":"Optimization workflow","text":""},{"location":"model/#optimize-method","title":"<code>optimize()</code> method","text":"<pre><code>def optimize(\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    optimizer: AllocationOptimizer,\n    T_max: int = 240,\n    n_sims: int = 500,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,\n    verbose: bool = True,\n    search_method: str = \"binary\",\n    withdrawals: Optional[WithdrawalModel] = None,\n    withdrawal_epsilon: float = 0.05,\n    **solver_kwargs\n) -&gt; OptimizationResult\n</code></pre> <p>Bilevel optimization: - Outer problem: Minimize horizon \\(T\\) - Inner problem: Find feasible allocation \\(X^*\\) at horizon \\(T\\)</p> <p>Search strategies: - <code>\"binary\"</code>: Binary search (faster, ~50% fewer iterations) - <code>\"linear\"</code>: Sequential search (safer, guaranteed to find solution)</p> <p>Example: <pre><code>from finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\n\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\n\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    search_method=\"binary\",\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(result.summary())\n</code></pre></p>"},{"location":"model/#simulate_from_optimization-method","title":"<code>simulate_from_optimization()</code> method","text":"<p>Convenience wrapper to simulate with optimal policy from optimization.</p> <pre><code>def simulate_from_optimization(\n    opt_result: OptimizationResult,\n    n_sims: int = 500,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,\n    withdrawals: Optional[WithdrawalModel] = None\n) -&gt; SimulationResult\n</code></pre> <p>Example: <pre><code># Optimize\nopt_result = model.optimize(goals, optimizer, T_max=120, n_sims=500, seed=42)\n\n# Validate with 1000 fresh scenarios\nsim_result = model.simulate_from_optimization(\n    opt_result,\n    n_sims=1000,\n    seed=999,  # Different seed for out-of-sample validation\n    withdrawals=withdrawals\n)\n</code></pre></p>"},{"location":"model/#verify_goals-method","title":"<code>verify_goals()</code> method","text":"<p>Validate goal satisfaction in simulation/optimization result.</p> <pre><code>def verify_goals(\n    result: Union[SimulationResult, OptimizationResult],\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    start: Optional[date] = None\n) -&gt; Dict[Goal, Dict[str, float]]\n</code></pre> <p>Returns: For each goal: - <code>satisfied</code>: bool - <code>violation_rate</code>: float (empirical \u2119(W &lt; threshold)) - <code>required_rate</code>: float (goal's \u03b5 = 1 - confidence) - <code>margin</code>: float (positive \u2192 satisfied) - <code>median_shortfall</code>: float - <code>n_violations</code>: int</p> <p>Example: <pre><code>status = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    if not metrics['satisfied']:\n        print(f\"VIOLATED: {goal}\")\n        print(f\"  Violation rate: {metrics['violation_rate']:.2%}\")\n        print(f\"  Shortfall: ${metrics['median_shortfall']:,.0f}\")\n</code></pre></p>"},{"location":"model/#unified-plotting-interface","title":"Unified plotting interface","text":""},{"location":"model/#plot-method","title":"<code>plot()</code> method","text":"<pre><code>def plot(\n    mode: str,\n    *,\n    T: Optional[int] = None,\n    X: Optional[np.ndarray] = None,\n    n_sims: int = 500,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    result: Optional[SimulationResult] = None,\n    goals: Optional[List] = None,\n    **kwargs\n)\n</code></pre> <p>Available modes:</p> Mode Requires Simulation Description <code>\"income\"</code> No Fixed + variable + total income streams <code>\"contributions\"</code> No Monthly contribution schedule <code>\"returns\"</code> No Return distributions and trajectories <code>\"returns_cumulative\"</code> No Cumulative return evolution <code>\"returns_horizon\"</code> No Risk-return by investment horizon <code>\"wealth\"</code> Yes Portfolio dynamics (4 panels) <code>\"comparison\"</code> Yes Multi-strategy comparison <p>Auto-simulation logic: <pre><code>IF mode in {\"wealth\", \"comparison\"}:\n    IF result provided:\n        use result\n    ELSE:\n        result = self.simulate(T, X, n_sims, start, seed)  # cached\n</code></pre></p> <p>Goals visualization: When <code>goals</code> parameter is provided to wealth plots: - TerminalGoal: Horizontal dashed line at threshold - IntermediateGoal: Dotted line with diamond marker at goal month</p> <p>Examples: <pre><code># Direct plotting (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42,\n           start=date(2025, 1, 1), goals=goals)\n\n# Reuse result across plots\nresult = model.simulate(T=24, X=X, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result, show_trajectories=True)\nmodel.plot(\"wealth\", result=result, show_trajectories=False)\n\n# Strategy comparison\nresults = {\n    \"Conservative\": model.simulate(T=24, X=X_cons, n_sims=500),\n    \"Aggressive\": model.simulate(T=24, X=X_agg, n_sims=500)\n}\nmodel.plot(\"comparison\", results=results)\n</code></pre></p>"},{"location":"model/#cache-management","title":"Cache management","text":""},{"location":"model/#inspection","title":"Inspection","text":"<pre><code>info = model.cache_info()\n# {'size': 3, 'memory_mb': 28.7}\n</code></pre> <p>Memory estimate: \\(\\approx n_{\\text{sims}} \\cdot T \\cdot M \\cdot 24\\) bytes (wealth + returns + contributions)</p>"},{"location":"model/#cache-key-components","title":"Cache key components","text":"<p>The cache key is computed via SHA256 hash of: - <code>T</code>: Horizon - <code>X.tobytes()</code>: Allocation policy bytes - <code>n_sims</code>: Number of simulations - <code>start</code>: Start date - <code>seed</code>: Random seed - <code>withdrawals.to_dict()</code>: Withdrawal configuration (if provided)</p>"},{"location":"model/#trade-offs","title":"Trade-offs","text":"<p>With cache (default): - Instant repeated calls - RAM scales with parameter space</p> <p>Without cache: <pre><code>model = FinancialModel(income, accounts, enable_cache=False)\n</code></pre> - Minimal memory - Re-simulation on every call</p> <p>Rule: Enable cache if <code>n_params \u00d7 n_sims \u00d7 T \u00d7 M \u00d7 24 &lt; 0.5 \u00d7 RAM</code>.</p>"},{"location":"model/#usage-patterns","title":"Usage patterns","text":""},{"location":"model/#a-basic-simulation-with-reproducibility","title":"A) Basic simulation with reproducibility","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04),\n    variable=VariableIncome(base=300_000, sigma=0.15, seed=100)\n)\n\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15)\n]\n\nmodel = FinancialModel(income, accounts)\n\n# Simulate\nX = np.tile([0.7, 0.3], (36, 1))\nresult = model.simulate(T=36, X=X, n_sims=2000, seed=42, start=date(2025, 1, 1))\n</code></pre>"},{"location":"model/#b-simulation-with-withdrawals","title":"B) Simulation with withdrawals","text":"<pre><code>from finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 5_000_000, date(2027, 1, 1), \"Pie departamento\")\n    ])\n)\n\nresult = model.simulate(\n    T=36, X=X, n_sims=2000, seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals\n)\n\n# Check withdrawals are recorded\nprint(result.withdrawals.shape)  # (2000, 36, 2)\n</code></pre>"},{"location":"model/#c-statistical-analysis","title":"C) Statistical analysis","text":"<pre><code># Summary statistics\nprint(result.summary(confidence=0.95))\n\n# Per-simulation metrics\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"Sharpe: {metrics['sharpe'].mean():.3f} \u00b1 {metrics['sharpe'].std():.3f}\")\n\n# Distribution-level risk\nagg = result.aggregate_metrics()\nprint(f\"VaR\u2089\u2085: ${agg.loc['Housing', 'var_95']:,.0f}\")\n</code></pre>"},{"location":"model/#d-full-optimization-workflow","title":"D) Full optimization workflow","text":"<pre><code>from finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\n# Optimize\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\nopt_result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={opt_result.T}\")\nprint(opt_result.summary())\n\n# Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"{goal.account}: {'\u2713' if metrics['satisfied'] else '\u2717'}\")\n</code></pre>"},{"location":"model/#e-visualization","title":"E) Visualization","text":"<pre><code># Pre-simulation plots\nmodel.plot(\"income\", months=24, start=date(2025, 1, 1))\nmodel.plot(\"returns_cumulative\", T=120, n_sims=500, start=date(2025, 1, 1))\n\n# Simulation-based with goals (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42,\n           start=date(2025, 1, 1), goals=goals, show_trajectories=True)\n\n# Using optimization result\nmodel.plot(\"wealth\", result=sim_result, goals=goals)\n</code></pre>"},{"location":"model/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter), where \\(F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m)\\).</p> <p>Proposition 2 (Stochastic Gradient): For independent \\(A_s\\) and \\(F_{s,t}^m\\): $$ \\mathbb{E}\\left[\\nabla_{x_s^m} W_t^m(X)\\right] = \\mathbb{E}[A_s] \\cdot \\mathbb{E}[F_{s,t}^m] $$</p> <p>Proposition 3 (Convergence Rate): For IID simulations: $$ \\left|\\hat{\\mathbb{E}}_n[W_T] - \\mathbb{E}[W_T]\\right| = O_p\\left(\\frac{1}{\\sqrt{n}}\\right) $$</p>"},{"location":"model/#seed-propagation","title":"Seed propagation","text":"<p>To ensure statistical independence while maintaining reproducibility:</p> Component Seed Used Purpose Income <code>seed</code> Stochastic contributions (VariableIncome) Returns <code>seed + 1</code> Correlated lognormal returns Withdrawals <code>seed + 2</code> Stochastic withdrawals <p>This ensures that changing the income model doesn't affect return scenarios (and vice versa), while maintaining full reproducibility when the same seed is used.</p>"},{"location":"model/#limitations","title":"Limitations","text":"<ol> <li> <p>Cache doesn't detect component mutations: Call <code>model.clear_cache()</code> after modifying <code>income</code> or <code>accounts</code> in-place.</p> </li> <li> <p>Fixed horizon T per simulation: For dynamic \\(T\\) optimization, use <code>optimize()</code> method.</p> </li> <li> <p>Constant correlation matrix: \\(\\Sigma\\) fixed over time (no regime-switching).</p> </li> <li> <p>Cache memory: Large parameter sweeps can consume significant RAM.</p> </li> </ol>"},{"location":"model/#complete-example","title":"Complete example","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer\nfrom finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, WithdrawalEvent\n\n# 1. Setup income\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04,\n                     salary_raises={date(2025, 7, 1): 200_000}),\n    variable=VariableIncome(base=300_000, sigma=0.15,\n                           seasonality=[1.0, 0.9, 1.1, 1.0, 1.2, 1.1,\n                                       1.0, 0.9, 0.95, 1.05, 1.1, 1.3],\n                           seed=100)\n)\n\n# 2. Setup accounts\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06,\n                        display_name=\"Fondo de Emergencia\"),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15,\n                        display_name=\"Ahorro Vivienda\")\n]\n\n# 3. Create model\nmodel = FinancialModel(income, accounts)\n\n# 4. Define withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Housing\", 5_000_000, date(2027, 6, 1), \"Pie departamento\")\n    ])\n)\n\n# 5. Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 12, 1), account=\"Emergency\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"Housing\", threshold=30_000_000, confidence=0.90)\n]\n\n# 6. Optimize\noptimizer = CVaROptimizer(n_accounts=model.M, objective=\"balanced\")\nopt_result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=60,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    withdrawals=withdrawals,\n    withdrawal_epsilon=0.05,\n    verbose=True\n)\n\nprint(f\"\\n=== Optimization Result ===\")\nprint(f\"Optimal horizon: T*={opt_result.T} months\")\nprint(opt_result.summary())\n\n# 7. Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(\n    opt_result,\n    n_sims=1000,\n    seed=999,\n    withdrawals=withdrawals\n)\n\n# 8. Check goals\nstatus = model.verify_goals(sim_result, goals)\nprint(\"\\n=== Goal Validation ===\")\nfor goal, metrics in status.items():\n    symbol = \"\u2713\" if metrics['satisfied'] else \"\u2717\"\n    print(f\"[{symbol}] {goal.account}: {metrics['violation_rate']:.1%} violations\")\n\n# 9. Statistical summary\nprint(\"\\n=== Final Wealth Summary ===\")\nprint(sim_result.summary(confidence=0.95))\n\n# 10. Visualize\nmodel.plot(\"wealth\", result=sim_result, goals=goals,\n           title=\"Optimized Portfolio with Withdrawals\",\n           show_trajectories=True)\n\n# 11. Cache info\nprint(f\"\\nCache: {model.cache_info()}\")\n</code></pre>"},{"location":"model/#references","title":"References","text":"<p>Internal modules: - income.py: Generates \\(A_t\\) (contributions) with fixed + variable streams - returns.py: Generates \\(R_t^m\\) (correlated lognormal returns) - withdrawal.py: Generates \\(D_t^m\\) (scheduled + stochastic withdrawals) - portfolio.py: Executes \\(W_{t+1}^m = (W_t^m + A_t x_t^m - D_t^m)(1 + R_t^m)\\) - goals.py: Defines chance constraints for optimization - optimization.py: Implements CVaR reformulation and bilevel search</p>"},{"location":"optimization/","title":"<code>optimization</code> \u2014 Convex Programming for Goal-Driven Portfolios","text":"<p>Core idea: Transform financial goals into convex optimization problems via CVaR reformulation, searching over horizons to find minimum feasible time and optimal allocations.</p>"},{"location":"optimization/#philosophy-and-role","title":"Philosophy and Role","text":""},{"location":"optimization/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li><code>income.py</code> \u2192 Contribution scenarios \\(A_t\\)</li> <li><code>portfolio.py</code> \u2192 Wealth dynamics \\(W_t^m(X)\\) via affine representation</li> <li><code>goals.py</code> \u2192 Goal specifications as chance constraints</li> <li><code>optimization.py</code> \u2192 Decision synthesis: minimize \\(T\\), optimize allocations \\(X\\)</li> </ul>"},{"location":"optimization/#inversion-of-traditional-planning","title":"Inversion of Traditional Planning","text":"<p>Traditional: Given savings \\(X\\) and horizon \\(T\\), compute terminal wealth FinOpt: Given wealth goals, find minimum \\(T^*\\) and optimal \\(X^*\\)</p> <p>Requires: 1. Chance-constrained formulation: \\(\\mathbb{P}(W_t^m \\geq b) \\geq 1-\\varepsilon\\) 2. Convex reformulation via CVaR 3. Bilevel optimization: outer (minimize \\(T\\)), inner (convex program)</p>"},{"location":"optimization/#mathematical-foundations","title":"Mathematical Foundations","text":""},{"location":"optimization/#wealth-evolution","title":"Wealth Evolution","text":"<p>Multiple accounts \\(m \\in \\{1,\\dots,M\\}\\):</p> \\[ W_{t+1}^m = \\big(W_t^m + A_t x_t^m - D_t^m\\big)(1 + R_t^m) \\] <p>where \\(D_t^m\\) is the withdrawal from account \\(m\\) at time \\(t\\).</p> <p>Closed-form (affine representation):</p> \\[ \\boxed{ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\, x_s^m - D_s^m\\big) \\, F_{s,t}^m } \\] <p>where accumulation factor:</p> \\[ F_{s,t}^m := \\prod_{\\tau=s+1}^{t} (1 + R_\\tau^m) \\] <p>Key consequences: - Affinity: \\(W_t^m(X)\\) linear in \\(X\\) (withdrawals \\(D\\) are parameters) \u2192 enables convex programming - Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) \u2192 analytical derivatives - Efficiency: \\(O(1)\\) wealth evaluation, no recursion</p>"},{"location":"optimization/#allocation-simplex","title":"Allocation Simplex","text":"<p>Decision variables satisfy budget constraint:</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} : x_t^m \\geq 0, \\; \\sum_{m=1}^M x_t^m = 1, \\; \\forall t \\right\\} \\] <p>Cartesian product of \\(T\\) probability simplices: \\(\\mathcal{X}_T = \\Delta^{M-1} \\times \\cdots \\times \\Delta^{M-1}\\).</p>"},{"location":"optimization/#bilevel-optimization","title":"Bilevel Optimization","text":""},{"location":"optimization/#problem-statement","title":"Problem Statement","text":"\\[ \\boxed{ \\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\mathcal{F}_T \\neq \\emptyset } \\] <p>where goal-feasible set:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\mathbb{P}\\big(W_t^m(X) \\geq b_t^m\\big) \\geq 1-\\varepsilon_t^m, \\; \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\geq b^m\\big) \\geq 1-\\varepsilon^m, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\\\ &amp; \\mathbb{P}\\big(W_t^m(X) \\geq D_t^m\\big) \\geq 1-\\delta, \\; \\forall \\text{ withdrawals} \\end{aligned} \\right\\} \\] <p>Inner problem (fixed \\(T\\)): $$ \\max_{X \\in \\mathcal{F}_T} f(X) $$</p>"},{"location":"optimization/#implemented-objectives","title":"Implemented Objectives","text":"<p>All objectives exploit affine wealth \\(W_t^m(X) = b + \\Phi X\\) for convexity:</p> Objective Formula Type Use Case <code>\"risky\"</code> \\(\\mathbb{E}\\left[\\sum_{m} W_T^m\\right]\\) LP Maximum wealth accumulation <code>\"balanced\"</code> \\(-\\sum_{t,m}(x_{t+1,m} - x_t^m)^2\\) QP Stable allocations (default) <code>\"conservative\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\cdot \\text{Var}(W_T)\\) QP Risk-averse mean-variance <code>\"risky_turnover\"</code> \\(\\mathbb{E}[W_T] - \\lambda \\cdot \\sum(\\Delta x)^2\\) QP Wealth + stability tradeoff <p>Note: The <code>conservative</code> objective uses variance (not standard deviation) in the CVXPY formulation for DCP compliance.</p>"},{"location":"optimization/#cvar-reformulation","title":"CVaR Reformulation","text":""},{"location":"optimization/#epigraphic-formulation-rockafellar-uryasev-2000","title":"Epigraphic Formulation (Rockafellar &amp; Uryasev 2000)","text":"<p>Transform chance constraint \\(\\mathbb{P}(W \\geq b) \\geq 1-\\varepsilon\\) into convex constraint:</p> \\[ \\text{CVaR}_\\varepsilon(b - W) \\leq 0 \\] <p>Epigraphic representation: $$ \\text{CVaR}\\alpha(L) = \\min{\\gamma, z} \\left{ \\gamma + \\frac{1}{\\alpha N} \\sum_{i=1}^N z^i \\right} $$ subject to: $$ z^i \\geq L^i - \\gamma, \\quad z^i \\geq 0, \\quad \\forall i $$</p> <p>where \\(L^i = b - W^i\\) is shortfall in scenario \\(i\\).</p>"},{"location":"optimization/#convex-program-formulation","title":"Convex Program Formulation","text":"<p>Decision variables: - \\(X \\in \\mathbb{R}^{T \\times M}\\): allocations - \\(\\gamma_g \\in \\mathbb{R}\\): VaR level per goal \\(g\\) - \\(z_g \\in \\mathbb{R}_+^N\\): excess shortfall per goal \\(g\\)</p> <p>Constraints:</p> <ol> <li> <p>Simplex: \\(\\sum_m x_t^m = 1, \\; x_t^m \\geq 0\\)</p> </li> <li> <p>CVaR (per goal): $$ \\begin{aligned} z_g^i &amp;\\geq (\\text{threshold}g - W{t_g}^{m_g,i}(X)) - \\gamma_g \\ \\gamma_g &amp;+ \\frac{1}{\\varepsilon_g N} \\sum_{i=1}^N z_g^i \\leq 0 \\end{aligned} $$</p> </li> <li> <p>Withdrawal feasibility (per withdrawal): $$ \\begin{aligned} z_w^i &amp;\\geq (D_t^m - W_t^{m,i}(X)) - \\gamma_w \\ \\gamma_w &amp;+ \\frac{1}{\\delta N} \\sum_{i=1}^N z_w^i \\leq 0 \\end{aligned} $$</p> </li> </ol>"},{"location":"optimization/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"optimization/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>OptimizationResult (frozen dataclass)\n    \u251c\u2500 X: np.ndarray (T, M)\n    \u251c\u2500 T: int\n    \u251c\u2500 objective_value: float\n    \u251c\u2500 feasible: bool\n    \u251c\u2500 goals: List[IntermediateGoal | TerminalGoal]\n    \u251c\u2500 goal_set: GoalSet\n    \u251c\u2500 solve_time: float\n    \u251c\u2500 validate_goals(result) \u2192 dict\n    \u251c\u2500 is_valid_allocation(tol) \u2192 bool\n    \u2514\u2500 summary() \u2192 str\n\nAllocationOptimizer (ABC)\n    \u251c\u2500 solve(T, A, R, initial_wealth, goal_set, D, ...) \u2192 OptimizationResult\n    \u251c\u2500 _check_feasibility(...) \u2192 bool\n    \u2514\u2500 _compute_objective(W, X, T, M) \u2192 float\n\nCVaROptimizer(AllocationOptimizer)\n    \u251c\u2500 cp: CVXPY module\n    \u251c\u2500 objective: str \u2208 {\"risky\", \"balanced\", \"risky_turnover\", \"conservative\"}\n    \u2514\u2500 solve(..., D, withdrawal_epsilon, ...) \u2192 OptimizationResult\n\nGoalSeeker\n    \u251c\u2500 optimizer: AllocationOptimizer\n    \u251c\u2500 seek(..., D_generator, withdrawal_epsilon, search_method) \u2192 OptimizationResult\n    \u251c\u2500 _linear_search(...) \u2192 OptimizationResult\n    \u2514\u2500 _binary_search(...) \u2192 OptimizationResult\n</code></pre>"},{"location":"optimization/#key-design-patterns","title":"Key Design Patterns","text":"<p>GoalSet passed explicitly: Caller creates <code>GoalSet</code> once before optimization loop:</p> <pre><code># In GoalSeeker.seek()\ngoal_set = GoalSet(goals, accounts, start_date)\n\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(\n        T=T, A=A, R=R, initial_wealth=initial_wealth,\n        goal_set=goal_set,  # Pre-validated, reused\n        D=D,                # Withdrawals (optional)\n        withdrawal_epsilon=0.05,\n        **solver_kwargs\n    )\n</code></pre> <p>Separation of responsibilities: - <code>GoalSet</code>: Validation, account resolution, minimum horizon estimation - <code>AllocationOptimizer</code>: Convex programming, feasibility checking - <code>GoalSeeker</code>: Bilevel search, warm starting</p>"},{"location":"optimization/#cvaroptimizer-api","title":"CVaROptimizer API","text":""},{"location":"optimization/#constructor","title":"Constructor","text":"<pre><code>from finopt.src.optimization import CVaROptimizer\n\noptimizer = CVaROptimizer(\n    n_accounts=3,\n    objective='balanced',           # Default: turnover minimization\n    objective_params={'lambda': 0.5},  # For conservative/risky_turnover\n    account_names=['Emergency', 'Housing', 'Retirement']\n)\n</code></pre>"},{"location":"optimization/#solve-method","title":"solve() Method","text":"<pre><code>result = optimizer.solve(\n    T=24,                          # Horizon (months)\n    A=A_scenarios,                 # (n_sims, T) contributions\n    R=R_scenarios,                 # (n_sims, T, M) returns\n    initial_wealth=np.array([1e6, 0.5e6, 2e6]),  # (M,)\n    goal_set=goal_set,             # Pre-validated GoalSet (REQUIRED)\n    X_init=None,                   # Warm start (optional, ignored by CVXPY)\n    D=withdrawal_matrix,           # (T, M) or (n_sims, T, M) withdrawals\n    withdrawal_epsilon=0.05,       # 95% confidence for withdrawals\n    solver='CLARABEL',             # Solver: CLARABEL, ECOS, SCS\n    verbose=True,\n    max_iters=10000,\n    abstol=1e-7,\n    reltol=1e-6\n)\n</code></pre>"},{"location":"optimization/#withdrawal-support","title":"Withdrawal Support","text":"<p>Withdrawals \\(D\\) can be: - Deterministic: Shape <code>(T, M)</code> \u2014 same withdrawal across all scenarios - Stochastic: Shape <code>(n_sims, T, M)</code> \u2014 per-scenario withdrawals</p> <p>Withdrawal feasibility constraint (Conservative - Option 1): <pre><code>\u2119(W_t^m \u2265 D_t^m) \u2265 1 - withdrawal_epsilon\n</code></pre></p> <p>Ensures sufficient wealth before each withdrawal, without relying on contributions.</p> <p>Implementation: <pre><code># CVaR reformulation for withdrawal constraint\n# Shortfall: D_t - W_t (positive = cannot meet withdrawal)\nshortfall = D_tm - W_pre_withdrawal\n\n# CVaR epigraphic constraints\nz_wd &gt;= shortfall - gamma_wd\ngamma_wd + sum(z_wd) / (withdrawal_epsilon * n_sims) &lt;= 0\n</code></pre></p> <p>Since \\(D\\) is a parameter (not decision variable), convexity is preserved.</p>"},{"location":"optimization/#goalseeker-api","title":"GoalSeeker API","text":""},{"location":"optimization/#constructor_1","title":"Constructor","text":"<pre><code>from finopt.src.optimization import GoalSeeker\n\nseeker = GoalSeeker(\n    optimizer=optimizer,\n    T_max=120,       # Maximum search horizon\n    verbose=True\n)\n</code></pre>"},{"location":"optimization/#seek-method","title":"seek() Method","text":"<pre><code>from datetime import date\n\n# Generator functions for scenarios\ndef A_gen(T, n_sims, seed):\n    return model.income.contributions(T, n_sims=n_sims, seed=seed, output=\"array\")\n\ndef R_gen(T, n_sims, seed):\n    return model.returns.generate(T, n_sims=n_sims, seed=seed)\n\n# Optional: withdrawal generator\ndef D_gen(T, n_sims, seed):\n    # Example: $500K withdrawal at month 12 from account 0\n    D = np.zeros((T, M))\n    if T &gt; 12:\n        D[12, 0] = 500_000\n    return D\n\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=np.array([1e6, 0.5e6]),\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\",        # \"binary\" or \"linear\"\n    D_generator=D_gen,             # Optional withdrawals\n    withdrawal_epsilon=0.05,       # 95% confidence\n    solver='CLARABEL',\n    verbose=True\n)\n</code></pre>"},{"location":"optimization/#search-strategies","title":"Search Strategies","text":""},{"location":"optimization/#linear-search-safe-slower","title":"Linear Search (Safe, Slower)","text":"<p>Algorithm: <pre><code>X_prev = None\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(T, A, R, initial_wealth, goal_set, D, X_init=X_prev)\n    if result.feasible:\n        return result  # Found T*\n    # Warm start: extend policy\n    if result.X is not None:\n        X_prev = np.vstack([result.X, result.X[-1:, :]])\n</code></pre></p> <p>Complexity: \\(O(T^* - T_{\\text{start}})\\) iterations</p> <p>Properties: - Always finds true \\(T^*\\) if feasible - No assumptions required - Warm start accelerates convergence</p>"},{"location":"optimization/#binary-search-faster-assumes-monotonicity","title":"Binary Search (Faster, Assumes Monotonicity)","text":"<p>Algorithm: <pre><code>left, right = T_start, T_max\nbest_result = None\n\nwhile left &lt; right:\n    mid = (left + right) // 2\n    result = optimizer.solve(mid, ...)\n\n    if result.feasible:\n        best_result = result\n        right = mid  # Search lower half\n    else:\n        left = mid + 1  # Search upper half\n\nreturn best_result\n</code></pre></p> <p>Complexity: \\(O(\\log(T_{\\max} - T_{\\text{start}}))\\) iterations</p> <p>Assumption: Monotonicity \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p> <p>When to use: - Typical financial planning scenarios (safe) - Contribution schedules are non-decreasing or stable - Goal structure is well-behaved</p> <p>When to avoid: - Contributions have sudden drops - Pathological goal configurations - Safety-critical applications \u2192 use linear search</p>"},{"location":"optimization/#solver-configuration","title":"Solver Configuration","text":""},{"location":"optimization/#available-solvers","title":"Available Solvers","text":"Solver Type Speed Stability Default CLARABEL Interior-point Balanced Good \u2713 ECOS Interior-point (LP/SOCP) Fast Good for well-conditioned SCS First-order conic Moderate Handles ill-conditioned"},{"location":"optimization/#solver-options-mapping","title":"Solver Options Mapping","text":"<p>The API uses standard option names that are mapped to solver-specific options:</p> <pre><code># Standard options\nresult = optimizer.solve(\n    ...,\n    solver='CLARABEL',\n    max_iters=10000,\n    abstol=1e-7,\n    reltol=1e-6\n)\n</code></pre> <p>Option mapping:</p> Standard ECOS SCS CLARABEL <code>max_iters</code> <code>max_iters</code> <code>max_iters</code> <code>max_iter</code> <code>abstol</code> <code>abstol</code> <code>eps_abs</code> <code>tol_gap_abs</code> <code>reltol</code> <code>reltol</code> <code>eps_rel</code> <code>tol_gap_rel</code>"},{"location":"optimization/#complexity-analysis","title":"Complexity Analysis","text":"<p>Variables: \\(T \\cdot M + G \\cdot (1 + N) + W \\cdot (1 + N)\\) - \\(T \\cdot M\\) allocations \\(X\\) - \\(G\\) VaR levels \\(\\gamma_g\\) + \\(G \\cdot N\\) excess shortfalls \\(z_g^i\\) - \\(W\\) withdrawal constraints (if applicable)</p> <p>Example: \\(T=24, M=3, G=3, N=300, W=2\\) - Variables: \\(72 + 903 + 602 = 1577\\) - Solve time: 30-100ms (CLARABEL)</p>"},{"location":"optimization/#optimizationresult","title":"OptimizationResult","text":""},{"location":"optimization/#attributes","title":"Attributes","text":"<pre><code>@dataclass(frozen=True)\nclass OptimizationResult:\n    X: np.ndarray              # Optimal allocation policy (T, M)\n    T: int                     # Horizon\n    objective_value: float     # f(X*)\n    feasible: bool             # All goals satisfied?\n    goals: List[...]           # Original goal specs\n    goal_set: GoalSet          # Validated collection\n    solve_time: float          # Solver time (seconds)\n    n_iterations: Optional[int]\n    diagnostics: Optional[dict]\n</code></pre>"},{"location":"optimization/#methods","title":"Methods","text":"<p>summary() \u2014 Human-readable output: <pre><code>print(result.summary())\n# OptimizationResult(\n#   Status: \u2713 Feasible\n#   Horizon: T=24 months\n#   Objective: 11234567.89\n#   Goals: 3 (1 intermediate, 2 terminal)\n#   Solve time: 0.342s\n#   Iterations: N/A\n# )\n</code></pre></p> <p>validate_goals(result) \u2014 Post-simulation validation: <pre><code>sim_result = model.simulate(T=result.T, X=result.X, n_sims=1000, seed=999)\nstatus = result.validate_goals(sim_result)\n\nfor goal, metrics in status.items():\n    print(f\"{goal.account}: {metrics['violation_rate']:.2%} violations\")\n</code></pre></p> <p>is_valid_allocation(tol) \u2014 Check simplex constraints: <pre><code>if not result.is_valid_allocation(tol=1e-6):\n    print(\"Warning: allocation violates simplex constraints\")\n</code></pre></p>"},{"location":"optimization/#diagnostics-and-debugging","title":"Diagnostics and Debugging","text":""},{"location":"optimization/#verbose-output","title":"Verbose Output","text":"<p>Enable <code>verbose=True</code> for detailed solver information:</p> <pre><code>[CVXPY Solution]\n  Status: optimal\n  Objective: 21543678.92\n  Solve time: 0.067s\n\n[Simplex Validation]\n  Max |\u03a3x_t - 1|: 3.45e-09\n  X bounds: [0.0000, 1.0000]\n\n[Goal Satisfaction Diagnostics]\n  Account 0 (Emergency):\n    Threshold:        5,500,000\n    Mean wealth:      6,234,567\n    Violation rate: 8.20% (max: 10.00%)\n    CVaR value:         -1234.56 (target: \u2264 0)\n\n[Withdrawal Feasibility Diagnostics]\n  Confidence level: 95% (\u03b5=5%)\n  \u2713 Period 11, Account 0 (Emergency Fund):\n    Withdrawal D_11:      500,000\n    Wealth W_11:        1,234,567\n    Violation rate:    2.30% (max: 5.00%)\n    CVaR value:          -5678.90 (target: \u2264 0)\n</code></pre>"},{"location":"optimization/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>1. Infeasible problem: <pre><code>Status: infeasible\n</code></pre> Solutions: - Increase <code>T_max</code> (extend planning horizon) - Reduce goal thresholds - Increase <code>epsilon</code> (lower confidence: 0.90 \u2192 0.85) - Increase contributions - Reduce withdrawal amounts</p> <p>2. Numerical instability: <pre><code>Max |\u03a3x_t - 1|: 1.23e-04\n\u26a0\ufe0f  Minor simplex violations detected\n</code></pre> Solutions: - Tighten solver tolerances: <code>abstol=1e-8, reltol=1e-7</code> - Switch solver: <code>CLARABEL</code> \u2192 <code>SCS</code> - Check for extreme returns</p> <p>3. Binary search failure: <pre><code>InfeasibleError: Binary search failed: T=87 infeasible\nMonotonicity assumption may be violated\n</code></pre> Solutions: - Switch to linear search: <code>search_method=\"linear\"</code> - Inspect contribution schedule for sudden drops - Verify goal configuration</p> <p>4. Withdrawal infeasibility: <pre><code>Withdrawal constraint violated at T=12\n</code></pre> Solutions: - Increase <code>withdrawal_epsilon</code> (0.05 \u2192 0.10) - Reduce withdrawal amount - Extend horizon to allow more accumulation - Prioritize liquidity in allocation</p>"},{"location":"optimization/#complete-examples","title":"Complete Examples","text":""},{"location":"optimization/#basic-optimization-with-goals","title":"Basic Optimization with Goals","text":"<pre><code>from datetime import date\nfrom finopt.src.optimization import CVaROptimizer, GoalSeeker\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\nfrom finopt.src.portfolio import Account\nimport numpy as np\n\n# Setup accounts\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05, initial_wealth=1_000_000),\n    Account.from_annual(\"Housing\", 0.07, 0.12, initial_wealth=500_000)\n]\ninitial_wealth = np.array([1_000_000, 500_000])\n\n# Define goals\ngoals = [\n    IntermediateGoal(date=date(2025, 7, 1), account=\"Emergency\",\n                     threshold=2_000_000, confidence=0.95),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\n# Create optimizer\noptimizer = CVaROptimizer(\n    n_accounts=len(accounts),\n    objective='balanced',\n    account_names=[a.name for a in accounts]\n)\n\n# Generator functions\ndef A_gen(T, n, s):\n    return np.full((n, T), 500_000)  # $500K/month\n\ndef R_gen(T, n, s):\n    np.random.seed(s)\n    return np.random.normal(0.005, 0.02, (n, T, 2))\n\n# Find minimum horizon\nseeker = GoalSeeker(optimizer, T_max=120, verbose=True)\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\"\n)\n\nprint(result.summary())\n</code></pre>"},{"location":"optimization/#optimization-with-withdrawals","title":"Optimization with Withdrawals","text":"<pre><code># Define withdrawal schedule\ndef D_gen(T, n_sims, seed):\n    \"\"\"$1M withdrawal from Housing account at month 24.\"\"\"\n    D = np.zeros((T, 2))\n    if T &gt; 24:\n        D[24, 1] = 1_000_000  # Account 1 = Housing\n    return D\n\n# Seek with withdrawals\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\",\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05  # 95% confidence\n)\n</code></pre>"},{"location":"optimization/#custom-objective-with-turnover-penalty","title":"Custom Objective with Turnover Penalty","text":"<pre><code>optimizer = CVaROptimizer(\n    n_accounts=3,\n    objective='risky_turnover',\n    objective_params={'lambda': 10000},  # Turnover penalty weight\n    account_names=[\"Emergency\", \"Housing\", \"Retirement\"]\n)\n</code></pre>"},{"location":"optimization/#theoretical-guarantees","title":"Theoretical Guarantees","text":"<p>Theorem 1 (Affine Wealth Representation): For any allocation policy \\(X \\in \\mathcal{X}_T\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter), enabling convex programming.</p> <p>Theorem 2 (CVaR Epigraphic Convexity): The epigraphic reformulation defines a convex constraint in \\(X\\) when \\(W(X)\\) is affine.</p> <p>Theorem 3 (Global Optimality): CVXPY interior-point solvers return global optimum for convex programs. No local minima exist.</p> <p>Theorem 4 (Bilevel Optimality): - Linear search: Finds true \\(T^*\\) if inner solver succeeds - Binary search: Finds \\(T^*\\) under monotonicity assumption \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p>"},{"location":"optimization/#exceptions","title":"Exceptions","text":"<p>The module raises <code>InfeasibleError</code> when no feasible solution is found:</p> <pre><code>from finopt.src.exceptions import InfeasibleError\n\ntry:\n    result = seeker.seek(...)\nexcept InfeasibleError as e:\n    print(f\"Optimization failed: {e}\")\n    # Suggestions: increase T_max, relax goals, increase contributions\n</code></pre>"},{"location":"optimization/#references","title":"References","text":"<p>Rockafellar, R.T. and Uryasev, S. (2000). Optimization of conditional value-at-risk. Journal of Risk, 2, 21-42.</p> <p>Markowitz, H. (1952). Portfolio Selection. The Journal of Finance, 7(1), 77-91.</p>"},{"location":"portfolio/","title":"<code>portfolio</code> \u2014 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Execute wealth dynamics under allocation policies, providing the mathematical foundation for optimization-driven portfolio construction. <code>portfolio.py</code> is the executor layer: it receives pre-generated contributions <code>A</code> (from <code>income.py</code>), returns <code>R</code> (from <code>returns.py</code>), and withdrawals <code>D</code>, applies allocation policy <code>X</code>, and computes wealth trajectories <code>W</code> via recursive or closed-form methods.</p>"},{"location":"portfolio/#why-a-dedicated-portfolio-module","title":"Why a dedicated portfolio module?","text":"<p>Financial optimization requires separating concerns: - <code>income.py</code> \u2192 cash availability (contributions <code>A</code>) - <code>returns.py</code> \u2192 stochastic return generation (<code>R</code>) - <code>portfolio.py</code> \u2192 wealth evolution given allocations (<code>W</code>) - <code>goals.py</code> \u2192 goal specifications - <code>optimization.py</code> \u2192 policy search</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to <code>ReturnModel</code>) - Optimization-ready: Affine wealth representation exposes analytical gradients - Batch processing: Vectorized Monte Carlo execution (no Python loops) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion - Withdrawal support: Handles scheduled or stochastic withdrawals <code>D</code></p>"},{"location":"portfolio/#design-principles","title":"Design principles","text":"<ol> <li>Separation of concerns</li> <li>Portfolio executes dynamics, does NOT generate stochastic processes</li> <li> <p>Returns/contributions/withdrawals are external inputs (not embedded models)</p> </li> <li> <p>Vectorized computation</p> </li> <li>Full batch processing: <code>(n_sims, T, M)</code> arrays without Python-level loops</li> <li> <p>Matches <code>income.py</code> pattern: <code>n_sims</code> parameter for Monte Carlo generation</p> </li> <li> <p>Optimization-first design</p> </li> <li>Affine wealth formula enables analytical gradients: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\)</li> <li> <p>Direct integration with convex solvers (CVXPY)</p> </li> <li> <p>Annual parameters by default</p> </li> <li>User-facing API uses intuitive annual returns/volatility</li> <li>Internal storage in monthly space (canonical form)</li> <li> <p>Properties provide dual temporal views without conversions</p> </li> <li> <p>Flexible naming</p> </li> <li>Short <code>name</code> for goal specification (e.g., \"RN\", \"CC\")</li> <li>Optional <code>display_name</code> for plots (e.g., \"Risky Norris (Fintual)\")</li> <li><code>label</code> property returns display_name if set, otherwise name</li> </ol>"},{"location":"portfolio/#the-two-core-surfaces","title":"The two core surfaces","text":""},{"location":"portfolio/#1-account","title":"1) <code>Account</code>","text":"<p>Frozen dataclass metadata container for investment account with dual temporal parameter access and flexible naming.</p> <p>Parameters: - <code>name</code>: Short account identifier for goal references (e.g., \"RN\", \"CC\", \"SLV\") - <code>initial_wealth</code>: Starting balance \\(W_0^m\\) (non-negative) - <code>return_strategy</code>: dict with monthly parameters <code>{\"mu\": float, \"sigma\": float}</code> - <code>display_name</code>: Optional long descriptive name for plots (e.g., \"Risky Norris (Fintual)\")</p> <p>Constructor methods (recommended): <pre><code># With display_name (recommended for clarity)\nAccount.from_annual(\n    name=\"RN\",\n    annual_return=0.12,\n    annual_volatility=0.15,\n    initial_wealth=0.0,\n    display_name=\"Risky Norris (Fintual)\"\n)\n\n# Without display_name (backward compatible)\nAccount.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05)\n\n# From monthly parameters (advanced)\nAccount.from_monthly(\"TAC\", monthly_mu=0.0058, monthly_sigma=0.0347)\n</code></pre></p> <p>Properties: - <code>label</code>: Display name for plots (returns <code>display_name</code> if set, otherwise <code>name</code>) - <code>monthly_params</code>: Canonical storage format <code>{\"mu\": float, \"sigma\": float}</code> - <code>annual_params</code>: User-friendly view <code>{\"return\": float, \"volatility\": float}</code></p> <p>Parameter conversion: $$ \\begin{aligned} \\mu_{\\text{monthly}} &amp;= (1 + r_{\\text{annual}})^{1/12} - 1 \\quad \\text{[geometric compounding]} \\ \\sigma_{\\text{monthly}} &amp;= \\frac{\\sigma_{\\text{annual}}}{\\sqrt{12}} \\quad \\text{[time scaling]} \\end{aligned} $$</p> <p>Example with display_name: <pre><code># Short name for goal specification\nrisky = Account.from_annual(\"RN\", annual_return=0.12, annual_volatility=0.15,\n                            display_name=\"Risky Norris (Fintual)\")\n\nprint(risky.name)   # 'RN' - used in goals\nprint(risky.label)  # 'Risky Norris (Fintual)' - shown in plots\n\n# Goal uses short name\ngoal = TerminalGoal(account=\"RN\", threshold=5_000_000, confidence=0.8)\n</code></pre></p>"},{"location":"portfolio/#2-portfolio","title":"2) <code>Portfolio</code>","text":"<p>Multi-account wealth dynamics executor with allocation policy and withdrawal support.</p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects (metadata only, no return models)</p> <p>Properties: - <code>M</code>: Number of accounts - <code>account_names</code>: List of account names - <code>initial_wealth_vector</code>: Initial wealth array <code>W0</code> from accounts</p> <p>Method signature: <pre><code>def simulate(\n    self,\n    A: np.ndarray,      # Contributions: (T,) or (n_sims, T)\n    R: np.ndarray,      # Returns: (n_sims, T, M)\n    X: np.ndarray,      # Allocations: (T, M)\n    D: np.ndarray = None,  # Withdrawals: (T, M) or (n_sims, T, M)\n    method: Literal[\"recursive\", \"affine\"] = \"recursive\",\n    initial_wealth: np.ndarray = None  # Override W0\n) -&gt; dict\n</code></pre></p> <p>Core wealth dynamics (with withdrawals): $$ W_{t+1}^m = \\big(W_t^m + A_t^m - D_t^m\\big)(1 + R_t^m) $$ where: - \\(A_t^m = x_t^m \\cdot A_t\\) (allocated contribution) - \\(D_t^m\\) = withdrawal from account \\(m\\) at time \\(t\\) - \\(\\sum_{m=1}^M x_t^m = 1\\), \\(x_t^m \\geq 0\\) (budget constraint)</p> <p>Returns: <pre><code>{\n    \"wealth\": np.ndarray,        # (n_sims, T+1, M)\n    \"total_wealth\": np.ndarray   # (n_sims, T+1)\n}\n</code></pre></p> <p>Computation methods:</p> Method Default Time Memory Use Case <code>\"recursive\"</code> \u2713 \\(O(n \\cdot T \\cdot M)\\) \\(O(n \\cdot T \\cdot M)\\) Simulation, large T <code>\"affine\"</code> \\(O(T^2 \\cdot M \\cdot n)\\) \\(O(n \\cdot T^2 \\cdot M)\\) Optimization, gradients"},{"location":"portfolio/#withdrawal-support","title":"Withdrawal Support","text":"<p>Withdrawals <code>D</code> can be provided as: - Deterministic: Shape <code>(T, M)</code> \u2014 same withdrawal schedule across all scenarios - Stochastic: Shape <code>(n_sims, T, M)</code> \u2014 per-scenario withdrawals - None: No withdrawals (default)</p> <p>Example: <pre><code># Deterministic: $500K from Housing account at month 12\nD = np.zeros((T, M))\nD[12, 1] = 500_000  # Account 1 = Housing\n\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre></p> <p>In optimization: Withdrawals are treated as parameters (not decision variables), preserving convexity: $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s x_s^m - D_s^m\\big) F_{s,t}^m $$</p>"},{"location":"portfolio/#affine-wealth-representation","title":"Affine wealth representation","text":""},{"location":"portfolio/#closed-form-formula","title":"Closed-form formula","text":"<p>The recursive dynamics admit a closed-form solution:</p> \\[ \\boxed{ W_t^m(X) = W_0^m \\cdot F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\, x_s^m - D_s^m\\big) \\, F_{s,t}^m } \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Convention: \\(F_{s,s}^m = 1\\) (no accumulation over empty interval).</p>"},{"location":"portfolio/#mathematical-properties","title":"Mathematical properties","text":"<ol> <li> <p>Affine in \\(X\\):    Since \\(D\\) is a parameter (not decision variable), wealth remains affine in \\(X\\):    $$    W_t^m(\\alpha X + \\beta Y) = \\alpha W_t^m(X) + \\beta W_t^m(Y) + \\text{const}    $$</p> </li> <li> <p>Analytical gradient:    $$    \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s \\, F_{s,t}^m, \\quad s &lt; t    $$    Enables gradient-based optimization without numerical differentiation.</p> </li> <li> <p>Monotonicity:    If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m\\) is strictly increasing in \\(x_s^m\\).</p> </li> </ol>"},{"location":"portfolio/#accumulation-factors-computation","title":"Accumulation factors computation","text":"<p>Method signature: <pre><code>def compute_accumulation_factors(self, R: np.ndarray) -&gt; np.ndarray\n</code></pre></p> <p>Input: Returns matrix <code>R</code> of shape <code>(n_sims, T, M)</code> Output: Factors tensor <code>F</code> of shape <code>(n_sims, T+1, T+1, M)</code></p> <p>Memory estimates: - <code>n_sims=500, T=24, M=2</code>: ~115 MB - <code>n_sims=500, T=120, M=5</code>: ~14 GB - <code>n_sims=1000, T=240, M=10</code>: ~221 GB (infeasible)</p> <p>For \\(T &gt; 100\\), consider: - Using <code>method=\"recursive\"</code> (no \\(F\\) precomputation) - Batching simulations (chunking <code>n_sims</code>) - On-the-fly gradient computation</p>"},{"location":"portfolio/#initial-wealth-override","title":"Initial Wealth Override","text":"<p>The <code>initial_wealth</code> parameter allows overriding the initial wealth vector without creating temporary Account objects:</p> <pre><code># Accounts have initial_wealth=0, but optimization needs non-zero W0\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05, initial_wealth=0),\n    Account.from_annual(\"Housing\", 0.07, 0.12, initial_wealth=0)\n]\nportfolio = Portfolio(accounts)\n\n# Override W0 for optimization scenario\nW0_scenario = np.array([5_000_000, 2_000_000])\nresult = portfolio.simulate(A=A, R=R, X=X, initial_wealth=W0_scenario)\n\n# Verify override\nassert np.allclose(result[\"wealth\"][:, 0, :], W0_scenario)\n</code></pre>"},{"location":"portfolio/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"portfolio/#workflow","title":"Workflow","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.returns import ReturnModel\nfrom finopt.src.income import IncomeModel, FixedIncome\n\n# 1. Define accounts (annual parameters + display names)\naccounts = [\n    Account.from_annual(\"EM\", annual_return=0.04, annual_volatility=0.05,\n                        display_name=\"Emergency Fund\"),\n    Account.from_annual(\"HS\", annual_return=0.07, annual_volatility=0.12,\n                        display_name=\"Housing Savings\")\n]\n\n# 2. Create portfolio executor\nportfolio = Portfolio(accounts)\n\n# 3. Generate stochastic inputs externally\nincome = IncomeModel(fixed=FixedIncome(base=1_400_000, annual_growth=0.03))\nreturns = ReturnModel(accounts, default_correlation=np.eye(2))\n\nT, n_sims = 24, 500\nA = income.contributions(T, start=date(2025, 1, 1), n_sims=n_sims)  # (500, 24)\nR = returns.generate(T, n_sims=n_sims, seed=42)                      # (500, 24, 2)\n\n# 4. Define allocation policy\nX = np.tile([0.6, 0.4], (T, 1))  # 60-40 split\n\n# 5. Execute wealth dynamics (with optional withdrawals)\nD = np.zeros((T, 2))\nD[12, 0] = 500_000  # $500K withdrawal from Emergency at month 12\n\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\nW = result[\"wealth\"]              # (500, 25, 2)\nW_total = result[\"total_wealth\"]  # (500, 25)\n\n# 6. Visualize with goals\nfrom finopt.src.goals import TerminalGoal, IntermediateGoal\n\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"EM\",\n                     threshold=5_000_000, confidence=0.95),\n    TerminalGoal(account=\"HS\", threshold=20_000_000, confidence=0.90)\n]\n\nportfolio.plot(result=result, X=X, start=date(2025, 1, 1), goals=goals)\n</code></pre>"},{"location":"portfolio/#data-flow","title":"Data flow","text":"<pre><code>income.py          returns.py\n    \u2193                  \u2193\n    A                  R          (external generation)\n    \u2193                  \u2193\n    \u2514\u2500\u2500\u25ba portfolio.simulate(A, R, X, D) \u2500\u2500\u25ba W\n                       \u2191        \u2191\n                       X        D    (from user or optimizer)\n</code></pre>"},{"location":"portfolio/#visualization","title":"Visualization","text":"<p>Method signature: <pre><code>def plot(\n    self,\n    result: dict,           # from simulate()\n    X: np.ndarray,          # allocation policy\n    start: date = None,     # calendar start date\n    goals: list = None,     # Goal objects to visualize\n    figsize: tuple = (16, 10),\n    title: str = None,\n    save_path: str = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.05,\n    colors: dict = None,\n    hist_bins: int = 30,\n    hist_color: str = 'mediumseagreen'\n)\n</code></pre></p> <p>Panel layout: 1. Top-left: Wealth per account (time series with Monte Carlo trajectories + goal markers) 2. Top-right: Total portfolio wealth + lateral histogram of final wealth distribution 3. Bottom-left: Portfolio composition (stacked area chart) 4. Bottom-right: Allocation policy (stacked bar chart)</p> <p>Goal visualization: - TerminalGoal: Horizontal dashed line at threshold across entire horizon - IntermediateGoal: Dotted line up to goal month with diamond marker</p> <p>Calendar-aware x-axis: When <code>start</code> is provided, the x-axis shows calendar dates instead of month indices.</p>"},{"location":"portfolio/#usage-patterns","title":"Usage patterns","text":""},{"location":"portfolio/#a-basic-simulation-deterministic-contributions","title":"A) Basic simulation (deterministic contributions)","text":"<pre><code>A = np.full(24, 100_000.0)                      # (24,)\nR = returns.generate(T=24, n_sims=500, seed=42) # (500, 24, 2)\nX = np.tile([0.5, 0.5], (24, 1))                # equal split\n\nresult = portfolio.simulate(A, R, X)\nW = result[\"wealth\"]  # (500, 25, 2)\n</code></pre>"},{"location":"portfolio/#b-stochastic-contributions-returns","title":"B) Stochastic contributions + returns","text":"<pre><code>A = income.contributions(24, start=date(2025, 1, 1), n_sims=500)  # (500, 24)\nR = returns.generate(T=24, n_sims=500, seed=42)                    # (500, 24, 2)\nX = np.tile([0.7, 0.3], (24, 1))\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#c-with-withdrawals","title":"C) With withdrawals","text":"<pre><code># $1M withdrawal from Housing at month 18\nD = np.zeros((T, 2))\nD[18, 1] = 1_000_000\n\nresult = portfolio.simulate(A, R, X, D=D)\n</code></pre>"},{"location":"portfolio/#d-time-varying-allocation-policy-glide-path","title":"D) Time-varying allocation policy (glide path)","text":"<pre><code>T = 60\nequity_fractions = np.linspace(0.8, 0.4, T)\nX = np.column_stack([equity_fractions, 1 - equity_fractions])  # (60, 2)\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#e-optimization-ready-gradient-computation","title":"E) Optimization-ready gradient computation","text":"<pre><code># Compute accumulation factors once\nF = portfolio.compute_accumulation_factors(R)  # (n_sims, T+1, T+1, M)\n\n# Gradient of E[W_24^0] w.r.t. X[10, 0]\nt_goal, s_contrib, m_account = 24, 10, 0\nA_val = A[:, 10].mean() if A.ndim == 2 else A[10]\ngrad = A_val * F[:, s_contrib, t_goal, m_account].mean()\n</code></pre>"},{"location":"portfolio/#f-method-selection-heuristic","title":"F) Method selection heuristic","text":"<p>Use <code>method=\"recursive\"</code> (default) when: - Pure simulation (no optimization) - Large horizons (\\(T &gt; 100\\)) - Memory-constrained environments - No need for gradients</p> <p>Use <code>method=\"affine\"</code> when: - Integrating with optimizer - Need analytical gradients - Moderate horizons (\\(T \\leq 100\\)) - Sufficient RAM for \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) storage</p>"},{"location":"portfolio/#exceptions","title":"Exceptions","text":"<p>The module raises <code>AllocationConstraintError</code> when allocation policy violates constraints:</p> <pre><code>from finopt.src.exceptions import AllocationConstraintError\n\ntry:\n    result = portfolio.simulate(A, R, X)\nexcept AllocationConstraintError as e:\n    print(f\"Invalid allocation: {e}\")\n    # Fix: ensure X[t, :].sum() == 1 and X &gt;= 0\n</code></pre>"},{"location":"portfolio/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\), return realization \\(\\{R_t^m\\}\\), and withdrawal schedule \\(\\{D_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} (A_s x_s^m - D_s^m) F_{s,t}^m $$ is affine in \\(X\\) (since \\(D\\) is a parameter).</p> <p>Corollary 1 (Linear Constraints): If goals are specified as \\(W_t^m(X) \\geq b_t^m\\) (deterministic), the feasible allocation set is a convex polytope.</p> <p>Proposition 2 (Gradient): The sensitivity of wealth to allocation at month \\(s\\) is: $$ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t $$</p> <p>Corollary 2 (Monotonicity): If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m(X)\\) is strictly increasing in \\(x_s^m\\).</p> <p>Proposition 3 (Withdrawal Independence): Withdrawals \\(D\\) do not affect gradients \\(\\frac{\\partial W_t^m}{\\partial x_s^m}\\) since they are parameters, not decision variables. This preserves convexity for CVaR optimization.</p>"},{"location":"returns/","title":"<code>returns</code> \u2014 Stochastic Return Generation for FinOpt","text":"<p>Purpose: Generate correlated stochastic returns under lognormal assumptions, providing the probabilistic foundation for Monte Carlo simulation and optimization under uncertainty. <code>returns.py</code> is the stochastic engine: it consumes account metadata (from <code>portfolio.py</code>) and produces vectorized return samples that drive wealth dynamics in <code>portfolio.simulate()</code>.</p>"},{"location":"returns/#why-a-dedicated-returns-module","title":"Why a dedicated returns module?","text":"<p>Financial planning under uncertainty requires explicit stochastic modeling: - <code>income.py</code> \u2192 cash flow uncertainty (seasonal + noise) - <code>returns.py</code> \u2192 market return uncertainty (correlated assets) - <code>portfolio.py</code> \u2192 wealth evolution executor - <code>optimization.py</code> \u2192 policy search under constraints</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to ReturnModel) - Correlation modeling: Cross-sectional dependence between accounts - Lognormal guarantee: \\(R_t &gt; -1\\) (no catastrophic losses) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion - Flexible correlation: Matrix or group-based specification</p>"},{"location":"returns/#mathematical-framework","title":"Mathematical framework","text":""},{"location":"returns/#lognormal-return-model","title":"Lognormal return model","text":"<p>Gross returns follow a correlated lognormal distribution:</p> \\[ 1 + R_t^m \\sim \\text{LogNormal}(\\mu_{\\text{log}}^m, \\Sigma) \\] <p>where the covariance matrix is constructed as:</p> \\[ \\Sigma = D \\rho D \\] <p>with: - \\(D = \\text{diag}(\\sigma_{\\text{log}}^1, \\ldots, \\sigma_{\\text{log}}^M)\\) (log-volatilities) - \\(\\rho \\in \\mathbb{R}^{M \\times M}\\) (correlation matrix, symmetric PSD with diagonal = 1)</p>"},{"location":"returns/#parameter-conversion","title":"Parameter conversion","text":"<p>Given arithmetic parameters \\((\\mu_{\\text{arith}}, \\sigma_{\\text{arith}})\\), convert to log-space:</p> \\[ \\begin{aligned} \\sigma_{\\text{log}} &amp;= \\sqrt{\\log\\left(1 + \\frac{\\sigma_{\\text{arith}}^2}{(1 + \\mu_{\\text{arith}})^2}\\right)} \\\\[8pt] \\mu_{\\text{log}} &amp;= \\log(1 + \\mu_{\\text{arith}}) - \\frac{\\sigma_{\\text{log}}^2}{2} \\end{aligned} \\] <p>Rationale: The adjustment \\(-\\sigma_{\\text{log}}^2/2\\) ensures: $$ \\mathbb{E}[1 + R_t^m] = \\exp\\left(\\mu_{\\text{log}} + \\frac{\\sigma_{\\text{log}}^2}{2}\\right) = 1 + \\mu_{\\text{arith}} $$</p>"},{"location":"returns/#generation-algorithm","title":"Generation algorithm","text":"<ol> <li>Sample log-returns: \\(Z \\sim \\mathcal{N}(\\mu_{\\text{log}}, \\Sigma)\\) with shape \\((n_{\\text{sims}}, T, M)\\)</li> <li>Transform to arithmetic: \\(R = \\exp(Z) - 1\\)</li> <li>Guarantee: \\(R_t^m &gt; -1\\) for all realizations (lognormal property)</li> </ol> <p>Complexity: \\(O(n_{\\text{sims}} \\cdot T \\cdot M^3)\\) dominated by Cholesky decomposition of \\(\\Sigma\\) (one-time cost).</p>"},{"location":"returns/#design-principles","title":"Design principles","text":"<ol> <li>Lognormal constraint</li> <li>Ensures \\(R_t &gt; -1\\) (realistic: no portfolio loses more than 100%)</li> <li> <p>Alternative to Normal (which allows \\(R_t &lt; -1\\)) or Bootstrap (limited to historical support)</p> </li> <li> <p>Correlation modeling</p> </li> <li>Default: uncorrelated accounts (\\(\\rho = I\\))</li> <li>Override per <code>generate()</code> call for sensitivity analysis</li> <li>Supports both matrix and group-based specification</li> <li> <p>Validation: symmetric, PSD, diagonal = 1</p> </li> <li> <p>Dual temporal representation</p> </li> <li>User-facing: annual parameters (intuitive)</li> <li>Internal: monthly log-space (canonical for sampling)</li> <li> <p>Properties provide views without conversion overhead</p> </li> <li> <p>No portfolio dependency</p> </li> <li>Consumes <code>Account</code> metadata (loose coupling)</li> <li>Never imports <code>Portfolio</code> (inverted dependency)</li> <li> <p>Testable in isolation</p> </li> <li> <p>IID assumption</p> </li> <li>Returns are independent across time (no GARCH/AR)</li> <li>Extension to time-series models is straightforward (see Extensions section)</li> </ol>"},{"location":"returns/#the-core-surface-returnmodel","title":"The core surface: <code>ReturnModel</code>","text":""},{"location":"returns/#constructor","title":"Constructor","text":"<p>Signature: <pre><code>ReturnModel(\n    accounts: List[Account],\n    default_correlation: Optional[Union[np.ndarray, Dict[Tuple[str, ...], float]]] = None\n)\n</code></pre></p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects with <code>return_strategy</code> metadata - <code>default_correlation</code>: Correlation specification (see below)</p> <p>Correlation specification options:</p> <ol> <li> <p>None (default): Identity matrix \\(\\rho = I_M\\) (uncorrelated)</p> </li> <li> <p>Matrix (np.ndarray): Full \\(M \\times M\\) correlation matrix    <pre><code>rho = np.array([[1.0, 0.5], [0.5, 1.0]])\nreturns = ReturnModel(accounts, default_correlation=rho)\n</code></pre></p> </li> <li> <p>Groups (Dict): Account groups with shared correlation    <pre><code>groups = {\n    (\"Emergency\", \"Housing\"): 0.3,        # Pair correlation\n    (\"Stock1\", \"Stock2\", \"Stock3\"): 0.6,  # Group correlation (all pairs)\n}\nreturns = ReturnModel(accounts, default_correlation=groups)\n</code></pre></p> </li> </ol> <p>Group semantics: - Tuple of 2 accounts: Single pair correlation - Tuple of 3+ accounts: All pairwise combinations get the same correlation - Unspecified pairs default to 0.0 - Diagonal always 1.0</p> <p>Initialization: 1. Validate correlation matrix (symmetric, PSD, diagonal = 1) 2. Extract arithmetic parameters from <code>accounts</code> 3. Precompute log-space parameters \\((\\mu_{\\text{log}}, \\sigma_{\\text{log}})\\)</p>"},{"location":"returns/#properties","title":"Properties","text":"<p>Dual temporal access:</p> <pre><code>@property\ndef monthly_params(self) -&gt; List[Dict[str, float]]\n    # [{\"mu\": float, \"sigma\": float}, ...]\n\n@property\ndef annual_params(self) -&gt; List[Dict[str, float]]\n    # [{\"return\": float, \"volatility\": float}, ...]\n</code></pre> <p>Legacy properties (backward compatible): <pre><code>@property\ndef mean_returns(self) -&gt; np.ndarray   # Expected arithmetic returns (monthly)\n\n@property\ndef volatilities(self) -&gt; np.ndarray   # Arithmetic volatilities (monthly)\n\n@property\ndef account_names(self) -&gt; List[str]   # Account names\n</code></pre></p> <p>Introspection: <pre><code>returns.params_table()  # DataFrame with monthly vs annual comparison\nprint(returns)          # Human-readable summary\n</code></pre></p> <p>Example output: <pre><code>ReturnModel(M=2, \u03c1=eye, accounts=['Emergency': 4.0%/year, 'Growth': 12.0%/year])\n</code></pre></p>"},{"location":"returns/#core-generation-method","title":"Core generation method","text":"<p>Signature: <pre><code>def generate(\n    self,\n    T: int,\n    n_sims: int = 1,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None\n) -&gt; np.ndarray\n</code></pre></p> <p>Parameters: - <code>T</code>: time horizon (months) - <code>n_sims</code>: number of Monte Carlo trajectories - <code>correlation</code>: override default correlation (sensitivity analysis) - <code>seed</code>: RNG seed for reproducibility</p> <p>Returns: - <code>R</code>: shape \\((n_{\\text{sims}}, T, M)\\) with \\(R_{i,t,m} &gt; -1\\) for all \\((i,t,m)\\)</p> <p>Raises: - <code>ValidationError</code>: If \\(T \\leq 0\\) - <code>ValueError</code>: If correlation matrix is invalid</p> <p>Algorithm: <pre><code># 1. Use correlation override or default\nrho = correlation if correlation is not None else self.default_correlation\n\n# 2. Build \u03a3 = D @ \u03c1 @ D\ncov = diag(\u03c3_log) @ rho @ diag(\u03c3_log)\n\n# 3. Sample log-returns\nrng = np.random.default_rng(seed)\nZ = rng.multivariate_normal(\u03bc_log, cov, size=(n_sims, T))  # (n_sims, T, M)\n\n# 4. Transform to arithmetic\nR = np.exp(Z) - 1.0\n</code></pre></p>"},{"location":"returns/#visualization-methods","title":"Visualization methods","text":""},{"location":"returns/#1-plot-distribution-analysis","title":"1) <code>plot()</code> \u2014 Distribution analysis","text":"<p>Signature: <pre><code>def plot(\n    self,\n    T: int = 32,\n    n_sims: int = 300,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,  # Calendar-aware x-axis\n    figsize: tuple = (16, 8),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.05\n)\n</code></pre></p> <p>Panel layout: 1. Top-left: Return trajectories (Monte Carlo paths) 2. Top-right: Marginal histograms (monthly distribution) 3. Bottom: Summary statistics table (monthly + annualized)</p> <p>Calendar-aware plotting: When <code>start</code> is provided, the x-axis shows calendar dates instead of numeric month indices: <pre><code>from datetime import date\nreturns.plot(T=24, n_sims=500, seed=42, start=date(2025, 1, 1))\n</code></pre></p>"},{"location":"returns/#2-plot_cumulative-wealth-evolution","title":"2) <code>plot_cumulative()</code> \u2014 Wealth evolution","text":"<p>Signature: <pre><code>def plot_cumulative(\n    self,\n    T: int = 24,\n    n_sims: int = 1000,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None,\n    start: Optional[date] = None,  # Calendar-aware x-axis\n    figsize: tuple = (14, 6),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.08,\n    show_percentiles: bool = True,\n    percentiles: tuple = (5, 95),\n    hist_bins: int = 40,\n    hist_color: str = 'red'\n)\n</code></pre></p> <p>Visualization: - Cumulative returns: \\(\\left(\\prod_{s=0}^{t-1}(1+R_s^m)\\right) - 1\\) - Lateral histogram of final returns - Percentile bands (default: 5th-95th)</p> <p>Modes: - M=1: Single plot with lateral histogram - M&gt;1: Separate subplot per account</p> <p>Theoretical validation (annotation box): - Simulation mean vs theoretical: \\(\\mathbb{E}[(1+\\mu)^T - 1]\\) - Jensen's inequality: sample mean &gt; theoretical (convexity)</p>"},{"location":"returns/#3-plot_horizon_analysis-time-diversification","title":"3) <code>plot_horizon_analysis()</code> \u2014 Time diversification","text":"<p>Signature: <pre><code>def plot_horizon_analysis(\n    self,\n    horizons: np.ndarray = np.array([1, 2, 3, 5, 10, 15, 20]),\n    figsize: tuple = (15, 5),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_table: bool = True\n)\n</code></pre></p> <p>Analysis across investment horizons (default: 1, 2, 3, 5, 10, 15, 20 years):</p> <p>Panel 1: Return vs Volatility - Expected return: \\((1+\\mu_{\\text{monthly}})^{T_{\\text{months}}} - 1\\) - Volatility: \\(\\sigma_{\\text{monthly}} \\sqrt{T_{\\text{months}}}\\) (time scaling) - Signal-to-noise ratio: \\(\\text{SNR} = \\mathbb{E}[R] / \\sigma[R]\\)</p> <p>Panel 2: Probability of Loss - \\(P(R_T &lt; 0)\\) via Normal approximation - Risk reduction annotation</p> <p>Printed table (when <code>show_table=True</code>): <pre><code>HORIZON ANALYSIS - Emergency\n================================================================================\nHorizon (years) | Expected Return (%) | Volatility (%) | P(Loss) (%) | SNR\n--------------------------------------------------------------------------------\n            1.0 |                 4.0 |            5.0 |        21.2 | 0.80\n            5.0 |                21.7 |           11.2 |         2.6 | 1.94\n           20.0 |               119.1 |           22.4 |         0.0 | 5.32\n================================================================================\n</code></pre></p>"},{"location":"returns/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"returns/#workflow","title":"Workflow","text":"<pre><code>from datetime import date\n\n# 1. Define accounts (annual parameters + display names)\naccounts = [\n    Account.from_annual(\"EM\", annual_return=0.04, annual_volatility=0.05,\n                        display_name=\"Emergency Fund\"),\n    Account.from_annual(\"HS\", annual_return=0.07, annual_volatility=0.12,\n                        display_name=\"Housing Savings\")\n]\n\n# 2. Create return generator with group correlation\ngroups = {(\"EM\", \"HS\"): 0.3}\nreturns = ReturnModel(accounts, default_correlation=groups)\n\n# 3. Generate samples\nR = returns.generate(T=24, n_sims=500, seed=42)  # (500, 24, 2)\n\n# 4. Feed to portfolio\nresult = portfolio.simulate(A=A, R=R, X=X)\n</code></pre>"},{"location":"returns/#data-flow","title":"Data flow","text":"<pre><code>Account metadata \u2192 ReturnModel \u2192 R \u2192 Portfolio.simulate() \u2192 W\n                        \u2191\n                   correlation\n                   (matrix or groups)\n</code></pre>"},{"location":"returns/#optimization-integration","title":"Optimization integration","text":"<p>Chance constraint evaluation: <pre><code># Generate scenario ensemble\nR_scenarios = returns.generate(T=24, n_sims=500, seed=42)\n\n# Evaluate constraint: P(W_T^m &gt;= b) &gt;= 1-\u03b5\nW = portfolio.simulate(A, R_scenarios, X)[\"wealth\"]\nW_T_m = W[:, -1, m]\nviolation_rate = (W_T_m &lt; b).mean()\nfeasible = (violation_rate &lt;= epsilon)\n</code></pre></p> <p>Sensitivity analysis: <pre><code># Test correlation impact\ncorrelations = [np.eye(2), np.array([[1, 0.5], [0.5, 1]])]\n\nfor rho in correlations:\n    R = returns.generate(T=24, n_sims=500, correlation=rho, seed=42)\n    result = portfolio.simulate(A, R, X)\n    print(f\"\u03c1={rho[0,1]}: mean W_T = {result['total_wealth'][:, -1].mean():,.0f}\")\n</code></pre></p>"},{"location":"returns/#usage-patterns","title":"Usage patterns","text":""},{"location":"returns/#a-basic-generation-uncorrelated","title":"A) Basic generation (uncorrelated)","text":"<pre><code>accounts = [\n    Account.from_annual(\"Conservative\", 0.04, 0.05),\n    Account.from_annual(\"Aggressive\", 0.12, 0.20)\n]\nreturns = ReturnModel(accounts)  # default: \u03c1 = I\n\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#b-correlated-accounts-matrix","title":"B) Correlated accounts (matrix)","text":"<pre><code>rho = np.array([\n    [1.00, 0.30],\n    [0.30, 1.00]\n])\n\nreturns = ReturnModel(accounts, default_correlation=rho)\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#c-correlated-accounts-groups","title":"C) Correlated accounts (groups)","text":"<pre><code># Define accounts\naccounts = [\n    Account.from_annual(\"Stock1\", 0.10, 0.18),\n    Account.from_annual(\"Stock2\", 0.12, 0.20),\n    Account.from_annual(\"Stock3\", 0.08, 0.15),\n    Account.from_annual(\"Bond\", 0.04, 0.05)\n]\n\n# Stocks are correlated with each other, bonds uncorrelated\ngroups = {\n    (\"Stock1\", \"Stock2\", \"Stock3\"): 0.6,  # All stock pairs get 0.6\n    # Bond not mentioned \u2192 0 correlation with everything\n}\n\nreturns = ReturnModel(accounts, default_correlation=groups)\n</code></pre>"},{"location":"returns/#d-correlation-override-sensitivity","title":"D) Correlation override (sensitivity)","text":"<pre><code># Default: \u03c1 = 0.3\nreturns = ReturnModel(accounts, default_correlation=rho_low)\n\n# Test high correlation without recreating model\nrho_high = np.array([[1.0, 0.8], [0.8, 1.0]])\nR_high = returns.generate(T=24, n_sims=500, correlation=rho_high, seed=42)\n</code></pre>"},{"location":"returns/#e-introspection-and-validation","title":"E) Introspection and validation","text":"<pre><code># Parameter table\nprint(returns.params_table())\n#            \u03bc (monthly)  \u03bc (annual)  \u03c3 (monthly)  \u03c3 (annual)\n# Emergency       0.0033       4.00%       0.0144       5.00%\n# Growth          0.0095      12.00%       0.0577      20.00%\n\n# Generate and validate\nR = returns.generate(T=240, n_sims=1000, seed=42)\n\n# Check lognormal property\nassert np.all(R &gt; -1.0)  # guaranteed by construction\n\n# Check empirical moments\nmu_empirical = R.mean(axis=(0, 1))  # average over sims and time\nmu_theoretical = returns.mean_returns  # from properties\nnp.testing.assert_allclose(mu_empirical, mu_theoretical, rtol=0.05)\n</code></pre>"},{"location":"returns/#f-calendar-aware-visualization","title":"F) Calendar-aware visualization","text":"<pre><code>from datetime import date\n\n# Plot with calendar dates on x-axis\nreturns.plot(T=24, n_sims=500, seed=42, start=date(2025, 1, 1))\nreturns.plot_cumulative(T=36, n_sims=500, seed=42, start=date(2025, 1, 1))\n</code></pre>"},{"location":"returns/#key-design-decisions","title":"Key design decisions","text":""},{"location":"returns/#1-lognormal-vs-normal-vs-bootstrap","title":"1. Lognormal vs Normal vs Bootstrap","text":"Method Pros Cons Lognormal (chosen) Guarantees \\(R_t &gt; -1\\), closed-form moments, positive skewness Assumes IID Normal Simpler mathematics Allows \\(R_t &lt; -1\\) (unrealistic) Bootstrap Matches historical distribution Limited to observed range"},{"location":"returns/#2-correlation-as-parameter-not-covariance","title":"2. Correlation as parameter (not covariance)","text":"<p>Rationale: - Correlation is scale-invariant (easier to specify) - Natural interpretation: \\(\\rho_{12} = 0.5\\) means \"moderate positive dependence\" - Covariance mixes magnitude and correlation (confusing)</p> <p>Construction: \\(\\Sigma = D\\rho D\\) separates scale (volatility) from dependence (correlation).</p>"},{"location":"returns/#3-group-based-correlation","title":"3. Group-based correlation","text":"<p>Rationale: - Financial intuition: \"these three stocks are correlated\" - Easier than building full matrix for many accounts - Automatic validation and symmetry</p>"},{"location":"returns/#4-precomputed-log-parameters","title":"4. Precomputed log-parameters","text":"<p>Performance: Conversion formulas involve <code>log</code>, <code>sqrt</code> (expensive). Precompute once in <code>__init__</code>.</p>"},{"location":"returns/#5-correlation-override-per-generate-call","title":"5. Correlation override per <code>generate()</code> call","text":"<p>Use case: Sensitivity analysis without recreating the model.</p>"},{"location":"returns/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Lognormal Moments): If \\(1 + R \\sim \\text{LogNormal}(\\mu_{\\log}, \\sigma_{\\log}^2)\\), then: $$ \\begin{aligned} \\mathbb{E}[R] &amp;= \\exp\\left(\\mu_{\\log} + \\frac{\\sigma_{\\log}^2}{2}\\right) - 1 \\[6pt] \\text{Var}[R] &amp;= \\left(\\exp(\\sigma_{\\log}^2) - 1\\right) \\exp(2\\mu_{\\log} + \\sigma_{\\log}^2) \\end{aligned} $$</p> <p>Proposition 2 (Return Bound): For lognormal returns, \\(R_t^m &gt; -1\\) almost surely.</p> <p>Proof: \\(1 + R_t^m = \\exp(Z_t^m)\\) where \\(Z_t^m \\in \\mathbb{R}\\). Since \\(\\exp(z) &gt; 0\\) for all \\(z \\in \\mathbb{R}\\), we have \\(R_t^m &gt; -1\\). \u220e</p> <p>Proposition 3 (Correlation Preservation): If \\((Z_1, Z_2)\\) are bivariate normal with correlation \\(\\rho\\), then \\(\\text{Corr}(\\exp(Z_1), \\exp(Z_2))\\) is a monotone increasing function of \\(\\rho\\).</p> <p>Proposition 4 (Time Diversification): For IID returns with \\(\\mu &gt; 0\\), the probability of loss decreases exponentially: $$ P\\left(\\prod_{t=1}^T (1+R_t) &lt; 1\\right) \\approx \\Phi\\left(-\\frac{\\mu \\sqrt{T}}{\\sigma}\\right) \\xrightarrow{T \\to \\infty} 0 $$</p>"},{"location":"returns/#extensions-temporal-dependence-roadmap","title":"Extensions: Temporal Dependence (Roadmap)","text":"<p>Note: This section describes potential future extensions. The current implementation only supports IID returns.</p>"},{"location":"returns/#motivation","title":"Motivation","text":"<p>The current IID assumption (\\(R_t^m \\perp R_s^m\\) for \\(t \\neq s\\)) is appropriate for monthly horizons and typical investment periods (\\(T = 24-60\\) months), where empirical autocorrelation is weak (\\(|\\rho_1| &lt; 0.1\\)). However, temporal structure becomes relevant for:</p> <ol> <li>Long horizons: \\(T &gt; 120\\) months where autocorrelation accumulates</li> <li>Momentum strategies: Assets with persistent trends (\\(\\phi &gt; 0.2\\))</li> <li>Volatility clustering: Crisis periods with persistent high volatility</li> </ol>"},{"location":"returns/#proposed-ar1-extension","title":"Proposed AR(1) Extension","text":"\\[ R_t^m = \\phi^m R_{t-1}^m + \\epsilon_t^m, \\quad \\epsilon_t^m \\sim \\text{LogNormal}(\\mu_\\epsilon, \\sigma_\\epsilon) \\] <p>Key insight: Preserves affine wealth representation because returns remain exogenous (not dependent on policy \\(X\\)).</p>"},{"location":"returns/#proposed-api","title":"Proposed API","text":"<pre><code>class ReturnModel:\n    def __init__(\n        self,\n        accounts: List[Account],\n        default_correlation: Optional[np.ndarray] = None,\n        temporal_model: Literal[\"iid\", \"ar1\", \"garch\"] = \"iid\",  # Future\n        temporal_params: Optional[Dict] = None  # {\"phi\": [...], ...}\n    ):\n        ...\n</code></pre> <p>Backward compatibility: Default <code>temporal_model=\"iid\"</code> preserves existing behavior.</p>"},{"location":"returns/#when-to-implement","title":"When to Implement","text":"<p>Signals that temporal structure matters: 1. Backtesting shows systematic bias 2. Long-horizon planning (\\(T &gt; 120\\) months) 3. Ljung-Box test rejects IID at 5% significance</p>"},{"location":"returns/#exceptions","title":"Exceptions","text":"<p>The module raises <code>ValidationError</code> for invalid parameters:</p> <pre><code>from finopt.src.exceptions import ValidationError\n\ntry:\n    R = returns.generate(T=-1, n_sims=500)\nexcept ValidationError as e:\n    print(f\"Invalid parameters: {e}\")\n</code></pre>"},{"location":"withdrawal/","title":"<code>withdrawal</code> \u2014 Scheduled Cash Outflows for FinOpt","text":"<p>Core idea: Model planned withdrawals (retiros) from investment accounts as parameters in the wealth dynamics equation. <code>withdrawal.py</code> captures cash outflows such as purchases, emergency expenses, or periodic distributions, producing arrays that downstream modules (<code>portfolio</code>, <code>optimization</code>) consume to adjust wealth trajectories.</p>"},{"location":"withdrawal/#why-a-dedicated-withdrawal-module","title":"Why a dedicated withdrawal module?","text":"<ul> <li>Explicit cash outflows: Withdrawals are first-class citizens, not hidden adjustments</li> <li>Optimization-compatible: Withdrawals are parameters (not decision variables), preserving convexity</li> <li>Calendar-aware: Dates are resolved to month offsets, matching <code>goals.py</code> and <code>income.py</code> patterns</li> <li>Dual mode: Supports both deterministic schedules and stochastic (uncertain) withdrawals</li> </ul>"},{"location":"withdrawal/#design-philosophy","title":"Design philosophy","text":"<ol> <li>Immutable specifications</li> <li><code>WithdrawalEvent</code> and <code>StochasticWithdrawal</code> are frozen dataclasses</li> <li> <p>Safe to hash, cache, and use as dict keys</p> </li> <li> <p>Calendar-aware resolution</p> </li> <li>Dates converted to month offsets via <code>resolve_month(start_date)</code></li> <li> <p>1-indexed months (matching <code>IntermediateGoal</code>)</p> </li> <li> <p>Pattern matching</p> </li> <li><code>WithdrawalEvent</code> \u2192 analogous to <code>IntermediateGoal</code> (fixed date, single amount)</li> <li><code>StochasticWithdrawal</code> \u2192 analogous to <code>VariableIncome</code> (base + sigma + floor/cap)</li> <li> <p><code>WithdrawalModel</code> \u2192 analogous to <code>IncomeModel</code> (facade combining deterministic + stochastic)</p> </li> <li> <p>Backward compatible</p> </li> <li><code>D=None</code> in <code>portfolio.simulate()</code> preserves existing behavior (no withdrawals)</li> </ol>"},{"location":"withdrawal/#mathematical-framework","title":"Mathematical Framework","text":""},{"location":"withdrawal/#wealth-dynamics-with-withdrawals","title":"Wealth dynamics with withdrawals","text":"\\[ W_{t+1}^m = \\big(W_t^m + A_t \\cdot x_t^m - D_t^m\\big)(1 + R_t^m) \\] <p>where: - \\(W_t^m\\) = wealth in account \\(m\\) at start of month \\(t\\) - \\(A_t\\) = total contribution at month \\(t\\) - \\(x_t^m\\) = allocation fraction to account \\(m\\) - \\(D_t^m\\) = withdrawal from account \\(m\\) during month \\(t\\) - \\(R_t^m\\) = return of account \\(m\\) during month \\(t\\)</p> <p>Timing convention: Withdrawal occurs at start of month (before returns applied). The withdrawn amount does not earn returns that month \u2014 this is the conservative assumption.</p>"},{"location":"withdrawal/#affine-representation-critical-for-optimization","title":"Affine representation (critical for optimization)","text":"\\[ \\boxed{ W_t^m(X) = W_0^m \\cdot F_{0,t}^m + \\sum_{s=0}^{t-1} \\big(A_s \\cdot x_s^m - D_s^m\\big) \\cdot F_{s,t}^m } \\] <p>Key insight: \\(D\\) is a parameter (not a decision variable), so wealth remains affine in \\(X\\), preserving convexity for CVaR optimization.</p>"},{"location":"withdrawal/#key-components","title":"Key components","text":""},{"location":"withdrawal/#1-withdrawalevent-frozen-dataclass","title":"1) <code>WithdrawalEvent</code> (frozen dataclass)","text":"<p>Single scheduled withdrawal from an investment account.</p> <pre><code>from datetime import date\nfrom finopt.src.withdrawal import WithdrawalEvent\n\nevent = WithdrawalEvent(\n    account=\"Conservador\",       # Account name or index\n    amount=400_000,              # Withdrawal amount (must be positive)\n    date=date(2025, 6, 1),       # Calendar date\n    description=\"Compra bicicleta\"  # Optional description\n)\n\n# Month resolution (1-indexed)\nmonth = event.resolve_month(date(2025, 1, 1))  # \u2192 6\n</code></pre> <p>Parameters: - <code>account</code>: Target account identifier (int index or str name) - <code>amount</code>: Withdrawal amount (must be positive) - <code>date</code>: Calendar date of the withdrawal - <code>description</code>: Optional human-readable description</p> <p>Month resolution: Same as <code>IntermediateGoal.resolve_month()</code> \u2014 returns 1-indexed month offset.</p>"},{"location":"withdrawal/#2-withdrawalschedule-dataclass","title":"2) <code>WithdrawalSchedule</code> (dataclass)","text":"<p>Collection of scheduled withdrawals for portfolio simulation.</p> <pre><code>from finopt.src.withdrawal import WithdrawalSchedule\n\nschedule = WithdrawalSchedule(events=[\n    WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1), \"Bicicleta\"),\n    WithdrawalEvent(\"Agresivo\", 2_000_000, date(2026, 12, 1), \"Vacaciones\")\n])\n\n# Convert to array for simulation\nD = schedule.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts\n)\n# D.shape \u2192 (36, 2)\n# D[5, 0] \u2192 400000.0 (June withdrawal from account 0)\n</code></pre> <p>Methods:</p> Method Returns Description <code>to_array(T, start_date, accounts)</code> <code>(T, M)</code> array Convert events to numpy array <code>total_by_account(accounts)</code> <code>Dict[str, float]</code> Sum of withdrawals per account <code>get_events_for_account(account)</code> <code>List[WithdrawalEvent]</code> Filter events by account <code>to_dict()</code> <code>dict</code> Serialize to dictionary <code>from_dict(payload)</code> <code>WithdrawalSchedule</code> Deserialize from dictionary <p>Behavior: - Events outside simulation horizon are ignored with a warning - Multiple events on the same month/account are summed - Empty events list is valid (returns zeros)</p>"},{"location":"withdrawal/#3-stochasticwithdrawal-frozen-dataclass","title":"3) <code>StochasticWithdrawal</code> (frozen dataclass)","text":"<p>Withdrawal with variability/uncertainty. Models withdrawals that have a base expected amount but may vary across scenarios (e.g., variable medical expenses, emergency costs).</p> <pre><code>from finopt.src.withdrawal import StochasticWithdrawal\n\nwithdrawal = StochasticWithdrawal(\n    account=\"Conservador\",\n    base_amount=300_000,      # Expected amount (mean)\n    sigma=50_000,             # Standard deviation\n    date=date(2025, 9, 1),    # Calendar date (or use month=9)\n    floor=200_000,            # Minimum amount\n    cap=500_000,              # Maximum amount\n    seed=42                   # Random seed\n)\n\n# Generate samples\nsamples = withdrawal.sample(n_sims=1000, start_date=date(2025, 1, 1))\n# samples.shape \u2192 (1000,)\n# All samples in [200_000, 500_000]\n</code></pre> <p>Parameters: - <code>account</code>: Target account identifier - <code>base_amount</code>: Expected withdrawal amount (mean of distribution) - <code>sigma</code>: Standard deviation - <code>month</code> or <code>date</code>: Timing (mutually exclusive, one required) - <code>floor</code>: Minimum withdrawal (default 0.0) - <code>cap</code>: Maximum withdrawal (None = no cap) - <code>seed</code>: Random seed for reproducibility</p> <p>Sampling: Truncated Gaussian distribution \\(\\mathcal{N}(\\text{base}, \\sigma^2)\\) clamped to \\([\\text{floor}, \\text{cap}]\\).</p>"},{"location":"withdrawal/#4-withdrawalmodel-dataclass","title":"4) <code>WithdrawalModel</code> (dataclass)","text":"<p>Unified facade combining scheduled and stochastic withdrawals.</p> <pre><code>from finopt.src.withdrawal import WithdrawalModel, WithdrawalSchedule, StochasticWithdrawal\n\nmodel = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1))\n    ]),\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=300_000,\n            sigma=50_000,\n            date=date(2025, 9, 1),\n            seed=42\n        )\n    ]\n)\n\n# Generate combined withdrawal array\nD = model.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts,\n    n_sims=500,\n    seed=42\n)\n# D.shape \u2192 (500, 36, 2)\n\n# Check expected totals\nmodel.total_expected(accounts)\n# \u2192 {'Conservador': 700000.0, 'Agresivo': 0.0}\n</code></pre> <p>Methods:</p> Method Returns Description <code>to_array(T, start_date, accounts, n_sims, seed)</code> <code>(n_sims, T, M)</code> array Combined withdrawal scenarios <code>total_expected(accounts)</code> <code>Dict[str, float]</code> Expected total per account <code>to_dict()</code> <code>dict</code> Serialize to dictionary <code>from_dict(payload)</code> <code>WithdrawalModel</code> Deserialize from dictionary <p>Behavior: - Scheduled withdrawals: broadcast to all scenarios (same values) - Stochastic withdrawals: independent sampling per scenario - Empty model returns zeros</p>"},{"location":"withdrawal/#month-resolution","title":"Month Resolution","text":"<p>Withdrawals use 1-indexed months, matching <code>IntermediateGoal</code>:</p> Date <code>resolve_month()</code> Array Index Interpretation January 1, 2025 (start) 1 0 Withdrawal during month 0 February 1, 2025 2 1 Withdrawal during month 1 June 1, 2025 6 5 Withdrawal during month 5 December 1, 2026 24 23 Withdrawal during month 23 <p>Example: <pre><code>event = WithdrawalEvent(\"Account\", 100_000, date(2025, 6, 1))\nmonth = event.resolve_month(date(2025, 1, 1))  # \u2192 6\n# Array index = month - 1 = 5\n# D[5, m] receives the withdrawal\n</code></pre></p>"},{"location":"withdrawal/#integration-with-portfolio","title":"Integration with Portfolio","text":""},{"location":"withdrawal/#basic-usage","title":"Basic usage","text":"<pre><code>from datetime import date\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.withdrawal import WithdrawalSchedule, WithdrawalEvent\n\n# Define accounts\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15)\n]\nportfolio = Portfolio(accounts)\n\n# Define withdrawals\nschedule = WithdrawalSchedule(events=[\n    WithdrawalEvent(\"Conservador\", 400_000, date(2025, 6, 1)),\n    WithdrawalEvent(\"Agresivo\", 2_000_000, date(2026, 12, 1))\n])\n\n# Convert to array\nD = schedule.to_array(T=36, start_date=date(2025, 1, 1), accounts=accounts)\n\n# Simulate with withdrawals\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre>"},{"location":"withdrawal/#with-stochastic-withdrawals","title":"With stochastic withdrawals","text":"<pre><code>from finopt.src.withdrawal import WithdrawalModel, StochasticWithdrawal\n\nmodel = WithdrawalModel(\n    scheduled=schedule,\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=200_000,\n            sigma=30_000,\n            date=date(2025, 9, 1),\n            floor=100_000,\n            cap=400_000\n        )\n    ]\n)\n\n# Generate stochastic withdrawal scenarios\nD = model.to_array(\n    T=36,\n    start_date=date(2025, 1, 1),\n    accounts=accounts,\n    n_sims=500,\n    seed=42\n)\n# D.shape \u2192 (500, 36, 2)\n\n# Simulate\nresult = portfolio.simulate(A=A, R=R, X=X, D=D)\n</code></pre>"},{"location":"withdrawal/#integration-with-optimization","title":"Integration with Optimization","text":""},{"location":"withdrawal/#cvaroptimizer-with-withdrawals","title":"CVaROptimizer with withdrawals","text":"<pre><code>from finopt.src.optimization import CVaROptimizer, GoalSeeker\n\noptimizer = CVaROptimizer(n_accounts=2, objective='balanced')\n\n# Define D_generator for GoalSeeker\ndef D_gen(T, n_sims, seed):\n    return model.to_array(\n        T=T,\n        start_date=date(2025, 1, 1),\n        accounts=accounts,\n        n_sims=n_sims,\n        seed=seed\n    )\n\nseeker = GoalSeeker(optimizer, T_max=120)\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05  # 95% confidence for withdrawal feasibility\n)\n</code></pre>"},{"location":"withdrawal/#withdrawal-feasibility-constraints","title":"Withdrawal feasibility constraints","text":"<p>The optimizer adds CVaR constraints to ensure sufficient wealth before each withdrawal:</p> \\[ \\mathbb{P}(W_t^m \\geq D_t^m) \\geq 1 - \\epsilon \\] <p>CVaR reformulation: $$ \\text{CVaR}_\\epsilon(D_t^m - W_t^m) \\leq 0 $$</p> <p>Default: <code>withdrawal_epsilon=0.05</code> (95% confidence of meeting withdrawals)</p>"},{"location":"withdrawal/#complete-example","title":"Complete Example","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.portfolio import Account, Portfolio\nfrom finopt.src.withdrawal import (\n    WithdrawalEvent, WithdrawalSchedule,\n    StochasticWithdrawal, WithdrawalModel\n)\nfrom finopt.src.goals import TerminalGoal\nfrom finopt.src.optimization import CVaROptimizer, GoalSeeker\n\n# 1. Define accounts\naccounts = [\n    Account.from_annual(\"Conservador\", 0.06, 0.08,\n                        display_name=\"Fondo Conservador\"),\n    Account.from_annual(\"Agresivo\", 0.12, 0.15,\n                        display_name=\"Fondo Agresivo\")\n]\n\n# 2. Define withdrawals\nwithdrawals = WithdrawalModel(\n    scheduled=WithdrawalSchedule(events=[\n        WithdrawalEvent(\n            account=\"Conservador\",\n            amount=400_000,\n            date=date(2025, 6, 1),\n            description=\"Compra bicicleta\"\n        ),\n        WithdrawalEvent(\n            account=\"Agresivo\",\n            amount=5_000_000,\n            date=date(2027, 1, 1),\n            description=\"Pie departamento\"\n        )\n    ]),\n    stochastic=[\n        StochasticWithdrawal(\n            account=\"Conservador\",\n            base_amount=200_000,\n            sigma=50_000,\n            date=date(2025, 12, 1),\n            floor=100_000,\n            cap=400_000\n        )\n    ]\n)\n\n# 3. Define goals\ngoals = [\n    TerminalGoal(account=\"Conservador\", threshold=10_000_000, confidence=0.90),\n    TerminalGoal(account=\"Agresivo\", threshold=30_000_000, confidence=0.85)\n]\n\n# 4. Setup optimization\nstart_date = date(2025, 1, 1)\ninitial_wealth = np.array([2_000_000, 5_000_000])\n\ndef A_gen(T, n_sims, seed):\n    return np.full((n_sims, T), 500_000)\n\ndef R_gen(T, n_sims, seed):\n    np.random.seed(seed)\n    return np.random.normal(0.005, 0.02, (n_sims, T, 2))\n\ndef D_gen(T, n_sims, seed):\n    return withdrawals.to_array(T, start_date, accounts, n_sims, seed)\n\n# 5. Optimize\noptimizer = CVaROptimizer(n_accounts=2, objective='balanced')\nseeker = GoalSeeker(optimizer, T_max=60, verbose=True)\n\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    initial_wealth=initial_wealth,\n    accounts=accounts,\n    start_date=start_date,\n    n_sims=500,\n    seed=42,\n    D_generator=D_gen,\n    withdrawal_epsilon=0.05\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(f\"Expected withdrawals: {withdrawals.total_expected(accounts)}\")\n</code></pre>"},{"location":"withdrawal/#serialization","title":"Serialization","text":"<p>Both <code>WithdrawalSchedule</code> and <code>WithdrawalModel</code> support JSON serialization:</p> <pre><code># Serialize\ndata = model.to_dict()\n# {\n#     \"scheduled\": {\"events\": [...]},\n#     \"stochastic\": [...]\n# }\n\n# Save to file\nimport json\nwith open(\"withdrawals.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\n# Load from file\nwith open(\"withdrawals.json\", \"r\") as f:\n    data = json.load(f)\nmodel = WithdrawalModel.from_dict(data)\n</code></pre>"},{"location":"withdrawal/#comparison-with-other-modules","title":"Comparison with Other Modules","text":"Module Concept Pattern <code>income.py</code> <code>FixedIncome</code> Deterministic contributions <code>withdrawal.py</code> <code>WithdrawalEvent</code> Deterministic withdrawals <code>income.py</code> <code>VariableIncome</code> Stochastic contributions <code>withdrawal.py</code> <code>StochasticWithdrawal</code> Stochastic withdrawals <code>income.py</code> <code>IncomeModel</code> Facade (fixed + variable) <code>withdrawal.py</code> <code>WithdrawalModel</code> Facade (scheduled + stochastic) <code>goals.py</code> <code>IntermediateGoal</code> Fixed-date constraint <code>withdrawal.py</code> <code>WithdrawalEvent</code> Fixed-date withdrawal"},{"location":"withdrawal/#api-summary","title":"API Summary","text":"Class Type Purpose <code>WithdrawalEvent</code> frozen dataclass Single scheduled withdrawal <code>WithdrawalSchedule</code> dataclass Collection of scheduled withdrawals <code>StochasticWithdrawal</code> frozen dataclass Withdrawal with uncertainty <code>WithdrawalModel</code> dataclass Unified facade <p>Key methods: - <code>resolve_month(start_date)</code> \u2014 Convert date to 1-indexed month offset - <code>to_array(T, start_date, accounts, ...)</code> \u2014 Generate numpy array for simulation - <code>total_by_account(accounts)</code> / <code>total_expected(accounts)</code> \u2014 Summarize withdrawals - <code>to_dict()</code> / <code>from_dict(payload)</code> \u2014 Serialization</p>"}]}