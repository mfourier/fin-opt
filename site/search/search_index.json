{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to FinOpt","text":"<p>FinOpt is a modular Python framework designed for intelligent financial planning. It combines stochastic simulation of income and investment returns with convex optimization to help users achieve their financial goals under uncertainty.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stochastic Income Modeling: Simulate fixed and variable income with growth, seasonality, and noise.</li> <li>Wealth Dynamics: Model the evolution of investment accounts using affine wealth representations.</li> <li>Goal-Oriented Optimization: Find the minimum time to achieve multiple financial goals (e.g., emergency funds, housing) with a specified level of confidence.</li> <li>Bilevel Optimization: Solve complex problems that minimize time while maximizing terminal wealth.</li> <li>Extensible Architecture: Modular design allows for custom return models, optimizers, and goal types.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To explore the technical details of the framework, check out the following sections:</p> <ul> <li>Technical Framework: An overview of the system architecture and design principles.</li> <li>Income Module: How we model cash flows.</li> <li>Portfolio Dynamics: The math behind wealth evolution.</li> <li>Optimization: Details on the chance-constrained optimization and SAA solvers.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre> <p>(Refer to the repository for more details on setup and usage)</p>"},{"location":"framework/","title":"FinOpt \u2014 Technical Framework","text":"<p>Tagline: Intelligent financial planning through stochastic simulation and convex optimization under uncertainty.</p> <p>This document describes the theoretical and technical framework of FinOpt, a modular system that connects user objectives (emergency funds, housing, retirement) with optimal investment strategies under stochastic income and returns via chance-constrained optimization.</p>"},{"location":"framework/#0-system-architecture","title":"0. System Architecture","text":"<p>FinOpt is composed of six core modules:</p> Module Purpose Key Abstractions <code>income.py</code> Cash flow modeling <code>FixedIncome</code>, <code>VariableIncome</code>, <code>IncomeModel</code> <code>portfolio.py</code> Wealth dynamics <code>Account</code>, <code>Portfolio</code> (affine wealth executor) <code>returns.py</code> Stochastic returns <code>ReturnModel</code> (correlated lognormal) <code>goals.py</code> Goal specification <code>IntermediateGoal</code>, <code>TerminalGoal</code>, <code>GoalSet</code> <code>optimization.py</code> Solvers <code>SAAOptimizer</code>, <code>CVaROptimizer</code>, <code>GoalSeeker</code> <code>model.py</code> Orchestration <code>FinancialModel</code> (unified facade) <p>Dependency graph: <pre><code>model.py (FinancialModel)\n    \u251c\u2500\u2192 income.py (IncomeModel)\n    \u251c\u2500\u2192 portfolio.py (Portfolio)\n    \u251c\u2500\u2192 returns.py (ReturnModel)\n    \u2514\u2500\u2192 optimization.py (GoalSeeker)\n            \u251c\u2500\u2192 goals.py (GoalSet)\n            \u2514\u2500\u2192 AllocationOptimizer (SAAOptimizer)\n</code></pre></p> <p>Design principles: - Loose coupling: Each module usable independently - Lazy imports: Optimization only loaded when needed (TYPE_CHECKING) - Separation of concerns: Portfolio executes dynamics, doesn't generate returns - Reproducibility: Explicit seed management with automatic propagation</p>"},{"location":"framework/#1-income-module","title":"1. Income Module","text":"<p>Total monthly income at time \\(t\\) is composed of fixed and variable parts:</p> \\[ Y_t = y_t^{\\text{fixed}} + Y_t^{\\text{variable}} \\]"},{"location":"framework/#11-fixed-income","title":"1.1 Fixed Income","text":"<p>The fixed component, \\(y_t^{\\text{fixed}}\\), reflects baseline salary subject to compounded annual growth \\(g\\) and scheduled raises \\(\\{(d_k, \\Delta_k)\\}\\):</p> \\[ y_t^{\\text{fixed}} = \\text{current\\_salary}(t) \\cdot (1+m)^{\\Delta t} \\] <p>where \\(m = (1 + g)^{1/12} - 1\\) is the monthly compounded rate, and \\(\\Delta t\\) represents time since the last raise.</p> <p>API: <pre><code>fixed = FixedIncome(\n    base=1_400_000,           # Current monthly salary\n    annual_growth=0.03,       # 3% annual raises\n    raises=[(12, 100_000)]    # +100k at month 12\n)\n</code></pre></p>"},{"location":"framework/#12-variable-income","title":"1.2 Variable Income","text":"<p>The variable component, \\(Y_t^{\\text{variable}}\\), models irregular income (freelance, bonuses) with:</p> <ul> <li>Seasonality: \\(s \\in \\mathbb{R}^{12}\\) (multiplicative monthly factors)</li> <li>Noise: \\(\\epsilon_t \\sim \\mathcal{N}(0, \\sigma^2)\\) (Gaussian shocks)</li> <li>Growth: same compounded rate \\(m\\) applied to base income</li> <li>Boundaries: optional floor and cap constraints</li> </ul> <p>The underlying stochastic projection:</p> \\[ \\tilde{Y}_t = \\max(\\text{floor},\\ \\mu_t (1 + \\epsilon_t)), \\quad \\text{where } \\mu_t = \\text{base} \\cdot (1 + m)^t \\cdot s_{(t \\bmod 12)} \\] <p>Then, guardrails:</p> \\[ Y_t^{\\text{variable}} = \\begin{cases} 0 &amp; \\text{if } \\tilde{Y}_t &lt; 0 \\\\ \\tilde{Y}_t &amp; \\text{if } 0 \\leq \\tilde{Y}_t \\leq \\text{cap} \\\\ \\text{cap} &amp; \\text{if } \\tilde{Y}_t &gt; \\text{cap} \\end{cases} \\] <p>API: <pre><code>variable = VariableIncome(\n    base=200_000,                   # Average monthly variable income\n    sigma=0.10,                     # 10% volatility\n    seasonality=[1.2, 0.8, ...],   # 12-month cycle\n    seed=42                         # Reproducibility\n)\n</code></pre></p>"},{"location":"framework/#13-contributions","title":"1.3 Contributions","text":"<p>A fraction of income is allocated monthly via calendar-rotating schedules:</p> \\[ A_t = \\alpha_{(t \\bmod 12)}^{f} \\cdot y_t^{\\text{fixed}} + \\alpha_{(t \\bmod 12)}^{v} \\cdot Y_t^{\\text{variable}} \\] <p>where \\(\\alpha^f, \\alpha^v \\in [0,1]^{12}\\) control fixed/variable contribution rates, rotated according to <code>start</code> date.</p> <p>API: <pre><code>income = IncomeModel(fixed=fixed, variable=variable)\nA = income.contributions(\n    months=24,\n    start=date(2025, 1, 1),\n    n_sims=500,\n    seed=42\n)  # \u2192 (500, 24) array\n</code></pre></p>"},{"location":"framework/#2-portfolio-dynamics","title":"2. Portfolio Dynamics","text":""},{"location":"framework/#21-wealth-evolution","title":"2.1 Wealth Evolution","text":"<p>Multiple accounts \\(m \\in \\mathcal{M} = \\{1,\\dots,M\\}\\) evolve via:</p> \\[ W_{t+1}^m = \\big(W_t^m + A_t x_t^m\\big)(1 + R_t^m) \\] <p>where: - \\(W_t^m\\) = wealth in account \\(m\\) at month \\(t\\) - \\(A_t x_t^m\\) = allocated contribution (\\(x_t^m\\) fraction of total contribution \\(A_t\\)) - \\(R_t^m\\) = stochastic return of account \\(m\\)</p> <p>API: <pre><code>accounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, \n                        annual_volatility=0.05, initial_wealth=0),\n    Account.from_annual(\"Housing\", annual_return=0.07, \n                        annual_volatility=0.12, initial_wealth=0)\n]\nportfolio = Portfolio(accounts)\n</code></pre></p>"},{"location":"framework/#22-allocation-policy","title":"2.2 Allocation Policy","text":"<p>Contributions allocated via decision variables \\(x_t^m \\in [0,1]\\) satisfying:</p> \\[ \\sum_{m=1}^M x_t^m = 1, \\quad x_t^m \\ge 0, \\quad \\forall t \\] <p>The allocation simplex at horizon \\(T\\) is:</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} :  \\begin{aligned} &amp; x_t^m \\ge 0 &amp;&amp; \\text{(non-negativity)} \\\\ &amp; \\sum_{m=1}^M x_t^m = 1 &amp;&amp; \\text{(budget constraint)} \\\\ &amp; \\forall t = 0, \\dots, T-1 \\end{aligned} \\right\\} \\] <p>representing all budget-feasible allocation policies (full contribution deployment each month).</p> <p>Geometric interpretation: \\(\\mathcal{X}_T\\) is the Cartesian product of \\(T\\) probability simplices: $$ \\mathcal{X}T = \\underbrace{\\Delta^{M-1} \\times \\cdots \\times \\Delta^{M-1}}{T \\text{ times}}, \\quad \\Delta^{M-1} = \\left{x \\in \\mathbb{R}+^M : \\sum{m=1}^M x^m = 1\\right} $$</p> <p>API: <pre><code>X = np.tile([0.6, 0.4], (T, 1))  # 60-40 split \u2208 \ud835\udcb3_T\n</code></pre></p>"},{"location":"framework/#23-affine-wealth-representation","title":"2.3 Affine Wealth Representation","text":"<p>Recursive wealth can be expressed in closed-form:</p> \\[ \\boxed{ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s \\, x_s^m \\, F_{s,t}^m } \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Key properties: 1. \\(W_t^m(X)\\) is affine in allocation policy \\(X\\) (linearity immediately visible) 2. Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) (analytical!) 3. Enables gradient-based convex optimization</p> <p>Implementation: <pre><code>result = portfolio.simulate(A=A, R=R, X=X, method=\"affine\")\nW = result[\"wealth\"]  # (n_sims, T+1, M)\n</code></pre></p>"},{"location":"framework/#3-goals-framework","title":"3. Goals Framework","text":""},{"location":"framework/#31-goal-types","title":"3.1 Goal Types","text":"<p>FinOpt supports two goal primitives:</p> <p>Intermediate Goal (fixed time): <pre><code>IntermediateGoal(\n    month=12,                    # Or date(2026, 1, 1)\n    account=\"Emergency\",\n    threshold=5_500_000,         # 5.5M CLP\n    confidence=0.90              # 90% probability\n)\n</code></pre></p> <p>Mathematical constraint: $$ \\mathbb{P}\\big(W_{t}^m \\ge b\\big) \\ge 1-\\varepsilon $$</p> <p>Terminal Goal (variable time): <pre><code>TerminalGoal(\n    account=\"Housing\",\n    threshold=20_000_000,        # 20M CLP\n    confidence=0.90\n)\n</code></pre></p> <p>Mathematical constraint: $$ \\mathbb{P}\\big(W_{T}^m \\ge b\\big) \\ge 1-\\varepsilon $$</p> <p>where \\(T\\) is the optimization horizon (decision variable).</p>"},{"location":"framework/#32-goal-set","title":"3.2 Goal Set","text":"<p>The goal set \\(\\mathcal{G}\\) is partitioned into:</p> \\[ \\mathcal{G} = \\mathcal{G}_{\\text{int}} \\cup \\mathcal{G}_{\\text{term}} \\] <p>where: - \\(\\mathcal{G}_{\\text{int}}\\): intermediate goals (constrain \\(T_{\\min}\\)) - \\(\\mathcal{G}_{\\text{term}}\\): terminal goals (determine \\(T^*\\))</p> <p>Properties:</p> <ol> <li> <p>Minimum horizon constraint:    $$    T \\geq T_{\\min} := \\max_{g \\in \\mathcal{G}_{\\text{int}}} t_g    $$</p> </li> <li> <p>Goal resolution: Month indices resolved via <code>start</code> date for calendar alignment</p> </li> <li> <p>Account mapping: Names \u2192 indices via <code>account_names</code> parameter</p> </li> </ol> <p>API: <pre><code>from datetime import date\n\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"Emergency\",\n                    threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\",\n                threshold=20_000_000, confidence=0.90)\n]\n\ngoal_set = GoalSet(goals, account_names=[\"Emergency\", \"Housing\"],\n                   start_date=date(2025, 1, 1))\n</code></pre></p>"},{"location":"framework/#33-horizon-estimation-heuristic","title":"3.3 Horizon Estimation Heuristic","text":"<p>For terminal-only goals (\\(\\mathcal{G}_{\\text{int}} = \\emptyset\\)), naive linear search starts at \\(T=1\\), wasting iterations. Instead, FinOpt uses a conservative heuristic:</p> \\[ T_{\\text{start}} = \\max_{g \\in \\mathcal{G}_{\\text{term}}} \\left\\lceil \\frac{b_g - W_0^m \\cdot (1 + \\mu)^{T_{\\min}}}{A_{\\text{avg}} \\cdot x_{\\min}^m \\cdot (1 + \\mu - \\sigma)} \\right\\rceil \\] <p>where: - \\(A_{\\text{avg}}\\): average monthly contribution (sampled) - \\(\\mu, \\sigma\\): expected return and volatility of account \\(m\\) - \\(x_{\\min}^m\\): minimum allocation fraction (conservative: 0.1) - Safety margin: multiply by 0.8 to start early</p> <p>Implementation: <code>GoalSet.estimate_minimum_horizon()</code></p>"},{"location":"framework/#4-optimization-framework","title":"4. Optimization Framework","text":""},{"location":"framework/#41-bilevel-problem","title":"4.1 Bilevel Problem","text":"<p>Find the minimum time \\(T^*\\) to achieve all goals while optimizing an objective \\(f(X)\\):</p> \\[ \\boxed{ \\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\max_{X \\in \\mathcal{F}_T} f(X) &gt; -\\infty } \\] <p>where the goal-feasible set at horizon \\(T\\) is:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\mathbb{P}\\big(W_t^m(X) \\ge b_t^m\\big) \\ge 1-\\varepsilon_t^m, \\; \\forall g \\in \\mathcal{G}_{\\text{int}}, \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\ge b^m\\big) \\ge 1-\\varepsilon^m, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\end{aligned} \\right\\} \\] <p>Equivalent decomposition:</p> <ul> <li>Outer problem: Find minimum horizon \\(T \\in [T_{\\text{start}}, T_{\\max}]\\) with non-empty feasible set</li> <li>Inner problem: For fixed \\(T\\), solve: $$ \\begin{aligned} \\max_{X \\in \\mathcal{X}_T} \\;\\; &amp; f(X) \\[0.5em] \\text{s.t.} \\;\\; &amp; X \\in \\mathcal{F}_T \\end{aligned} $$</li> </ul>"},{"location":"framework/#42-inner-problem-fixed-horizon","title":"4.2 Inner Problem (Fixed Horizon)","text":"<p>For given horizon \\(T\\), solve:</p> \\[ \\begin{aligned} \\max_{X \\in \\mathcal{X}_T} \\;\\; &amp; f(X) \\\\[0.5em] \\text{s.t.} \\;\\; &amp; \\mathbb{P}\\big(W_t^m(X) \\ge b_t^m\\big) \\ge 1-\\varepsilon_t^m, \\quad \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\ge b^m\\big) \\ge 1-\\varepsilon^m, \\quad \\forall g \\in \\mathcal{G}_{\\text{term}} \\end{aligned} \\] <p>Objective functions: - <code>\"terminal_wealth\"</code>: \\(f(X) = \\mathbb{E}\\big[\\sum_m W_T^m(X)\\big]\\) (default) - <code>\"low_turnover\"</code>: \\(f(X) = \\mathbb{E}[W_T] - \\lambda \\sum_{t,m} |x_{t+1,m} - x_t^m|\\) - <code>\"risk_adjusted\"</code>: \\(f(X) = \\mathbb{E}[W_T] - \\lambda \\cdot \\text{Std}(W_T)\\) - Custom: user-provided callable</p>"},{"location":"framework/#43-chance-constraint-reformulation","title":"4.3 Chance Constraint Reformulation","text":"<p>Challenge: Indicator function \\(\\mathbb{1}\\{W \\geq b\\}\\) is discontinuous.</p>"},{"location":"framework/#sample-average-approximation-saa","title":"Sample Average Approximation (SAA)","text":"<p>Discrete approximation with \\(N\\) scenarios \\(\\omega^{(i)}\\):</p> \\[ \\frac{1}{N}\\sum_{i=1}^N \\mathbb{1}\\{W_t^m(X; \\omega^{(i)}) \\ge b_t^m\\} \\ge 1-\\varepsilon_t^m \\] <p>Issue: Non-smooth, no gradient.</p>"},{"location":"framework/#sigmoid-smoothing-saaoptimizer","title":"Sigmoid Smoothing (SAAOptimizer)","text":"<p>Replace indicator with sigmoid \\(\\sigma(z) = 1/(1 + e^{-z})\\):</p> \\[ \\boxed{ \\frac{1}{N} \\sum_{i=1}^N \\sigma\\left(\\frac{W_t^m(X; \\omega^{(i)}) - b_t^m}{\\tau}\\right) \\ge 1-\\varepsilon_t^m } \\] <p>Properties: 1. Differentiability: \\(\\sigma'(z) = \\sigma(z)(1 - \\sigma(z))\\) \u2192 analytical gradient 2. Approximation quality: controlled by temperature \\(\\tau\\)    - Small \\(\\tau\\) (0.01): \\(\\sigma \\approx \\mathbb{1}\\) (sharp, harder to optimize)    - Large \\(\\tau\\) (1.0): \\(\\sigma \\approx 0.5\\) (smooth, loose approximation)    - Balanced \\(\\tau\\) (0.1): trade-off for practical optimization 3. Convexity: smoothed constraint is convex in \\(X\\) (via affine wealth)</p> <p>Gradient computation:</p> \\[ \\frac{\\partial}{\\partial x_s^m} \\left[\\frac{1}{N} \\sum_{i=1}^N \\sigma\\left(\\frac{W_t^m(X; \\omega^{(i)}) - b}{\\tau}\\right)\\right] = \\frac{1}{N\\tau} \\sum_{i=1}^N \\sigma'(z^{(i)}) \\cdot A_s^{(i)} \\cdot F_{s,t}^{m,(i)} \\] <p>where \\(z^{(i)} = (W_t^m(X; \\omega^{(i)}) - b)/\\tau\\).</p> <p>API: <pre><code>from finopt.src.optimization import SAAOptimizer\n\noptimizer = SAAOptimizer(\n    n_accounts=2,\n    tau=0.1,                      # Sigmoid temperature\n    objective=\"terminal_wealth\",\n    account_names=[\"Emergency\", \"Housing\"]\n)\n</code></pre></p>"},{"location":"framework/#cvar-reformulation-cvaroptimizer-stub","title":"CVaR Reformulation (CVaROptimizer - Stub)","text":"<p>Risk-adjusted objective via Conditional Value-at-Risk:</p> \\[ \\max \\; \\mathbb{E}[W_T] - \\lambda \\cdot \\text{CVaR}_{\\alpha}(-W_T) \\] <p>subject to goal constraints. Requires CVXPY for implementation.</p>"},{"location":"framework/#44-solution-strategy-goalseeker","title":"4.4 Solution Strategy (GoalSeeker)","text":"<p>Bilevel solver with linear search and warm start:</p> <pre><code>class GoalSeeker:\n    def seek(goals, A_generator, R_generator, W0, ...):\n        # Estimate intelligent starting horizon\n        T_start = estimate_horizon(goals, A_generator, W0)\n\n        X_prev = None  # Warm start\n        for T in range(T_start, T_max + 1):\n            # Generate scenarios for current horizon\n            A = A_generator(T, n_sims, seed)\n            R = R_generator(T, n_sims, seed+1)\n\n            # Solve inner problem\n            result = optimizer.solve(T, A, R, W0, goals, X_init=X_prev)\n\n            # Check feasibility (exact SAA validation)\n            if result.feasible:\n                return result  # Found T*\n\n            # Warm start: extend X for next iteration\n            X_prev = extend_policy(result.X)\n\n        raise ValueError(\"No feasible solution in [T_start, T_max]\")\n</code></pre> <p>Key features: 1. Intelligent start: Skips infeasible horizons via heuristic 2. Warm start: Extends previous \\(X\\) policy for faster convergence 3. Exact validation: Final feasibility check uses non-smoothed SAA</p> <p>API: <pre><code>from finopt.src.optimization import GoalSeeker\n\nseeker = GoalSeeker(optimizer, T_max=240, verbose=True)\nresult = seeker.seek(goals, A_generator, R_generator, W0, \n                    start_date=date(2025,1,1), n_sims=500, seed=42)\n</code></pre></p>"},{"location":"framework/#5-integration-financialmodel","title":"5. Integration: FinancialModel","text":""},{"location":"framework/#51-unified-facade","title":"5.1 Unified Facade","text":"<p><code>FinancialModel</code> orchestrates all components:</p> <pre><code>from finopt.src.model import FinancialModel\n\nmodel = FinancialModel(\n    income=income,              # IncomeModel\n    accounts=accounts,          # List[Account]\n    default_correlation=None,   # Return correlation matrix\n    enable_cache=True           # Simulation caching\n)\n</code></pre> <p>Attributes: - <code>model.income</code>: IncomeModel instance - <code>model.returns</code>: ReturnModel instance (auto-created) - <code>model.portfolio</code>: Portfolio instance (auto-created) - <code>model.M</code>: Number of accounts</p>"},{"location":"framework/#52-core-methods","title":"5.2 Core Methods","text":""},{"location":"framework/#simulation","title":"Simulation","text":"<pre><code>result = model.simulate(\n    T=24,\n    X=X,                        # (24, 2) allocation policy\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    use_cache=True\n)\n# Returns: SimulationResult with wealth, contributions, returns\n</code></pre> <p>Features: - Automatic seed propagation (income: seed, returns: seed+1) - SHA256 cache keying for instant re-runs - Affine wealth computation for optimization readiness</p>"},{"location":"framework/#optimization","title":"Optimization","text":"<pre><code>result = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    verbose=True\n)\n# Returns: OptimizationResult with X*, T*, feasibility, diagnostics\n</code></pre> <p>Features: - Lazy import of optimization module (TYPE_CHECKING) - Duck typing validation of optimizer interface - Automatic generator construction for income/returns - Extracts <code>W0</code> from portfolio automatically</p>"},{"location":"framework/#validation","title":"Validation","text":"<pre><code>status = model.verify_goals(result, goals)\n# Returns: dict mapping each goal to violation metrics\n</code></pre> <p>Features: - Handles both <code>SimulationResult</code> and <code>OptimizationResult</code> - Auto-converts <code>OptimizationResult</code> \u2192 <code>SimulationResult</code> (500 fresh scenarios) - Computes empirical violation rates</p>"},{"location":"framework/#visualization","title":"Visualization","text":"<pre><code>model.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42, \n          start=date(2025,1,1))\n</code></pre> <p>Modes: - Pre-simulation: <code>\"income\"</code>, <code>\"contributions\"</code>, <code>\"returns\"</code> - Simulation-based: <code>\"wealth\"</code>, <code>\"comparison\"</code></p>"},{"location":"framework/#53-workflow-example","title":"5.3 Workflow Example","text":"<pre><code># 1. Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000, annual_growth=0.03),\n    variable=VariableIncome(base=200_000, sigma=0.10)\n)\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05),\n    Account.from_annual(\"Housing\", 0.07, 0.12)\n]\nmodel = FinancialModel(income, accounts)\n\n# 2. Define goals\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"Emergency\",\n                    threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\",\n                threshold=20_000_000, confidence=0.90)\n]\n\n# 3. Optimize\noptimizer = SAAOptimizer(n_accounts=2, tau=0.1)\nopt_result = model.optimize(goals, optimizer, T_max=120, seed=42)\n\nprint(f\"Optimal horizon: T*={opt_result.T} months\")\nprint(f\"Feasible: {opt_result.feasible}\")\n\n# 4. Validate with fresh scenarios\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"{goal}: {metrics['satisfied']} \"\n          f\"(violation rate: {metrics['violation_rate']:.2%})\")\n\n# 5. Visualize\nmodel.plot(\"wealth\", result=sim_result, show_trajectories=True)\n</code></pre>"},{"location":"framework/#6-implementation-details","title":"6. Implementation Details","text":""},{"location":"framework/#61-calendar-alignment","title":"6.1 Calendar Alignment","text":"<p>All projections use <code>start: date</code> parameter: - Seasonality rotates via offset \\(= (\\text{start.month} - 1)\\) - Salary raises applied at specific dates relative to start - Contribution fractions rotate cyclically to match fiscal year - Temporal index: <code>month_index(start, T)</code> \u2192 DatetimeIndex</p>"},{"location":"framework/#62-seed-management","title":"6.2 Seed Management","text":"<p>Reproducibility architecture: <pre><code>User seed\n    \u251c\u2500\u2192 Income: seed\n    \u2514\u2500\u2192 Returns: seed + 1\n</code></pre></p> <p>Rationale: Statistical independence between income and return shocks.</p> <p>Implementation: <pre><code>A = income.contributions(months=T, seed=seed)\nR = returns.generate(T, seed=None if seed is None else seed + 1)\n</code></pre></p>"},{"location":"framework/#63-memory-management","title":"6.3 Memory Management","text":"<p>Accumulation factors: \\(F \\in \\mathbb{R}^{N \\times (T+1) \\times (T+1) \\times M}\\)</p> <p>Memory usage: \\(N \\cdot T^2 \\cdot M \\cdot 8\\) bytes</p> <p>Estimates: - \\(N=500, T=24, M=2\\): ~115 MB - \\(N=500, T=120, M=5\\): ~14 GB \u26a0\ufe0f - \\(N=1000, T=240, M=10\\): ~221 GB (infeasible)</p> <p>Mitigation strategies: - Use <code>method=\"recursive\"</code> for large \\(T\\) (no \\(F\\) precomputation) - Process simulations in batches (chunk \\(N\\)) - Compute gradients on-the-fly (store only needed \\(F_{s,t}\\) pairs) - Use sparse storage for intermediate-goal-only problems</p>"},{"location":"framework/#64-output-formats","title":"6.4 Output Formats","text":"<p>All methods support flexible output: - <code>output=\"array\"</code>: NumPy arrays (computational efficiency) - <code>output=\"series\"</code>: Pandas Series with calendar index (reporting) - <code>output=\"dataframe\"</code>: Component breakdown (analysis)</p>"},{"location":"framework/#65-type-safety","title":"6.5 Type Safety","text":"<p>Lazy imports for optimization: <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .optimization import AllocationOptimizer, OptimizationResult\n</code></pre></p> <p>Runtime validation: <pre><code># Duck typing (no import needed at runtime)\nif not hasattr(optimizer, 'solve') or not callable(optimizer.solve):\n    raise TypeError(\"optimizer must implement .solve() method\")\n</code></pre></p>"},{"location":"framework/#7-key-mathematical-results","title":"7. Key Mathematical Results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\) and return realization \\(\\{R_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m $$ is affine in \\(X\\).</p> <p>Corollary 1 (Convex Feasible Set): For deterministic constraints \\(W_t^m(X) \\ge b_t^m\\), the feasible allocation set is a convex polytope.</p> <p>Proposition 2 (Analytical Gradient): The sensitivity of wealth to allocation at month \\(s\\) is: $$ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t $$</p> <p>Corollary 2 (Monotonicity): If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m(X)\\) is strictly increasing in \\(x_s^m\\).</p> <p>Proposition 3 (Sigmoid Approximation Error): For temperature \\(\\tau &gt; 0\\): $$ \\left|\\sigma\\left(\\frac{z}{\\tau}\\right) - \\mathbb{1}{z \\geq 0}\\right| \\le \\frac{1}{2} $$ with error decaying exponentially in \\(|z|/\\tau\\).</p> <p>Proposition 4 (SAA Consistency): Under mild regularity conditions, as \\(N \\to \\infty\\): $$ \\frac{1}{N}\\sum_{i=1}^N \\mathbb{1}{W_t^m(X; \\omega^{(i)}) \\ge b} \\xrightarrow{a.s.} \\mathbb{P}(W_t^m(X) \\ge b) $$</p>"},{"location":"framework/#8-usage-examples","title":"8. Usage Examples","text":""},{"location":"framework/#81-basic-simulation","title":"8.1 Basic Simulation","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\nimport numpy as np\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000, annual_growth=0.03),\n    variable=VariableIncome(base=200_000, sigma=0.10, seed=42)\n)\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05),\n    Account.from_annual(\"Housing\", 0.07, 0.12)\n]\nmodel = FinancialModel(income, accounts)\n\n# Simulate with 60-40 allocation\nX = np.tile([0.6, 0.4], (24, 1))\nresult = model.simulate(T=24, X=X, n_sims=500, seed=42,\n                       start=date(2025, 1, 1))\n\n# Analyze\nprint(result.summary(confidence=0.95))\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"Mean Sharpe: {metrics['sharpe'].mean():.3f}\")\n</code></pre>"},{"location":"framework/#82-goal-driven-optimization","title":"8.2 Goal-Driven Optimization","text":"<pre><code>from finopt.src.optimization import SAAOptimizer\nfrom finopt.src.goals import IntermediateGoal, TerminalGoal\n\n# Define goals\ngoals = [\n    IntermediateGoal(\n        month=12, \n        account=\"Emergency\",\n        threshold=5_500_000,\n        confidence=0.90\n    ),\n    TerminalGoal(\n        account=\"Housing\",\n        threshold=20_000_000,\n        confidence=0.90\n    )\n]\n\n# Create optimizer\noptimizer = SAAOptimizer(\n    n_accounts=model.M,\n    tau=0.1,\n    objective=\"terminal_wealth\"\n)\n\n# Optimize\nresult = model.optimize(\n    goals=goals,\n    optimizer=optimizer,\n    T_max=120,\n    n_sims=500,\n    seed=42,\n    start=date(2025, 1, 1),\n    verbose=True\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(f\"Feasible: {result.feasible}\")\nprint(result.summary())\n</code></pre>"},{"location":"framework/#83-multi-goal-validation","title":"8.3 Multi-Goal Validation","text":"<pre><code># Simulate with optimal policy (fresh scenarios)\nsim_result = model.simulate_from_optimization(\n    result, \n    n_sims=1000, \n    seed=999\n)\n\n# Verify goal satisfaction\nstatus = model.verify_goals(sim_result, goals)\n\nfor goal, metrics in status.items():\n    print(f\"\\nGoal: {goal}\")\n    print(f\"  Satisfied: {metrics['satisfied']}\")\n    print(f\"  Violation rate: {metrics['violation_rate']:.2%}\")\n    print(f\"  Required rate: {metrics['required_rate']:.2%}\")\n    print(f\"  Margin: {metrics['margin']:.4f}\")\n    if not metrics['satisfied']:\n        print(f\"  Median shortfall: ${metrics['median_shortfall']:,.0f}\")\n</code></pre>"},{"location":"framework/#84-strategy-comparison","title":"8.4 Strategy Comparison","text":"<pre><code># Define multiple strategies\nX_conservative = np.tile([0.9, 0.1], (24, 1))  # 90% emergency\nX_balanced = np.tile([0.6, 0.4], (24, 1))      # 60-40\nX_aggressive = np.tile([0.3, 0.7], (24, 1))    # 30% emergency\n\n# Simulate each\nr1 = model.simulate(T=24, X=X_conservative, n_sims=500, seed=42)\nr2 = model.simulate(T=24, X=X_balanced, n_sims=500, seed=42)\nr3 = model.simulate(T=24, X=X_aggressive, n_sims=500, seed=42)\n\n# Compare\nmodel.plot(\"comparison\", results={\n    \"Conservative\": r1,\n    \"Balanced\": r2,\n    \"Aggressive\": r3\n})\n</code></pre>"},{"location":"framework/#9-extensions-and-future-work","title":"9. Extensions and Future Work","text":""},{"location":"framework/#91-implemented-features","title":"9.1 Implemented Features","text":"<p>\u2705 Multi-account portfolios with correlated returns \u2705 Intermediate and terminal goals with chance constraints \u2705 Sigmoid-smoothed SAA for gradient-based optimization \u2705 Intelligent horizon estimation for terminal-only goals \u2705 Warm start for faster bilevel convergence \u2705 Affine wealth for analytical gradients \u2705 Calendar alignment for seasonality and raises \u2705 Seed propagation for reproducibility  </p>"},{"location":"framework/#92-potential-extensions","title":"9.2 Potential Extensions","text":"<p>Optimization: - \ud83d\udd04 CVaR implementation (CVXPY-based, convex formulation) - \ud83d\udd04 Robust optimization (worst-case performance over scenarios) - \ud83d\udd04 Multi-period rebalancing (time-varying \\(x_t^m\\) with turnover penalty) - \ud83d\udd04 Dynamic programming (Bellman recursion for complex constraints)</p> <p>Portfolio features: - \ud83d\udd04 Transaction costs (\\(\\kappa \\|\\Delta x_t\\|_1\\) friction terms) - \ud83d\udd04 Tax-aware optimization (capital gains, withdrawal timing) - \ud83d\udd04 Minimum balance constraints (\\(W_t^m \\geq W_{\\min}^m\\)) - \ud83d\udd04 Leverage constraints (short-selling, margin limits)</p> <p>Income modeling: - \ud83d\udd04 Multi-source income (multiple jobs, rental, dividends) - \ud83d\udd04 Income shocks (unemployment, health events) - \ud83d\udd04 Non-Gaussian noise (fat tails, asymmetry)</p> <p>Risk management: - \ud83d\udd04 Downside protection (VaR/CVaR constraints) - \ud83d\udd04 Path-dependent goals (average wealth, peak wealth) - \ud83d\udd04 Correlation uncertainty (robust correlation estimation)</p> <p>Performance: - \ud83d\udd04 GPU acceleration (CuPy for large-scale Monte Carlo) - \ud83d\udd04 Sparse factorization (memory-efficient \\(F\\) storage) - \ud83d\udd04 Parallel simulation (multi-process scenario generation)</p>"},{"location":"framework/#10-references-and-resources","title":"10. References and Resources","text":""},{"location":"framework/#mathematical-foundations","title":"Mathematical Foundations","text":"<ul> <li>Rockafellar &amp; Uryasev (2000), \"Optimization of conditional value-at-risk\"</li> <li>Luedtke &amp; Ahmed (2008), \"A sample approximation approach for optimization with probabilistic constraints\"</li> <li>Nemirovski &amp; Shapiro (2006), \"Convex approximations of chance constrained programs\"</li> </ul>"},{"location":"framework/#implementation","title":"Implementation","text":"<ul> <li>GitHub: <code>github.com/maxliionel/finopt</code></li> <li>Documentation: Full API docs in module docstrings</li> <li>Tests: Comprehensive unit and integration tests</li> </ul>"},{"location":"framework/#related-tools","title":"Related Tools","text":"<ul> <li>CVXPY: Convex optimization modeling language</li> <li>Scipy: Scientific computing (optimize.minimize with SLSQP)</li> <li>NumPy/Pandas: Numerical computing and data analysis</li> </ul> <p>End of Framework Document</p>"},{"location":"framework/#appendix-quick-reference","title":"Appendix: Quick Reference","text":""},{"location":"framework/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>IncomeModel\n    \u251c\u2500 FixedIncome\n    \u2514\u2500 VariableIncome\n\nPortfolio\n    \u2514\u2500 Account\n\nReturnModel (uses Account metadata)\n\nFinancialModel (facade)\n    \u251c\u2500 income: IncomeModel\n    \u251c\u2500 portfolio: Portfolio\n    \u2514\u2500 returns: ReturnModel\n\nAllocationOptimizer (abstract)\n    \u251c\u2500 SAAOptimizer (sigmoid-smoothed)\n    \u2514\u2500 CVaROptimizer (stub)\n\nGoalSeeker (bilevel solver)\n    \u2514\u2500 optimizer: AllocationOptimizer\n</code></pre>"},{"location":"framework/#key-type-signatures","title":"Key Type Signatures","text":"<pre><code># Simulation\nSimulationResult = model.simulate(\n    T: int,\n    X: np.ndarray,  # (T, M)\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date]\n) -&gt; SimulationResult\n\n# Optimization\nOptimizationResult = model.optimize(\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    optimizer: AllocationOptimizer,\n    T_max: int,\n    n_sims: int,\n    seed: Optional[int],\n    start: Optional[date]\n) -&gt; OptimizationResult\n\n# Validation\nDict[Goal, Dict[str, float]] = model.verify_goals(\n    result: Union[SimulationResult, OptimizationResult],\n    goals: List[Union[IntermediateGoal, TerminalGoal]],\n    start: Optional[date]\n)\n</code></pre>"},{"location":"framework/#common-patterns","title":"Common Patterns","text":"<pre><code># Pattern 1: Simulation-only workflow\nmodel = FinancialModel(income, accounts)\nX = define_allocation_policy(T, M)\nresult = model.simulate(T, X, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result)\n\n# Pattern 2: Optimization workflow\ngoals = define_goals()\noptimizer = SAAOptimizer(n_accounts=M, tau=0.1)\nopt_result = model.optimize(goals, optimizer, T_max=120, seed=42)\nsim_result = model.simulate_from_optimization(opt_result, n_sims=1000)\nstatus = model.verify_goals(sim_result, goals)\n\n# Pattern 3: Comparison workflow\nresults = {name: model.simulate(T, X_i, ...) for name, X_i in strategies.items()}\nmodel.plot(\"comparison\", results=results)\n</code></pre>"},{"location":"goals/","title":"<code>goals</code> \u2014 Philosophy and Role in FinOpt","text":"<p>Core idea: translate financial goals (target amount and deadline) into verifiable criteria over simulated wealth trajectories. <code>goals.py</code> connects what the user wants to achieve (e.g., \u201c20M CLP in 24 months\u201d) with what the simulation engine produces (<code>wealth</code> series), and outputs clear evaluations: success, shortfall, and attainment ratio.</p>"},{"location":"goals/#why-a-dedicated-goals-module","title":"Why a dedicated goals module?","text":"<ul> <li>Grounds objectives in numbers: converts \u201cbuy a house in 2 years\u201d into <code>B_m</code> (amount) and <code>T_m</code> (deadline).  </li> <li>Separates the what from the how: <code>investment.py</code> grows capital; <code>simulation.py</code> orchestrates scenarios; <code>goals.py</code> checks if results meet the target.  </li> <li>Enables optimization: by quantifying shortfalls, it allows solving for minimum contributions, minimum time, or allocation across multiple goals (goal-based investing).</li> </ul>"},{"location":"goals/#design-philosophy","title":"Design philosophy","text":"<ol> <li>Minimal and deterministic </li> <li>Depends only on <code>numpy</code>, <code>pandas</code>, and project utilities (<code>utils.py</code>).  </li> <li> <p>Deterministic: any randomness comes from return paths or contribution flows, not from this module.</p> </li> <li> <p>Consistent calendar indexing </p> </li> <li>Supports deadlines as calendar dates (<code>target_date</code>) or as month indices relative to the start (<code>target_month_index</code>).  </li> <li> <p>Uses helpers (<code>month_index</code>, <code>align_index_like</code>) to align goals with the wealth series.</p> </li> <li> <p>Simple, serializable interfaces </p> </li> <li><code>Goal</code> and evaluation results can be (de)serialized (<code>to_dict</code>, <code>from_dict</code>) for configs and reporting.</li> </ol>"},{"location":"goals/#key-concepts","title":"Key concepts","text":"<ul> <li>Goal (<code>Goal</code>): pair of (target amount <code>B_m</code>, deadline <code>T_m</code>) plus metadata (<code>name</code>, <code>priority</code>, <code>notes</code>).  </li> <li>Evaluation: given a wealth path, compute:  </li> <li><code>success</code> (boolean),  </li> <li><code>shortfall = max(0, B_m - W_{m,T_m})</code>,  </li> <li><code>attainment_ratio = min(W_{m,T_m}/B_m, 1)</code>.  </li> <li>Contribution split (MVP): split aggregate contributions into per-goal series by proportions summing to 1.  </li> <li>Required constant contribution: compute the <code>a*</code> needed to guarantee the goal under a given returns path (possibly time-varying).</li> </ul>"},{"location":"goals/#main-surfaces-api","title":"Main surfaces (API)","text":""},{"location":"goals/#1-goal-dataclass","title":"1) <code>Goal</code> (dataclass)","text":"<pre><code>Goal(\n  name: str,\n  target_amount: float,\n  target_date: Optional[date] = None,        # or...\n  target_month_index: Optional[int] = None,  # ...exactly one must be provided\n  priority: int = 0,\n  notes: Optional[str] = None\n)\n</code></pre>"},{"location":"goals/#2-goal-evaluation","title":"2) Goal evaluation","text":"<ul> <li> <p>Single goal: <code>evaluate_goal(wealth: pd.Series, goal: Goal) -&gt; GoalEvaluation</code></p> </li> <li> <p>Multiple goals: <code>evaluate_goals(wealth: pd.Series, goals: Iterable[Goal]) -&gt; pd.DataFrame</code></p> </li> </ul> <p>The multiple-goal version returns a DataFrame ordered by priority (if available), with the following columns:</p> <ul> <li><code>goal</code> </li> <li><code>deadline_pos</code> </li> <li><code>deadline_timestamp</code> </li> <li><code>target_amount</code> </li> <li><code>wealth_at_deadline</code> </li> <li><code>success</code> </li> <li><code>shortfall</code> </li> <li><code>attainment_ratio</code></li> </ul> <p>Interpretation: - <code>attainment_ratio</code> allows comparison of heterogeneous goals on a [0,1] scale. - <code>shortfall</code> quantifies the missing amount in currency units.</p>"},{"location":"goals/#3-proportional-contribution-split-mvp","title":"3) Proportional contribution split (MVP)","text":"<p><code>allocate_contributions_proportional(contributions: pd.Series, weights_by_goal: dict) -&gt; pd.DataFrame</code></p> <ul> <li>Purpose: obtain per-goal contribution columns that sum to the aggregate.  </li> <li>Rules: weights must be non-negative; normalized to sum to 1; index preserved.</li> </ul> <p>Use case: build per-goal reports or run per-goal simulations (via <code>simulate_capital</code> on each column).</p>"},{"location":"goals/#4-required-constant-contribution-under-a-returns-path","title":"4) Required constant contribution under a returns path","text":"<p><code>required_constant_contribution(target_amount, start_wealth, returns_path) -&gt; float</code></p> <ul> <li> <p>Dynamics: $$ W_{t+1} = (W_t + a)\\,(1 + r_t), \\quad t=0,\\dots,T-1 $$</p> </li> <li> <p>Closed form for time-varying \\(r_t\\): Define  $$ G_t = \\prod_{u=t}^{T-1}(1+r_u), \\quad AF = \\sum_{t=0}^{T-1} G_{t+1} $$ Then: $$ W_T = W_0\\,G_0 + a\\,AF \\;\\;\\Rightarrow\\;\\; a^* = \\max!\\left(0, \\frac{B - W_0 G_0}{AF}\\right) $$</p> </li> <li> <p>Interpretation: <code>a*</code> is the minimum constant monthly contribution required to guarantee reaching the target amount <code>B</code> at horizon <code>T</code>, under the given return path.</p> </li> </ul>"},{"location":"goals/#integration-in-the-finopt-workflow","title":"Integration in the FinOpt workflow","text":"<ol> <li><code>income.py</code> \u2192 produces aggregate contributions.  </li> <li><code>investment.py</code> \u2192 simulates wealth (single or multi-asset).  </li> <li><code>simulation.py</code> \u2192 orchestrates scenarios and outputs wealth.  </li> <li><code>goals.py</code> \u2192 evaluates goal attainment, splits contributions per goal, and computes required <code>a*</code>.</li> </ol>"},{"location":"income/","title":"<code>income</code> \u2013 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Model where the money comes from (and how it evolves) so the rest of FinOpt can decide how to allocate and invest it. In FinOpt's pipeline, <code>income.py</code> is the entry point of cash flows: it turns assumptions about salary and variable earnings into a clean, reproducible monthly series that downstream modules consume for contributions and simulations.</p>"},{"location":"income/#why-a-dedicated-income-module","title":"Why a dedicated income module?","text":"<p>Financial planning hinges on cash availability per period. Any optimizer or simulator that ignores timing or volatility of income will produce plans that are hard to execute. <code>income.py</code> separates cash generation (what you earn) from capital dynamics (what you invest), giving you:</p> <ul> <li>Clarity: Incomes are modeled explicitly (fixed vs. variable).  </li> <li>Composability: Outputs plug directly into <code>simulation.py</code> and <code>investment.py</code>.  </li> <li>Reproducibility: Deterministic by default; any randomness is controlled by an explicit seed.  </li> <li>Extensibility: Easy to add expenses, taxes, or more streams without touching portfolio code.</li> </ul>"},{"location":"income/#design-principles","title":"Design principles","text":"<ol> <li>Deterministic baseline, controlled randomness</li> <li>Everything is deterministic unless you explicitly add noise to <code>VariableIncome</code> via <code>sigma</code> and <code>seed</code>.</li> <li>Calendar-first outputs</li> <li>Returns pandas Series/DataFrames indexed by the first day of each month (friendly for reporting and plotting).</li> <li>Minimal but expressive</li> <li>Two stream types cover common cases:<ul> <li><code>FixedIncome</code>: predictable salary with optional annual growth and scheduled raises.</li> <li><code>VariableIncome</code>: irregular stream with seasonality and Gaussian noise.</li> </ul> </li> <li>Single responsibility</li> <li><code>income.py</code> does not simulate returns or portfolios. It only projects income and derives contribution series from it.</li> </ol>"},{"location":"income/#the-three-core-surfaces","title":"The three core surfaces","text":""},{"location":"income/#1-fixedincome","title":"1) <code>FixedIncome</code>","text":"<p>A deterministic monthly base with compounded annual growth and optional salary raises:</p> <p>Parameters: - <code>base</code>: monthly base income at t=0 - <code>annual_growth</code>: nominal annual rate (converted internally to monthly compounding) - <code>salary_raises</code>: <code>Optional[Dict[date, float]]</code> \u2013 absolute raise amounts at specific dates - <code>name</code>: identifier for labeling outputs</p> <p>Method signature: <pre><code>def project(\n    self, \n    months: int, \n    *, \n    start: Optional[date] = None,\n    output: Literal[\"array\", \"series\"] = \"array\"\n) -&gt; np.ndarray | pd.Series\n</code></pre> - <code>start</code>: required when <code>salary_raises</code> is specified; used for calendar alignment - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</p> <p>Key behaviors: - Monthly projection uses the equivalent monthly rate: <code>m = (1 + annual_growth)^(1/12) - 1</code> - Salary raises are applied permanently from the month containing the specified date - Growth compounds on the updated base after each raise - Requires <code>start</code> date in <code>.project()</code> when <code>salary_raises</code> is specified - Guarantees non-negativity and well-formed arrays</p> <p>Interpretation: models a salary with contractual raises and inflation adjustments; simple and transparent.</p>"},{"location":"income/#2-variableincome","title":"2) <code>VariableIncome</code>","text":"<p>A variable stream with optional seasonality, noise, floor/cap, and annual growth:</p> <p>Parameters: - <code>base</code>: baseline monthly income before transformations - <code>seasonality</code>: 12 multiplicative factors (Jan\u2013Dec), must have length 12 - <code>sigma</code>: standard deviation of noise as a fraction of the month mean - <code>floor</code> / <code>cap</code>: guardrails applied after noise (e.g., minimum expected side income) - <code>annual_growth</code>: nominal annual rate applied before seasonality - <code>seed</code>: RNG seed for reproducible noise (can be overridden in <code>.project()</code>) - <code>name</code>: identifier for labeling outputs</p> <p>Method signature: <pre><code>def project(\n    self, \n    months: int, \n    *, \n    start: Optional[date | int] = None, \n    seed: Optional[int] = None,\n    output: Literal[\"array\", \"series\"] = \"array\"\n) -&gt; np.ndarray | pd.Series\n</code></pre> - <code>start</code>: can be <code>date</code> or <code>int</code> (month 1-12); determines seasonality rotation - <code>seed</code> in <code>project()</code> overrides instance-level seed if provided - <code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</p> <p>Interpretation: models tutoring, bonuses, or freelancing income whose level changes across the year and fluctuates each month.</p>"},{"location":"income/#3-incomemodel","title":"3) <code>IncomeModel</code>","text":"<p>A fa\u00e7ade that combines streams and produces projections, contributions, metrics, and visualizations.</p>"},{"location":"income/#core-projection-methods","title":"Core projection methods","text":"<p><code>project(months, start=None, output=\"series\", seed=None)</code> - Returns total income (optionally as DataFrame with [fixed, variable, total] columns) - Aligned to calendar via <code>start</code> date - <code>output</code>: <code>\"series\"</code> returns total as Series, <code>\"dataframe\"</code> returns breakdown with components - <code>seed</code>: controls reproducibility of variable income (overrides instance seed) - Example:   <pre><code># Total income as Series (default)\ntotal = income.project(months=24, start=date(2025, 9, 1))\n\n# Breakdown as DataFrame\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n</code></pre></p> <p><code>contributions(months, start=None, seed=None, output=\"series\")</code> - Computes monthly contributions using 12-month fractional arrays that rotate based on <code>start</code>:   $$   \\text{contrib}t = \\alpha^{\\text{fixed}}{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{fixed}}t + \\alpha^{\\text{variable}}{(t+\\text{offset})\\bmod 12} \\cdot y^{\\text{variable}}_t   $$   where <code>offset = normalize_start_month(start)</code>.</p> <ul> <li><code>output</code>: <code>\"array\"</code> returns <code>np.ndarray</code>, <code>\"series\"</code> returns <code>pd.Series</code> with calendar index</li> <li> <p><code>seed</code>: controls reproducibility of variable income (overrides instance seed)</p> </li> <li> <p>Default fractions (if <code>monthly_contribution</code> is <code>None</code>):</p> </li> <li>Fixed: 30% each month</li> <li> <p>Variable: 100% each month</p> </li> <li> <p>Custom fractions via attribute:   <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # Jan-Dec fractions\n    \"variable\": [1.0]*12\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> </li> <li> <p>Contributions are floored at zero (no negative values)</p> </li> <li>The 12-month arrays repeat cyclically for horizons &gt; 12 months</li> </ul>"},{"location":"income/#statistical-methods","title":"Statistical methods","text":"<p><code>income_metrics(months, start=None, variable_threshold=None)</code> - Returns <code>IncomeMetrics</code> dataclass with:   <pre><code>@dataclass\nclass IncomeMetrics:\n    months: int\n    total_fixed, total_variable, total_income: float\n    mean_fixed, mean_variable, mean_total: float\n    std_variable, coefvar_variable: float\n    fixed_share, variable_share: float\n    min_variable, max_variable: float\n    pct_variable_below_threshold: float  # NaN if threshold not provided\n</code></pre></p> <p><code>summary(months, start=None, variable_threshold=None, round_digits=2)</code> - Convenience wrapper that returns <code>income_metrics()</code> as a rounded pandas Series</p>"},{"location":"income/#visualization-methods","title":"Visualization methods","text":"<p><code>plot_income(months, start=None, ...)</code> - Plots fixed, variable, and total income streams - Dual-axis support: automatic when scales differ by <code>dual_axis_ratio</code> (default 3.0) - Monte Carlo trajectories: shows individual stochastic paths when <code>show_trajectories=True</code> and <code>sigma &gt; 0</code> - Confidence bands: statistical intervals when <code>show_confidence_band=True</code> and <code>sigma &gt; 0</code> - Key parameters:   - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code>   - <code>ylabel_left</code>, <code>ylabel_right</code>: axis labels   - <code>dual_axis</code>: <code>\"auto\"</code> | <code>True</code> | <code>False</code>   - <code>show_trajectories=True</code>, <code>trajectory_alpha=0.08</code>   - <code>show_confidence_band=False</code>, <code>confidence=0.9</code>, <code>n_simulations=500</code>   - <code>colors</code>: <code>{\"fixed\": \"blue\", \"variable\": \"orange\", \"total\": \"black\"}</code>   - <code>save_path</code>, <code>return_fig_ax</code> - Displays cumulative totals annotation</p> <p><code>plot_contributions(months, start=None, ...)</code> - Plots total monthly contributions with optional Monte Carlo trajectories and confidence bands - Single y-axis (no dual-axis) - Key parameters:   - <code>ax</code>, <code>figsize</code>, <code>title</code>, <code>legend</code>, <code>grid</code>, <code>ylabel</code>   - <code>show_trajectories=True</code>, <code>trajectory_alpha=0.08</code>   - <code>show_confidence_band=False</code>, <code>confidence=0.9</code>, <code>n_simulations=500</code>   - <code>colors</code>: <code>{\"total\": \"blue\", \"ci\": \"orange\"}</code>   - <code>save_path</code>, <code>return_fig_ax</code> - Displays total contributions annotation</p> <p><code>plot(mode=\"income\"|\"contributions\", ...)</code> - Unified wrapper that dispatches to <code>plot_income()</code> or <code>plot_contributions()</code> - All parameters are forwarded to the appropriate method</p>"},{"location":"income/#serialization","title":"Serialization","text":"<p><code>to_dict()</code> / <code>from_dict(payload)</code> - Serialize/deserialize model configuration for persistence - Handles <code>salary_raises</code> date conversion (ISO format strings)</p>"},{"location":"income/#how-incomepy-powers-the-rest-of-finopt","title":"How <code>income.py</code> powers the rest of FinOpt","text":"<ul> <li> <p><code>simulation.py</code>   Uses <code>IncomeModel.contributions(...)</code> to generate the contribution series aligned to the simulation calendar, then combines it with deterministic or Monte Carlo returns to simulate wealth.</p> </li> <li> <p><code>investment.py</code>   Receives the contributions from <code>income.py</code> and applies capital accumulation:   $$   W_{t+1}=(W_t+A_t)(1+R_t).   $$   Metrics (CAGR, drawdown, volatility) are computed downstream on the resulting wealth path.</p> </li> <li> <p><code>utils.py</code>   Provides shared helpers used by <code>income.py</code> (e.g., rate conversions annual\u2194monthly, month index construction, validation).</p> </li> </ul>"},{"location":"income/#recommended-usage-patterns","title":"Recommended usage patterns","text":""},{"location":"income/#a-baseline-projection-deterministic","title":"A) Baseline projection (deterministic)","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\n\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_400_000.0, annual_growth=0.00),\n    variable=VariableIncome(base=200_000.0, sigma=0.00)  # no noise\n)\n\n# 24-month calendar-aligned totals (and components if needed)\ndf = income.project(months=24, start=date(2025, 9, 1), output=\"dataframe\")\n</code></pre>"},{"location":"income/#b-from-income-to-contributions","title":"B) From income to contributions","text":"<p>Option 1: Use defaults (30% fixed, 100% variable) <pre><code>contrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 2: Custom monthly fractions <pre><code>income.monthly_contribution = {\n    \"fixed\": [0.35]*12,      # 35% each month (Jan-Dec)\n    \"variable\": [1.0]*12     # 100% each month\n}\ncontrib = income.contributions(months=24, start=date(2025, 9, 1))\n</code></pre></p> <p>Option 3: Seasonal contribution patterns <pre><code># Higher contributions in bonus months\nincome.monthly_contribution = {\n    \"fixed\": [0.30]*12,\n    \"variable\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n                 1.0, 1.0, 1.0, 1.0, 1.0, 0.5]  # save 50% of Dec bonus\n}\n</code></pre></p>"},{"location":"income/#c-fixed-income-with-salary-raises","title":"C) Fixed income with salary raises","text":"<pre><code>fixed = FixedIncome(\n    base=1_400_000.0,\n    annual_growth=0.03,\n    salary_raises={\n        date(2025, 7, 1): 200_000,   # raise in July\n        date(2026, 1, 1): 150_000    # raise in January\n    }\n)\n# Requires start date when projecting\npath = fixed.project(months=24, start=date(2025, 1, 1))  # returns array by default\nseries = fixed.project(months=24, start=date(2025, 1, 1), output=\"series\")  # with calendar index\n</code></pre>"},{"location":"income/#d-variable-income-with-seasonality-noise","title":"D) Variable income with seasonality + noise","text":"<pre><code>seasonality = [1.00, 0.95, 1.05, 1.10, 1.15, 1.10, \n               1.00, 0.90, 0.95, 1.05, 1.10, 1.20]\n\nincome_var = VariableIncome(\n    base=200_000.0,\n    seasonality=seasonality,\n    sigma=0.15,\n    floor=50_000.0,\n    cap=400_000.0,\n    annual_growth=0.02,\n    seed=123\n)\n\n# Project as array (default)\npath = income_var.project(months=12)\n\n# Project as Series with calendar alignment\nseries = income_var.project(months=12, start=date(2025, 1, 1), output=\"series\")\n</code></pre>"},{"location":"income/#e-statistical-summary","title":"E) Statistical summary","text":"<pre><code># Detailed metrics as dataclass\nmetrics = income.income_metrics(\n    months=24, \n    start=date(2025, 1, 1),\n    variable_threshold=150_000.0\n)\n\n# Compact summary as Series\nsummary = income.summary(months=24, start=date(2025, 1, 1), round_digits=2)\nprint(summary)\n</code></pre>"},{"location":"income/#f-visualization-with-monte-carlo-trajectories","title":"F) Visualization with Monte Carlo trajectories","text":"<pre><code># Income streams with stochastic trajectories (default if sigma &gt; 0)\nincome.plot_income(\n    months=24, \n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    n_simulations=500,\n    dual_axis=\"auto\",\n    save_path=\"income_projection.png\"\n)\n\n# Legacy mode: confidence bands only\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=False,\n    show_confidence_band=True,\n    confidence=0.95\n)\n\n# Hybrid mode: trajectories + bands\nincome.plot_income(\n    months=24,\n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    show_confidence_band=True,\n    n_simulations=150,\n    trajectory_alpha=0.03\n)\n\n# Contributions with trajectories\nincome.plot_contributions(\n    months=24, \n    start=date(2025, 1, 1),\n    show_trajectories=True,\n    title=\"Monthly Investment Contributions\"\n)\n\n# Using unified wrapper\nincome.plot(\n    mode=\"income\",  # or \"contributions\"\n    months=24,\n    start=date(2025, 1, 1)\n)\n</code></pre>"},{"location":"income/#key-design-decisions","title":"Key design decisions","text":""},{"location":"income/#1-monthly-fractions-are-12-element-arrays-not-scalars","title":"1. Monthly fractions are 12-element arrays, not scalars","text":"<p>This allows seasonal contribution strategies: save more during high-income months, less during lean months. The arrays rotate based on <code>start</code> and repeat cyclically.</p>"},{"location":"income/#2-salary-raises-are-date-based-not-month-offset-based","title":"2. Salary raises are date-based, not month-offset-based","text":"<p>You specify <code>{date(2025, 7, 1): 200_000}</code>, not <code>{6: 200_000}</code>. The conversion to month offsets happens internally relative to the projection <code>start</code> date, making the model calendar-aware.</p>"},{"location":"income/#3-flexible-output-formats-via-output-parameter","title":"3. Flexible output formats via <code>output</code> parameter","text":"<p>All projection methods (<code>FixedIncome.project()</code>, <code>VariableIncome.project()</code>, <code>IncomeModel.project()</code>, <code>IncomeModel.contributions()</code>) support an <code>output</code> parameter to control return type: - <code>\"array\"</code>: returns <code>np.ndarray</code> (default for streams, no calendar overhead) - <code>\"series\"</code>: returns <code>pd.Series</code> with calendar index (default for <code>IncomeModel</code>, user-friendly) - <code>\"dataframe\"</code>: returns <code>pd.DataFrame</code> with component breakdown (only <code>IncomeModel.project()</code>)</p>"},{"location":"income/#4-reproducibility-via-explicit-seed-parameter","title":"4. Reproducibility via explicit <code>seed</code> parameter","text":"<p>Variable income randomness is controlled at two levels: - Instance-level: <code>VariableIncome(seed=42)</code> sets default seed - Method-level: <code>project(..., seed=123)</code> overrides for specific realizations This enables reproducible stochastic projections without mutating the model state.</p>"},{"location":"income/#5-monte-carlo-trajectories-as-primary-visualization","title":"5. Monte Carlo trajectories as primary visualization","text":"<p>When <code>sigma &gt; 0</code>, plotting methods default to showing individual trajectories (<code>show_trajectories=True</code>) instead of confidence bands, providing more intuitive visualization of stochastic dynamics. Confidence bands remain available via <code>show_confidence_band=True</code>.</p>"},{"location":"income/#6-dual-axis-activation-is-automatic-by-default","title":"6. Dual-axis activation is automatic by default","text":"<p>When fixed and variable incomes differ by a factor &gt; <code>dual_axis_ratio</code>, the plot automatically uses separate y-axes to avoid visual compression. Override with <code>dual_axis=True|False</code>.</p>"},{"location":"income/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Rate conversion: <code>annual_to_monthly(g) = (1+g)^(1/12) - 1</code> ensures geometric compounding</li> <li>Calendar alignment: <code>month_index(start, months)</code> generates <code>pd.DatetimeIndex</code> of first-of-month dates</li> <li>Seasonality rotation: <code>normalize_start_month(start)</code> returns 0-indexed month offset (0=Jan, 11=Dec)</li> <li>Non-negativity: all income and contribution values are floored at zero after transformations</li> <li>Seed propagation: <code>seed=None</code> in methods uses instance seed; both <code>None</code> generates non-deterministic noise</li> </ul>"},{"location":"model/","title":"Integration Model","text":"<pre><code># `model` \u2014 Philosophy &amp; Role in FinOpt\n\n&gt; **Purpose:** Unified **orchestrator** for Monte Carlo simulation, integrating income generation, return modeling, and portfolio dynamics into a single coherent interface with intelligent caching, reproducibility guarantees, and optimization-ready outputs.  \n&gt; `model.py` is the **facade layer**: while `income.py` generates cash flows, `returns.py` produces stochastic returns, and `portfolio.py` executes wealth dynamics, `model.py` coordinates the entire pipeline and packages results for analysis and optimization.\n\n---\n\n## Why a dedicated model module?\n\nFinancial planning requires **end-to-end simulation** with multiple moving parts. `model.py` provides:\n\n- **Single entry point:** Unified `FinancialModel` class orchestrates all components\n- **Intelligent caching:** Parameter-based memoization avoids redundant computation\n- **Reproducibility:** Explicit seed management with automatic propagation\n- **Rich analytics:** `SimulationResult` container with financial metrics computation\n- **Seamless visualization:** Auto-simulation in `plot()` methods\n- **Optimization integration:** Affine wealth representation for gradient-based solvers\n\n---\n\n## Design principles\n\n1. **Facade pattern:** Coordinates but doesn't re-implement (loose coupling)\n2. **Explicit reproducibility:** Seed propagation ensures statistical independence (income uses `seed`, returns use `seed+1`)\n3. **Type-safe results:** `SimulationResult` as explicit dataclass (not `dict`)\n4. **Zero-overhead visualization:** `plot()` auto-simulates with caching\n5. **Optimization-ready:** Default `method=\"affine\"` exposes gradients $\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m$\n\n---\n\n## Core components\n\n### 1) `SimulationResult`\n\nImmutable container for complete Monte Carlo simulation output with lazy-computed analytics.\n\n**Attributes:**\n```python\n@dataclass(frozen=False)\nclass SimulationResult:\n    # Primary outputs\n    wealth: np.ndarray              # (n_sims, T+1, M)\n    total_wealth: np.ndarray        # (n_sims, T+1)\n    contributions: np.ndarray       # (n_sims, T) or (T,)\n    returns: np.ndarray             # (n_sims, T, M)\n    income: dict                    # {\"fixed\", \"variable\", \"total\"}\n    allocation: np.ndarray          # (T, M)\n\n    # Metadata for reproducibility\n    T, n_sims, M: int\n    start: date\n    seed: Optional[int]\n    account_names: List[str]\n</code></pre> <p>Analytical methods:</p>"},{"location":"model/#metricsaccountnone-pddataframe","title":"<code>metrics(account=None) \u2192 pd.DataFrame</code>","text":"<p>Computes per-simulation financial metrics:</p> \\[ \\begin{aligned} \\text{CAGR}_i &amp;= \\left(\\frac{W_{T,i}}{W_{0,i}}\\right)^{12/T} - 1 \\\\ \\text{Sharpe}_i &amp;= \\frac{\\bar{R}_i}{\\sigma_i} \\quad \\text{(assumes } r_f = 0\\text{)} \\\\ \\text{Sortino}_i &amp;= \\frac{\\bar{R}_i}{\\sigma^-_i}, \\quad \\sigma^-_i = \\sqrt{\\mathbb{E}[\\min(R_t, 0)^2]} \\\\ \\text{MDD}_i &amp;= \\min_{t} \\frac{W_{t,i} - \\max_{s \\leq t} W_{s,i}}{\\max_{s \\leq t} W_{s,i}} \\end{aligned} \\] <p>Returns: DataFrame with columns <code>['cagr', 'volatility', 'sharpe', 'sortino', 'max_drawdown']</code></p>"},{"location":"model/#aggregate_metricsaccountnone-pdseries-pddataframe","title":"<code>aggregate_metrics(account=None) \u2192 pd.Series | pd.DataFrame</code>","text":"<p>Computes distribution-level risk metrics:</p> \\[ \\begin{aligned} \\text{VaR}_{0.95}(W_T) &amp;= F_{W_T}^{-1}(0.05) \\quad \\text{(5th percentile)} \\\\ \\text{CVaR}_{0.95}(W_T) &amp;= \\mathbb{E}[W_T \\mid W_T \\leq \\text{VaR}_{0.95}] \\end{aligned} \\] <p>Plus summary statistics: mean, median, std, min, max of \\(W_T\\).</p> <p>Use in optimization: <pre><code># Chance constraint: P(W_T^m &gt;= b) &gt;= 1-\u03b5 via CVaR\ncvar = result.aggregate_metrics(account=\"Housing\")['cvar_95']\nif cvar &gt;= goal:\n    # Feasible with \u03b1=0.95 confidence\n</code></pre></p>"},{"location":"model/#summaryconfidence095-pddataframe","title":"<code>summary(confidence=0.95) \u2192 pd.DataFrame</code>","text":"<p>Statistical summary with confidence intervals: $$ \\text{CI}{1-\\alpha}(W_T) = \\left[F^{-1}{W_T}(\\alpha/2), F^{-1}_{W_T}(1-\\alpha/2)\\right] $$</p>"},{"location":"model/#convergence_analysis-pddataframe","title":"<code>convergence_analysis() \u2192 pd.DataFrame</code>","text":"<p>Monte Carlo convergence diagnostics via standard error: \\(\\text{SE}(n) = \\frac{\\sigma_{W_T}}{\\sqrt{n}}\\)</p>"},{"location":"model/#2-financialmodel","title":"2) <code>FinancialModel</code>","text":"<p>Unified orchestrator coordinating the flow: <code>income \u2192 contributions (A) \u2192 returns (R) \u2192 wealth (W)</code></p> <p>Constructor: <pre><code>FinancialModel(\n    income: IncomeModel,\n    accounts: List[Account],\n    default_correlation: Optional[np.ndarray] = None,\n    enable_cache: bool = True\n)\n</code></pre></p> <p>Internal components: <pre><code>self.returns = ReturnModel(accounts, default_correlation)\nself.portfolio = Portfolio(accounts)\n</code></pre></p>"},{"location":"model/#simulation-workflow","title":"Simulation workflow","text":""},{"location":"model/#simulate-method","title":"<code>simulate()</code> method","text":"<pre><code>def simulate(\n    T: int,\n    X: np.ndarray,                    # (T, M)\n    n_sims: int = 1,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    use_cache: bool = True\n) -&gt; SimulationResult\n</code></pre> <p>Pipeline execution:</p> <ol> <li>Cache lookup: SHA256 hash of <code>(T, X.tobytes(), n_sims, start, seed)</code></li> <li>Seed propagation: <pre><code>A = income.contributions(T, start, seed=seed, n_sims=n_sims)\nR = returns.generate(T, n_sims, seed=None if seed is None else seed+1)\n</code></pre></li> <li>Wealth dynamics: <pre><code>portfolio_result = portfolio.simulate(A, R, X, method=\"affine\")\n</code></pre>    Uses affine representation:    $$    W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m    $$</li> <li>Result packaging: Wrap arrays in <code>SimulationResult</code> dataclass</li> </ol> <p>Complexity: \\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\) time, same space</p> <p>Example: <pre><code>X = np.tile([0.7, 0.3], (24, 1))\nresult = model.simulate(T=24, X=X, n_sims=1000, seed=42)\n\n# Second call: O(1) (cached)\nresult2 = model.simulate(T=24, X=X, n_sims=1000, seed=42)\nassert result is result2  # same object\n</code></pre></p>"},{"location":"model/#unified-plotting-interface","title":"Unified plotting interface","text":""},{"location":"model/#plot-method","title":"<code>plot()</code> method","text":"<pre><code>def plot(\n    mode: str,\n    *,\n    T: Optional[int] = None,\n    X: Optional[np.ndarray] = None,\n    n_sims: int = 500,\n    start: Optional[date] = None,\n    seed: Optional[int] = None,\n    result: Optional[SimulationResult] = None,\n    **kwargs\n)\n</code></pre> <p>Available modes:</p> Mode Requires Simulation Description <code>\"income\"</code> No Fixed + variable + total income streams <code>\"contributions\"</code> No Monthly contribution schedule <code>\"returns\"</code> No Return distributions and trajectories <code>\"returns_cumulative\"</code> No Cumulative return evolution <code>\"returns_horizon\"</code> No Risk-return by investment horizon <code>\"wealth\"</code> Yes Portfolio dynamics (4 panels) <code>\"comparison\"</code> Yes Multi-strategy comparison <p>Auto-simulation logic: <pre><code>IF mode in {\"wealth\", \"comparison\"}:\n    IF result provided:\n        use result\n    ELSE:\n        result = self.simulate(T, X, n_sims, start, seed)  # cached\n</code></pre></p> <p>Examples: <pre><code># Direct plotting (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42, start=date(2025, 1, 1))\n\n# Reuse result across plots\nresult = model.simulate(T=24, X=X, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result, show_trajectories=True)\nmodel.plot(\"wealth\", result=result, show_trajectories=False)\n\n# Strategy comparison\nresults = {\n    \"Conservative\": model.simulate(T=24, X=X_cons, n_sims=500),\n    \"Aggressive\": model.simulate(T=24, X=X_agg, n_sims=500)\n}\nmodel.plot(\"comparison\", results=results)\n</code></pre></p>"},{"location":"model/#integration-with-optimization","title":"Integration with optimization","text":""},{"location":"model/#affine-wealth-for-convex-problems","title":"Affine wealth for convex problems","text":"<p><code>simulate()</code> uses <code>method=\"affine\"</code> internally, enabling:</p> <ol> <li>Linear constraints: \\(W_t^m(X) \\geq b_t^m\\) is affine in \\(X\\)</li> <li>Analytical gradients: \\(\\nabla_{x_s^m} W_t^m(X) = A_s F_{s,t}^m\\)</li> <li>SAA for chance constraints:    $$    \\mathbb{P}(W_t^m \\geq b) \\geq 1-\\varepsilon \\quad \\Rightarrow \\quad \\frac{1}{n_{\\text{sims}}} \\sum_{i=1}^{n_{\\text{sims}}} \\mathbb{1}_{W_t^{m,(i)} \\geq b} \\geq 1-\\varepsilon    $$</li> </ol>"},{"location":"model/#goal-feasibility-check","title":"Goal feasibility check","text":"<pre><code># Goal: $12M in Housing at T=24 with 95% confidence\nresult = model.simulate(T=24, X=X_uniform, n_sims=1000, seed=42)\ncvar = result.aggregate_metrics(account=\"Housing\")['cvar_95']\n\nif cvar &gt;= 12_000_000:\n    print(f\"Feasible! CVaR\u2089\u2085 = ${cvar:,.0f}\")\nelse:\n    print(f\"Deficit: ${12_000_000 - cvar:,.0f}\")\n</code></pre>"},{"location":"model/#cache-management","title":"Cache management","text":""},{"location":"model/#inspection","title":"Inspection","text":"<pre><code>info = model.cache_info()\n# {'size': 3, 'memory_mb': 28.7}\n</code></pre> <p>Memory estimate: \\(\\approx n_{\\text{sims}} \\cdot T \\cdot M \\cdot 24\\) bytes (wealth + returns + contributions)</p>"},{"location":"model/#trade-offs","title":"Trade-offs","text":"<p>With cache (default): - \u2705 Instant repeated calls - \u274c RAM scales with parameter space</p> <p>Without cache: <pre><code>model = FinancialModel(income, accounts, enable_cache=False)\n</code></pre> - \u2705 Minimal memory - \u274c Re-simulation on every call</p> <p>Rule: Enable cache if <code>n_params \u00d7 n_sims \u00d7 T \u00d7 M \u00d7 24 &lt; 0.5 \u00d7 RAM</code>.</p>"},{"location":"model/#usage-patterns","title":"Usage patterns","text":""},{"location":"model/#a-basic-simulation-with-reproducibility","title":"A) Basic simulation with reproducibility","text":"<pre><code>from datetime import date\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04),\n    variable=VariableIncome(base=300_000, sigma=0.15, seed=100)\n)\n\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15)\n]\n\nmodel = FinancialModel(income, accounts)\n\n# Simulate\nX = np.tile([0.7, 0.3], (36, 1))\nresult = model.simulate(T=36, X=X, n_sims=2000, seed=42, start=date(2025, 1, 1))\n</code></pre>"},{"location":"model/#b-statistical-analysis","title":"B) Statistical analysis","text":"<pre><code># Summary statistics\nprint(result.summary(confidence=0.95))\n\n# Per-simulation metrics\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"Sharpe: {metrics['sharpe'].mean():.3f} \u00b1 {metrics['sharpe'].std():.3f}\")\n\n# Distribution-level risk\nagg = result.aggregate_metrics()\nprint(f\"VaR\u2089\u2085: ${agg.loc['Housing', 'var_95']:,.0f}\")\n</code></pre>"},{"location":"model/#c-visualization","title":"C) Visualization","text":"<pre><code># Pre-simulation plots\nmodel.plot(\"income\", months=24, start=date(2025, 1, 1))\nmodel.plot(\"returns_cumulative\", T=120, n_sims=500, start=date(2025, 1, 1))\n\n# Simulation-based (auto-simulates + caches)\nmodel.plot(\"wealth\", T=24, X=X, n_sims=500, seed=42, \n           start=date(2025, 1, 1), show_trajectories=True)\n</code></pre>"},{"location":"model/#d-time-varying-allocation-glide-path","title":"D) Time-varying allocation (glide path)","text":"<pre><code>T = 60\nequity_fractions = np.linspace(0.80, 0.40, T)\nX_glide = np.column_stack([equity_fractions, 1 - equity_fractions])\n\nresult = model.simulate(T=T, X=X_glide, n_sims=500, seed=42)\nmodel.plot(\"wealth\", result=result, title=\"Glide Path Strategy\")\n</code></pre>"},{"location":"model/#key-design-decisions","title":"Key design decisions","text":""},{"location":"model/#1-seed-propagation-for-independence","title":"1. Seed propagation for independence","text":"<p>Income uses <code>seed</code>, returns use <code>seed+1</code> to avoid artificial coupling while maintaining reproducibility.</p>"},{"location":"model/#2-sha256-hashing-for-cache-keys","title":"2. SHA256 hashing for cache keys","text":"<p>Deterministic, collision-resistant (\\(P(\\text{collision}) \\approx 2^{-256}\\)), fast (\\(O(T \\cdot M)\\)).</p>"},{"location":"model/#3-simulationresult-as-dataclass","title":"3. SimulationResult as dataclass","text":"<p>Type safety, immutability enforcement, method encapsulation vs. dict with magic keys.</p>"},{"location":"model/#4-default-methodaffine","title":"4. Default <code>method=\"affine\"</code>","text":"<p>Optimization-ready (exposes gradients), acceptable memory for \\(T \\leq 100\\).</p>"},{"location":"model/#5-calendar-propagation","title":"5. Calendar propagation","text":"<p><code>start</code> flows through: <code>user \u2192 simulate(start) \u2192 result.start \u2192 plot(result) \u2192 x-axis dates</code></p>"},{"location":"model/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X\\) and return realization \\(\\{R_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m $$ is affine in \\(X\\), where \\(F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m)\\).</p> <p>Proposition 2 (Stochastic Gradient): For independent \\(A_s\\) and \\(F_{s,t}^m\\): $$ \\mathbb{E}\\left[\\nabla_{x_s^m} W_t^m(X)\\right] = \\mathbb{E}[A_s] \\cdot \\mathbb{E}[F_{s,t}^m] $$</p> <p>Proposition 3 (Convergence Rate): For IID simulations: $$ \\left|\\hat{\\mathbb{E}}_n[W_T] - \\mathbb{E}[W_T]\\right| = O_p\\left(\\frac{1}{\\sqrt{n}}\\right) $$</p>"},{"location":"model/#limitations","title":"Limitations","text":"<ol> <li> <p>Cache doesn't detect component mutations: Call <code>model.clear_cache()</code> after modifying <code>income</code> or <code>accounts</code> in-place.</p> </li> <li> <p>Fixed horizon T: For dynamic \\(T\\) optimization, use outer loop or <code>optimization.py</code> bilevel formulation.</p> </li> <li> <p>Constant correlation matrix: \\(\\Sigma\\) fixed over time (no regime-switching).</p> </li> </ol>"},{"location":"model/#complete-example","title":"Complete example","text":"<pre><code>from datetime import date\nimport numpy as np\nfrom finopt.src.income import FixedIncome, VariableIncome, IncomeModel\nfrom finopt.src.portfolio import Account\nfrom finopt.src.model import FinancialModel\n\n# Setup\nincome = IncomeModel(\n    fixed=FixedIncome(base=1_500_000, annual_growth=0.04,\n                     salary_raises={date(2025, 7, 1): 200_000}),\n    variable=VariableIncome(base=300_000, sigma=0.15, \n                           seasonality=[1.0, 0.9, 1.1, 1.0, 1.2, 1.1,\n                                       1.0, 0.9, 0.95, 1.05, 1.1, 1.3],\n                           seed=100)\n)\n\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.035, annual_volatility=0.06),\n    Account.from_annual(\"Housing\", annual_return=0.08, annual_volatility=0.15)\n]\n\nmodel = FinancialModel(income, accounts)\n\n# Simulate with glide path\nT = 36\nequity_fractions = np.linspace(0.7, 0.4, T)\nX_glide = np.column_stack([1 - equity_fractions, equity_fractions])\n\nresult = model.simulate(T=T, X=X_glide, n_sims=2000, seed=42, \n                       start=date(2025, 1, 1))\n\n# Analysis\nprint(\"=== Summary Statistics ===\")\nprint(result.summary(confidence=0.95))\n\nprint(\"\\n=== Aggregate Risk Metrics ===\")\nprint(result.aggregate_metrics())\n\nmetrics = result.metrics(account=\"Emergency\")\nprint(f\"\\nEmergency - Mean Sharpe: {metrics['sharpe'].mean():.3f}\")\n\nconv = result.convergence_analysis()\nprint(f\"\\nConvergence - Final SE: ${conv['std_error'].iloc[-1]:,.0f}\")\n\n# Visualization\nmodel.plot(\"wealth\", result=result, title=\"Glide Path Strategy\",\n           show_trajectories=True, save_path=\"glide_path.png\")\n\n# Cache info\nprint(f\"\\nCache: {model.cache_info()}\")\n</code></pre>"},{"location":"model/#references","title":"References","text":"<p>Internal modules: - income.py: Generates \\(A_t\\) (contributions) with fixed + variable streams - returns.py: Generates \\(R_t^m\\) (correlated lognormal returns) - portfolio.py: Executes \\(W_{t+1}^m = (W_t^m + A_t x_t^m)(1 + R_t^m)\\) with affine representation - optimization.py: Consumes <code>SimulationResult</code> for bilevel goal-seeking problems - utils.py: Rate conversions, financial metrics (CAGR, drawdown, Sharpe)</p>"},{"location":"optimization/","title":"<code>optimization</code> \u2014 Convex Programming for Goal-Driven Portfolios","text":"<p>Core idea: Transform financial goals into convex optimization problems via CVaR reformulation, searching over horizons to find minimum feasible time and optimal allocations.</p>"},{"location":"optimization/#philosophy-and-role","title":"Philosophy and Role","text":""},{"location":"optimization/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li><code>income.py</code> \u2192 Contribution scenarios \\(A_t\\)</li> <li><code>portfolio.py</code> \u2192 Wealth dynamics \\(W_t^m(X)\\) via affine representation</li> <li><code>optimization.py</code> \u2192 Decision synthesis: minimize \\(T\\), optimize allocations \\(X\\)</li> </ul>"},{"location":"optimization/#inversion-of-traditional-planning","title":"Inversion of Traditional Planning","text":"<p>Traditional: Given savings \\(X\\) and horizon \\(T\\), compute terminal wealth FinOpt: Given wealth goals, find minimum \\(T^*\\) and optimal \\(X^*\\)</p> <p>Requires: 1. Chance-constrained formulation: \\(\\mathbb{P}(W_t^m \\geq b) \\geq 1-\\varepsilon\\) 2. Convex reformulation via CVaR 3. Bilevel optimization: outer (minimize \\(T\\)), inner (convex program)</p>"},{"location":"optimization/#mathematical-foundations","title":"Mathematical Foundations","text":""},{"location":"optimization/#wealth-evolution","title":"Wealth Evolution","text":"<p>Multiple accounts \\(m \\in \\{1,\\dots,M\\}\\):</p> \\[ W_{t+1}^m = \\big(W_t^m + A_t x_t^m\\big)(1 + R_t^m) \\] <p>Closed-form (affine representation):</p> \\[ \\boxed{ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s \\, x_s^m \\, F_{s,t}^m } \\] <p>where accumulation factor:</p> \\[ F_{s,t}^m := \\prod_{\\tau=s+1}^{t} (1 + R_\\tau^m) \\] <p>Key consequences: - Affinity: \\(W_t^m(X)\\) linear in \\(X\\) \u2192 enables convex programming - Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) \u2192 analytical derivatives - Efficiency: \\(O(1)\\) wealth evaluation, no recursion</p>"},{"location":"optimization/#allocation-simplex","title":"Allocation Simplex","text":"<p>Decision variables satisfy budget constraint:</p> \\[ \\mathcal{X}_T = \\left\\{ X \\in \\mathbb{R}^{T \\times M} : x_t^m \\geq 0, \\; \\sum_{m=1}^M x_t^m = 1, \\; \\forall t \\right\\} \\] <p>Cartesian product of \\(T\\) probability simplices: \\(\\mathcal{X}_T = \\Delta^{M-1} \\times \\cdots \\times \\Delta^{M-1}\\).</p>"},{"location":"optimization/#goal-framework","title":"Goal Framework","text":""},{"location":"optimization/#goal-primitives","title":"Goal Primitives","text":"<p>IntermediateGoal (fixed time \\(t\\)): $$ \\mathbb{P}(W_t^m(X) \\geq b_t) \\geq 1 - \\varepsilon_t $$</p> <p>TerminalGoal (variable horizon \\(T\\)): $$ \\mathbb{P}(W_T^m(X) \\geq b) \\geq 1 - \\varepsilon $$</p> <p>Example: <pre><code>from datetime import date\n\ngoals = [\n    IntermediateGoal(date=date(2026, 1, 1), account=\"Emergency\",\n                     threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\",\n                 threshold=20_000_000, confidence=0.90)\n]\n</code></pre></p>"},{"location":"optimization/#goalset-algebra","title":"GoalSet Algebra","text":"<p>Partition: \\(\\mathcal{G} = \\mathcal{G}_{\\text{int}} \\cup \\mathcal{G}_{\\text{term}}\\)</p> <p>Minimum horizon constraint: $$ T \\geq T_{\\min} := \\max_{g \\in \\mathcal{G}_{\\text{int}}} t_g $$</p> <p>Heuristic for terminal-only goals:</p> <p>Uses conservative accumulation analysis with account-specific returns:</p> \\[ T_{\\text{start}} = \\max_{g \\in \\mathcal{G}_{\\text{term}}} \\left\\lceil \\frac{b_g - W_0^m (1+\\mu_m)^{T_{\\min}}}{A_{\\text{avg}} \\cdot \\alpha \\cdot (1+\\mu_m - \\sigma_m)} \\right\\rceil \\] <p>where: - \\(\\mu_m\\), \\(\\sigma_m\\) from <code>Account.monthly_return</code> and <code>Account.monthly_volatility</code> - \\(\\alpha\\) = safety margin (default 0.75) - \\(A_{\\text{avg}}\\) = average monthly contribution</p> <p>Implementation: <code>GoalSet.estimate_minimum_horizon(monthly_contribution, accounts, safety_margin=0.75)</code></p>"},{"location":"optimization/#bilevel-optimization","title":"Bilevel Optimization","text":""},{"location":"optimization/#problem-statement","title":"Problem Statement","text":"\\[ \\boxed{ \\min_{T \\in \\mathbb{N}} \\;\\; T \\quad \\text{s.t.} \\quad \\mathcal{F}_T \\neq \\emptyset } \\] <p>where goal-feasible set:</p> \\[ \\mathcal{F}_T := \\left\\{ X \\in \\mathcal{X}_T : \\begin{aligned} &amp; \\mathbb{P}\\big(W_t^m(X) \\geq b_t^m\\big) \\geq 1-\\varepsilon_t^m, \\; \\forall g \\in \\mathcal{G}_{\\text{int}} \\\\ &amp; \\mathbb{P}\\big(W_T^m(X) \\geq b^m\\big) \\geq 1-\\varepsilon^m, \\; \\forall g \\in \\mathcal{G}_{\\text{term}} \\end{aligned} \\right\\} \\] <p>Inner problem (fixed \\(T\\)): $$ \\max_{X \\in \\mathcal{F}_T} f(X) $$</p>"},{"location":"optimization/#implemented-objectives","title":"Implemented Objectives","text":"<p>All objectives exploit affine wealth \\(W_t^m(X) = b + \\Phi X\\) for convexity. The following objectives are currently implemented in <code>CVaROptimizer</code>:</p> <p>1. risky (linear program - fastest): $$ f(X) = \\mathbb{E}\\left[\\sum_{m=1}^M W_T^m(X)\\right] $$ Maximizes expected total terminal wealth. Pure wealth accumulation without risk considerations.</p> <p>2. balanced (turnover minimization): $$ f(X) = -\\sum_{t=1}^{T-1} \\sum_{m=1}^M (x_{t+1,m} - x_t^m)^2 $$ Minimizes portfolio rebalancing via squared L2 penalty on allocation changes. Negative sign converts minimization to maximization problem for solver.</p> <p>3. risky_turnover (wealth with turnover penalty): $$ f(X) = \\mathbb{E}\\left[\\sum_{m=1}^M W_T^m\\right] - \\lambda \\sum_{t=1}^{T-1} \\sum_{m=1}^M (x_{t+1,m} - x_t^m)^2 $$ Balances wealth accumulation against transaction costs. Parameter \\(\\lambda\\) controls penalty strength (typical: 0.1-1.0 for normalized allocations, 1000-50000 for monetary scale).</p> <p>4. conservative (mean-standard deviation): $$ f(X) = \\mathbb{E}[W_T] - \\lambda \\cdot \\text{Std}(W_T) $$ Risk-averse objective penalizing volatility. Uses standard deviation (not variance) for intuitive scaling. Parameter \\(\\lambda\\) controls risk aversion (typical: 0.1-1.0).</p> <p>Note: While variance \\(\\text{Var}(W_T)\\) would be quadratic convex, the code uses standard deviation \\(\\text{Std}(W_T)\\) which is concave. This maintains the correct optimization direction (maximizing a concave function is convex) but differs from classical mean-variance formulations.</p>"},{"location":"optimization/#cvar-reformulation","title":"CVaR Reformulation","text":""},{"location":"optimization/#epigraphic-formulation-rockafellar-uryasev-2000","title":"Epigraphic Formulation (Rockafellar &amp; Uryasev 2000)","text":"<p>Transform chance constraint \\(\\mathbb{P}(W \\geq b) \\geq 1-\\varepsilon\\) into convex constraint:</p> \\[ \\text{CVaR}_\\varepsilon(b - W) \\leq 0 \\] <p>Epigraphic representation: $$ \\text{CVaR}\\alpha(L) = \\min{\\gamma, z} \\left{ \\gamma + \\frac{1}{\\alpha N} \\sum_{i=1}^N z^i \\right} $$ subject to: $$ z^i \\geq L^i - \\gamma, \\quad z^i \\geq 0, \\quad \\forall i $$</p> <p>where \\(L^i = b - W^i\\) is shortfall in scenario \\(i\\).</p>"},{"location":"optimization/#convex-program-formulation","title":"Convex Program Formulation","text":"<p>Decision variables: - \\(X \\in \\mathbb{R}^{T \\times M}\\): allocations - \\(\\gamma_g \\in \\mathbb{R}\\): VaR level per goal \\(g\\) - \\(z_g \\in \\mathbb{R}_+^N\\): excess shortfall per goal \\(g\\)</p> <p>Constraints:</p> <ol> <li> <p>Simplex: \\(\\sum_m x_t^m = 1, \\; x_t^m \\geq 0\\)</p> </li> <li> <p>CVaR (per goal): $$ \\begin{aligned} z_g^i &amp;\\geq (\\text{threshold}g - W{t_g}^{m_g,i}(X)) - \\gamma_g \\ \\gamma_g &amp;+ \\frac{1}{\\varepsilon_g N} \\sum_{i=1}^N z_g^i \\leq 0 \\end{aligned} $$</p> </li> </ol> <p>Affine wealth construction: <pre><code>def build_wealth_affine(t, m):\n    \"\"\"W[:,t,m] = b + \u03a6 @ X[:t,m]\"\"\"\n    b = W0[m] * F[:, 0, t, m]  # Constant term\n    if t == 0:\n        return b\n    Phi = A[:, :t] * F[:, :t, t, m]  # Coefficient matrix\n    return b + Phi @ X[:t, m]\n</code></pre></p>"},{"location":"optimization/#dcp-compliance-disciplined-convex-programming","title":"DCP Compliance (Disciplined Convex Programming)","text":"<p>Variance formulation (when used):</p> \\[ \\text{Var}(W) = \\frac{1}{N}\\sum_{i=1}^N (W_i - \\bar{W})^2 \\] <p>Implemented via <code>cp.sum_squares</code>: <pre><code>mean_wealth = cp.sum(W_T_total) / n_sims\nvariance = cp.sum_squares(W_T_total - mean_wealth) / n_sims\n</code></pre></p> <p>Convexity: Sum of squares of affine expressions is convex (SOC representable).</p> <p>Turnover formulation:</p> <p>Squared L2 norm is convex: <pre><code>turnover = cp.sum_squares(X[1:, :] - X[:-1, :])\n</code></pre></p> <p>Equivalent to \\(\\sum_{t,m} (x_{t+1,m} - x_t^m)^2\\).</p>"},{"location":"optimization/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"optimization/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>AllocationOptimizer (ABC)\n    \u251c\u2500 solve(T, A, R, W0, goal_set, ...) \u2192 OptimizationResult\n    \u251c\u2500 _check_feasibility(...) \u2192 bool\n    \u251c\u2500 _compute_objective(W, X, T, M) \u2192 float\n    \u251c\u2500 _objective_risky(W, X, T, M)\n    \u251c\u2500 _objective_balanced(W, X, T, M)\n    \u251c\u2500 _objective_risky_turnover(W, X, T, M)\n    \u2514\u2500 _objective_conservative(W, X, T, M)\n\nCVaROptimizer(AllocationOptimizer)\n    \u251c\u2500 cp: CVXPY module\n    \u251c\u2500 objective: str \u2208 {\"risky\", \"balanced\", \"risky_turnover\", \"conservative\"}\n    \u2514\u2500 solve(...) \u2192 OptimizationResult\n\nGoalSeeker\n    \u251c\u2500 optimizer: AllocationOptimizer\n    \u251c\u2500 seek(..., search_method=\"binary\") \u2192 OptimizationResult\n    \u251c\u2500 _linear_search(...) \u2192 OptimizationResult\n    \u2514\u2500 _binary_search(...) \u2192 OptimizationResult\n</code></pre>"},{"location":"optimization/#key-design-changes","title":"Key Design Changes","text":"<p>GoalSet passed explicitly: Caller creates <code>GoalSet</code> once before optimization loop, avoiding redundant validation:</p> <pre><code># In GoalSeeker.seek()\ngoal_set = GoalSet(goals, accounts, start_date)\n\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(\n        T=T, A=A, R=R, W0=W0,\n        goal_set=goal_set,  # Pre-validated, reused\n        **solver_kwargs\n    )\n</code></pre> <p>Separation of responsibilities: - <code>GoalSet</code>: Validation, account resolution, minimum horizon estimation - <code>AllocationOptimizer</code>: Convex programming, feasibility checking - <code>GoalSeeker</code>: Bilevel search, warm starting</p>"},{"location":"optimization/#cvaroptimizersolve-algorithm","title":"CVaROptimizer.solve() Algorithm","text":"<pre><code># 1. Validate inputs\nif T &lt; goal_set.T_min:\n    raise ValueError(f\"T={T} &lt; goal_set.T_min\")\n\n# 2. Precompute accumulation factors\nportfolio = Portfolio(goal_set.accounts)\nF = portfolio.compute_accumulation_factors(R)  # (n_sims, T+1, T+1, M)\n\n# 3. Decision variables\nX = cp.Variable((T, M), nonneg=True)\ngamma = {g: cp.Variable() for g in goals}\nz = {g: cp.Variable(n_sims, nonneg=True) for g in goals}\n\n# 4. Affine wealth helper\ndef build_wealth_affine(t, m):\n    b = W0[m] * F[:, 0, t, m]\n    if t == 0:\n        return b\n    Phi = A[:, :t] * F[:, :t, t, m]\n    return b + Phi @ X[:t, m]\n\n# 5. Constraints\nconstraints = [cp.sum(X, axis=1) == 1]  # Simplex\n\nfor goal in goal_set.terminal_goals:\n    m = goal_set.get_account_index(goal)\n    W_T_m = build_wealth_affine(T, m)\n    shortfall = goal.threshold - W_T_m\n    constraints += [\n        z[goal] &gt;= shortfall - gamma[goal],\n        gamma[goal] + cp.sum(z[goal])/(goal.epsilon * n_sims) &lt;= 0\n    ]\n\nfor goal in goal_set.intermediate_goals:\n    m = goal_set.get_account_index(goal)\n    t = goal_set.get_resolved_month(goal)\n    W_t_m = build_wealth_affine(t, m)\n    shortfall = goal.threshold - W_t_m\n    constraints += [\n        z[goal] &gt;= shortfall - gamma[goal],\n        gamma[goal] + cp.sum(z[goal])/(goal.epsilon * n_sims) &lt;= 0\n    ]\n\n# 6. Objective (dispatch by self.objective)\nW_T_total = sum(build_wealth_affine(T, m) for m in range(M))\nmean_wealth = cp.sum(W_T_total) / n_sims\n\nif self.objective == \"risky\":\n    objective = cp.Maximize(mean_wealth)\nelif self.objective == \"conservative\":\n    lambda_ = self.objective_params.get(\"lambda\", 0.5)\n    variance = cp.sum_squares(W_T_total - mean_wealth) / n_sims\n    objective = cp.Maximize(mean_wealth - lambda_ * variance)\nelif self.objective == \"risky_turnover\":\n    lambda_ = self.objective_params.get(\"lambda\", 15000)\n    turnover = cp.sum_squares(X[1:, :] - X[:-1, :]) if T &gt; 1 else 0\n    objective = cp.Maximize(mean_wealth - lambda_ * turnover)\nelif self.objective == \"balanced\":\n    turnover = cp.sum_squares(X[1:, :] - X[:-1, :]) if T &gt; 1 else 0\n    objective = cp.Maximize(-turnover)\n\n# 7. Solve\nprob = cp.Problem(objective, constraints)\nprob.solve(solver=cp.ECOS, verbose=verbose, max_iters=max_iters)\n\n# 8. Extract and validate\nX_star = X.value\n# Project to simplex if needed (numerical tolerance)\nfor t in range(T):\n    if abs(X_star[t, :].sum() - 1.0) &gt; 1e-6:\n        X_star[t, :] = np.maximum(X_star[t, :], 0)\n        X_star[t, :] /= X_star[t, :].sum()\n\n# 9. Exact feasibility check\nfeasible = self._check_feasibility(X_star, A, R, W0, portfolio, goal_set)\n\nreturn OptimizationResult(X=X_star, T=T, feasible=feasible, ...)\n</code></pre>"},{"location":"optimization/#goalseeker-search-strategies","title":"GoalSeeker Search Strategies","text":""},{"location":"optimization/#linear-search-safe-slower","title":"Linear Search (Safe, Slower)","text":"<p>Algorithm: <pre><code>X_prev = None\nfor T in range(T_start, T_max + 1):\n    result = optimizer.solve(T, A, R, W0, goal_set, X_init=X_prev)\n    if result.feasible:\n        return result  # Found T*\n    # Warm start: extend policy\n    if result.X is not None:\n        X_prev = np.vstack([result.X, result.X[-1:, :]])\n</code></pre></p> <p>Complexity: \\(O(T^* - T_{\\text{start}})\\) iterations</p> <p>Properties: - Always finds true \\(T^*\\) if feasible - No assumptions required - Warm start accelerates convergence</p>"},{"location":"optimization/#binary-search-faster-assumes-monotonicity","title":"Binary Search (Faster, Assumes Monotonicity)","text":"<p>Algorithm: <pre><code>left, right = T_start, T_max\nbest_result = None\n\nwhile left &lt; right:\n    mid = (left + right) // 2\n\n    # Warm start from previous result\n    X_init = None\n    if best_result and best_result.T &lt; mid:\n        n_extend = mid - best_result.T\n        X_init = np.vstack([\n            best_result.X,\n            np.tile(best_result.X[-1:, :], (n_extend, 1))\n        ])\n\n    result = optimizer.solve(mid, A, R, W0, goal_set, X_init=X_init)\n\n    if result.feasible:\n        best_result = result\n        right = mid  # Search lower half\n    else:\n        left = mid + 1  # Search upper half\n\nreturn best_result\n</code></pre></p> <p>Complexity: \\(O(\\log(T_{\\max} - T_{\\text{start}}))\\) iterations</p> <p>Assumption: Monotonicity \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p> <p>When to use: - Typical financial planning scenarios (safe) - Contribution schedules are non-decreasing or stable - Goal structure is well-behaved</p> <p>When to avoid: - Contributions have sudden drops - Pathological goal configurations - Safety-critical applications \u2192 use linear search</p>"},{"location":"optimization/#solver-configuration","title":"Solver Configuration","text":""},{"location":"optimization/#cvxpy-solvers","title":"CVXPY Solvers","text":"<p>ECOS (default): - Type: Interior-point (LP/SOCP) - Speed: Fast (30-80ms typical) - Stability: Good for well-conditioned problems - Recommended for most use cases</p> <p>SCS (robust): - Type: First-order conic solver - Speed: Moderate - Stability: Handles ill-conditioned problems - Use when ECOS fails or numerical issues</p> <p>CLARABEL (modern): - Type: Interior-point - Speed: Balanced - Stability: Good numerical properties - Alternative to ECOS for difficult problems</p>"},{"location":"optimization/#solver-options","title":"Solver Options","text":"<pre><code>result = optimizer.solve(\n    T=24, A=A, R=R, W0=W0, goal_set=goal_set,\n    solver='ECOS',\n    verbose=True,\n    max_iters=10000,\n    abstol=1e-7,  # Absolute tolerance\n    reltol=1e-6   # Relative tolerance\n)\n</code></pre>"},{"location":"optimization/#complexity-analysis","title":"Complexity Analysis","text":"<p>Variables: \\(T \\cdot M + G \\cdot (1 + N) + f(obj)\\) - \\(T \\cdot M\\) allocations \\(X\\) - \\(G\\) VaR levels \\(\\gamma_g\\) - \\(G \\cdot N\\) excess shortfalls \\(z_g^i\\) - \\(f(obj)\\) = objective-dependent (e.g., variance auxiliary variables)</p> <p>Constraints: \\(T + G \\cdot (N + 1) + g(obj)\\) - \\(T\\) simplex constraints - \\(G \\cdot N\\) CVaR auxiliary constraints - \\(G\\) CVaR threshold constraints - \\(g(obj)\\) = objective-dependent</p> <p>Example: \\(T=24, M=3, G=3, N=300\\) - Variables: \\(72 + 903 = 975\\) - Constraints: \\(24 + 903 = 927\\) - Solve time: 30-80ms (ECOS)</p> <p>Interior-point complexity: \\(O(n^{3.5})\\) where \\(n\\) = number of variables</p>"},{"location":"optimization/#numerical-considerations","title":"Numerical Considerations","text":""},{"location":"optimization/#memory-management","title":"Memory Management","text":"<p>Accumulation factor tensor \\(F \\in \\mathbb{R}^{N \\times (T+1) \\times (T+1) \\times M}\\):</p> <p>Size: \\(N \\cdot T^2 \\cdot M \\cdot 8\\) bytes</p> <p>Example: \\(N=500, T=120, M=5\\) \u2192 14 GB \u26a0\ufe0f</p> <p>Mitigation: 1. Use <code>Portfolio.compute_accumulation_factors()</code> with optimized storage 2. Batch scenarios (process \\(N\\) in chunks) 3. On-demand computation in optimizer (trade memory for compute) 4. Reduce \\(N\\) for preliminary runs (100-200 sufficient for testing)</p>"},{"location":"optimization/#simplex-projection","title":"Simplex Projection","text":"<p>Due to finite solver tolerance, may have \\(|\\sum_m x_t^m - 1| \\approx 10^{-8}\\):</p> <pre><code>for t in range(T):\n    row_sum = X_star[t, :].sum()\n    if abs(row_sum - 1.0) &gt; 1e-6:\n        X_star[t, :] = np.maximum(X_star[t, :], 0)  # Clip negatives\n        X_star[t, :] /= X_star[t, :].sum()  # Renormalize\n</code></pre> <p>Applied automatically in <code>CVaROptimizer.solve()</code> post-optimization.</p>"},{"location":"optimization/#feasibility-validation","title":"Feasibility Validation","text":"<p>Two-stage validation:</p> <ol> <li>CVXPY constraints: CVaR constraints during solve</li> <li>Convex relaxation via epigraphic formulation</li> <li> <p>Solver tolerances may allow small violations</p> </li> <li> <p>Exact SAA: Non-smoothed indicator check via <code>_check_feasibility()</code> <pre><code>violations = W[:, t, m] &lt; goal.threshold\nviolation_rate = violations.mean()\nfeasible = violation_rate &lt;= goal.epsilon\n</code></pre></p> </li> </ol> <p>Prevents false positives from numerical approximations.</p> <p>Implementation pattern: <pre><code># After CVXPY solve\nX_star = X.value\nfeasible = self._check_feasibility(\n    X_star, A, R, W0, portfolio, goal_set\n)\n</code></pre></p>"},{"location":"optimization/#theoretical-guarantees","title":"Theoretical Guarantees","text":"<p>Theorem 1 (Affine Wealth Representation): For any allocation policy \\(X \\in \\mathcal{X}_T\\) and return realization \\(\\{R_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m $$ is affine in \\(X\\), enabling convex programming formulations.</p> <p>Theorem 2 (CVaR Epigraphic Convexity): The epigraphic reformulation $$ \\text{CVaR}\\varepsilon(b - W) = \\inf{\\gamma, z} \\left{ \\gamma + \\frac{1}{\\varepsilon N}\\sum_{i=1}^N z^i : z^i \\geq b - W^i - \\gamma, \\, z^i \\geq 0 \\right} $$ defines a convex constraint in \\(X\\) when \\(W(X)\\) is affine.</p> <p>Theorem 3 (Objective Convexity): All implemented objectives maintain convexity: - risky: Linear in \\(X\\) \u2192 convex - balanced: \\(-\\|X\\|_2^2\\) \u2192 concave (maximizing concave is convex) - risky_turnover: Linear - convex \u2192 convex - conservative: Linear - concave \u2192 convex (when using Std, not Var)</p> <p>Corollary (Global Optimality): CVXPY interior-point solvers return global optimum for convex programs. No local minima exist.</p> <p>Theorem 4 (SAA Convergence): Under bounded returns and Lipschitz continuity in \\(X\\): $$ \\frac{1}{N}\\sum_{i=1}^N \\mathbb{1}{W_t^m(X; \\omega^{(i)}) \\geq b} \\xrightarrow{a.s.} \\mathbb{P}(W_t^m(X) \\geq b) $$ as \\(N \\to \\infty\\).</p> <p>Theorem 5 (Bilevel Optimality): - Linear search: Finds true \\(T^*\\) if inner solver succeeds - Binary search: Finds \\(T^*\\) under monotonicity assumption \\(\\mathcal{F}_T \\subseteq \\mathcal{F}_{T+1}\\)</p> <p>Proposition (Iteration Reduction): Binary search reduces expected iterations from \\(O(T^* - T_{\\text{start}})\\) to \\(O(\\log(T_{\\max} - T_{\\text{start}}))\\).</p>"},{"location":"optimization/#diagnostics-and-debugging","title":"Diagnostics and Debugging","text":""},{"location":"optimization/#verbose-output","title":"Verbose Output","text":"<p>Enable <code>verbose=True</code> for detailed solver information:</p> <pre><code>[CVXPY Solution]\n  Status: optimal\n  Objective: 21543678.92\n  Solve time: 0.067s\n\n[Simplex Validation]\n  Max |\u03a3x_t - 1|: 3.45e-09\n  X bounds: [0.0000, 1.0000]\n\n[Goal Satisfaction Diagnostics]\n  Account 0 (Emergency):\n    Threshold:        5,500,000\n    Mean wealth:      6,234,567\n    Violation rate: 8.20% (max: 10.00%)\n    CVaR value:         -1234.56 (target: \u2264 0)\n\n  Account 1 (Housing) at month 12:\n    Threshold:       10,000,000\n    Mean wealth:     11,456,789\n    Violation rate: 7.50% (max: 10.00%)\n    CVaR value:         -2345.67 (target: \u2264 0)\n</code></pre>"},{"location":"optimization/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>1. Infeasible problem: <pre><code>Status: infeasible\nOptimal: T*=240 (exhausted T_max)\n</code></pre> Diagnosis: Goals too aggressive for available resources</p> <p>Solutions: - Increase <code>T_max</code> (extend planning horizon) - Reduce goal thresholds (lower target wealth) - Increase <code>epsilon</code> (lower confidence requirement: 0.90 \u2192 0.85) - Increase contributions (higher income allocation) - Verify initial wealth \\(W_0\\) is sufficient</p> <p>2. Numerical instability: <pre><code>Max |\u03a3x_t - 1|: 1.23e-04\n\u26a0\ufe0f  Minor simplex violations detected\n</code></pre> Diagnosis: Solver tolerance issues</p> <p>Solutions: - Tighten solver tolerances: <code>abstol=1e-8, reltol=1e-7</code> - Switch solver: <code>ECOS</code> \u2192 <code>SCS</code> (more robust) - Check for extreme returns in \\(R\\) (e.g., \\(|R_t^m| &gt; 1\\)) - Scale problem: normalize wealth to \\([0, 1]\\) range</p> <p>3. Slow convergence: <pre><code>Solve time: 12.345s (expected: 0.05-0.10s)\n</code></pre> Diagnosis: Problem size or conditioning issues</p> <p>Solutions: - Reduce scenarios: \\(N=500\\) \u2192 \\(N=200\\) for testing - Simplify objective: <code>balanced</code> \u2192 <code>risky</code> (LP faster than SOCP) - Use warm start: pass <code>X_init</code> from previous horizon - Reduce horizon for initial exploration: \\(T=120\\) \u2192 \\(T=60\\)</p> <p>4. Goal validation failure: <pre><code>Status: optimal (CVXPY)\nFeasibility check: FAILED\n  Violation rate: 12.5% (max: 10.0%)\n</code></pre> Diagnosis: CVaR approximation vs exact SAA mismatch</p> <p>Solutions: - Increase scenarios: \\(N=300\\) \u2192 \\(N=500\\) (reduces sampling error) - Tighten CVaR tolerance: adjust solver <code>abstol</code> - Verify accumulation factor computation - Check for numerical underflow/overflow in \\(F\\)</p> <p>5. Binary search failure: <pre><code>Binary search failed: T=87 infeasible\nMonotonicity assumption may be violated\n</code></pre> Diagnosis: Non-monotonic feasible set</p> <p>Solutions: - Switch to linear search: <code>search_method=\"linear\"</code> - Inspect contribution schedule for sudden drops - Verify goal configuration (check intermediate goals) - Plot feasibility vs \\(T\\) to identify non-monotonicity</p>"},{"location":"optimization/#usage-examples","title":"Usage Examples","text":""},{"location":"optimization/#basic-optimization","title":"Basic Optimization","text":"<pre><code>from finopt.src.optimization import CVaROptimizer, GoalSeeker\nfrom finopt.src.goals import TerminalGoal\nfrom datetime import date\n\n# Setup\naccounts = [\n    Account.from_annual(\"Emergency\", 0.04, 0.05, initial_wealth=1_000_000),\n    Account.from_annual(\"Housing\", 0.07, 0.12, initial_wealth=500_000)\n]\nW0 = np.array([1_000_000, 500_000])\n\ngoals = [\n    TerminalGoal(account=\"Emergency\", threshold=5_500_000, confidence=0.90),\n    TerminalGoal(account=\"Housing\", threshold=20_000_000, confidence=0.90)\n]\n\n# Optimizer with terminal wealth objective\noptimizer = CVaROptimizer(\n    n_accounts=len(accounts),\n    objective='risky',\n    account_names=[a.name for a in accounts]\n)\n\n# Generators for scenarios\ndef A_gen(T, n, s):\n    return model.income.contributions(T, n_sims=n, seed=s, output=\"array\")\n\ndef R_gen(T, n, s):\n    return model.returns.generate(T, n_sims=n, seed=s)\n\n# Bilevel search\nseeker = GoalSeeker(optimizer, T_max=120, verbose=True)\nresult = seeker.seek(\n    goals=goals,\n    A_generator=A_gen,\n    R_generator=R_gen,\n    W0=W0,\n    accounts=accounts,\n    start_date=date(2025, 1, 1),\n    n_sims=500,\n    seed=42,\n    search_method=\"binary\"\n)\n\nprint(f\"Optimal horizon: T*={result.T} months\")\nprint(f\"Feasible: {result.feasible}\")\n</code></pre>"},{"location":"optimization/#custom-objective-with-turnover-penalty","title":"Custom Objective with Turnover Penalty","text":"<pre><code>optimizer = CVaROptimizer(\n    n_accounts=3,\n    objective='risky_turnover',\n    objective_params={'lambda': 10000},  # Turnover penalty\n    account_names=[\"Emergency\", \"Housing\", \"Retirement\"]\n)\n\nresult = optimizer.solve(\n    T=24,\n    A=A_scenarios,\n    R=R_scenarios,\n    W0=np.array([1e6, 0.5e6, 2e6]),\n    goal_set=goal_set,\n    solver='ECOS',\n    verbose=True\n)\n</code></pre>"},{"location":"optimization/#post-optimization-validation","title":"Post-Optimization Validation","text":"<pre><code># Simulate with optimal policy\nsim_result = model.simulate(\n    T=result.T,\n    X=result.X,\n    n_sims=1000,  # Higher fidelity\n    seed=999\n)\n\n# Validate goals\nstatus = result.validate_goals(sim_result)\n\nfor goal, metrics in status.items():\n    print(f\"{goal.account}:\")\n    print(f\"  Violation rate: {metrics['violation_rate']:.2%}\")\n    print(f\"  Required confidence: {goal.confidence:.2%}\")\n    print(f\"  Status: {'\u2713 PASS' if metrics['satisfied'] else '\u2717 FAIL'}\")\n</code></pre>"},{"location":"optimization/#references","title":"References","text":"<p>Rockafellar, R.T. and Uryasev, S. (2000). Optimization of conditional value-at-risk. Journal of Risk, 2, 21-42.</p> <p>Markowitz, H. (1952). Portfolio Selection. The Journal of Finance, 7(1), 77-91.</p>"},{"location":"portfolio/","title":"<code>portfolio</code> \u2014 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Execute wealth dynamics under allocation policies, providing the mathematical foundation for optimization-driven portfolio construction. <code>portfolio.py</code> is the executor layer: it receives pre-generated contributions <code>A</code> (from <code>income.py</code>) and returns <code>R</code> (from <code>returns.py</code>), applies allocation policy <code>X</code>, and computes wealth trajectories <code>W</code> via recursive or closed-form methods.</p>"},{"location":"portfolio/#why-a-dedicated-portfolio-module","title":"Why a dedicated portfolio module?","text":"<p>Financial optimization requires separating concerns: - <code>income.py</code> \u2192 cash availability - <code>returns.py</code> \u2192 stochastic return generation - <code>portfolio.py</code> \u2192 wealth evolution given allocations - <code>optimization.py</code> \u2192 policy search</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to <code>ReturnModel</code>) - Optimization-ready: Affine wealth representation exposes analytical gradients - Batch processing: Vectorized Monte Carlo execution (no Python loops) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion</p>"},{"location":"portfolio/#design-principles","title":"Design principles","text":"<ol> <li>Separation of concerns</li> <li>Portfolio executes dynamics, does NOT generate stochastic processes</li> <li> <p>Returns/contributions are external inputs (not embedded models)</p> </li> <li> <p>Vectorized computation</p> </li> <li>Full batch processing: <code>(n_sims, T, M)</code> arrays without Python-level loops</li> <li> <p>Matches <code>income.py</code> pattern: <code>n_sims</code> parameter for Monte Carlo generation</p> </li> <li> <p>Optimization-first design</p> </li> <li>Affine wealth formula enables analytical gradients: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\)</li> <li> <p>Direct integration with convex solvers (CVXPY, scipy.optimize)</p> </li> <li> <p>Annual parameters by default</p> </li> <li>User-facing API uses intuitive annual returns/volatility</li> <li>Internal storage in monthly space (canonical form)</li> <li> <p>Properties provide dual temporal views without conversions</p> </li> <li> <p>Calendar alignment inheritance</p> </li> <li>Contributions <code>A</code> from <code>income.contributions()</code> are calendar-aware</li> <li>Portfolio preserves temporal semantics (no date handling needed)</li> </ol>"},{"location":"portfolio/#the-two-core-surfaces","title":"The two core surfaces","text":""},{"location":"portfolio/#1-account","title":"1) <code>Account</code>","text":"<p>Metadata container for investment account with dual temporal parameter access.</p> <p>Parameters: - <code>name</code>: account identifier (e.g., \"Emergency\", \"Housing\") - <code>initial_wealth</code>: starting balance \\(W_0^m\\) (non-negative) - <code>return_strategy</code>: dict with monthly parameters <code>{\"mu\": float, \"sigma\": float}</code></p> <p>Constructor methods (recommended): <pre><code>Account.from_annual(name, annual_return, annual_volatility, initial_wealth=0.0)\nAccount.from_monthly(name, monthly_mu, monthly_sigma, initial_wealth=0.0)\n</code></pre></p> <p>Properties: - <code>monthly_params</code>: canonical storage format <code>{\"mu\": float, \"sigma\": float}</code> - <code>annual_params</code>: user-friendly view <code>{\"return\": float, \"volatility\": float}</code></p> <p>Parameter conversion: $$ \\begin{aligned} \\mu_{\\text{monthly}} &amp;= (1 + r_{\\text{annual}})^{1/12} - 1 \\quad \\text{[geometric compounding]} \\ \\sigma_{\\text{monthly}} &amp;= \\frac{\\sigma_{\\text{annual}}}{\\sqrt{12}} \\quad \\text{[time scaling]} \\end{aligned} $$</p> <p>Interpretation: Lightweight struct consumed by <code>ReturnModel</code> for return generation. No embedded stochastic processes\u2014pure metadata.</p> <p>Key behaviors: - Round-trip conversion: <code>monthly_to_annual(annual_to_monthly(r)) \u2248 r</code> - Validation: ensures \\(W_0^m \\geq 0\\), \\(\\sigma \\geq 0\\) - String representation uses annual parameters for readability</p>"},{"location":"portfolio/#2-portfolio","title":"2) <code>Portfolio</code>","text":"<p>Multi-account wealth dynamics executor with allocation policy support.</p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects (metadata only, no return models)</p> <p>Method signature: <pre><code>def simulate(\n    self,\n    A: np.ndarray,      # Contributions: (T,) or (n_sims, T)\n    R: np.ndarray,      # Returns: (n_sims, T, M)\n    X: np.ndarray,      # Allocations: (T, M)\n    method: Literal[\"recursive\", \"affine\"] = \"affine\"\n) -&gt; dict\n</code></pre></p> <p>Core wealth dynamics: $$ W_{t+1}^m = \\big(W_t^m + A_t^m\\big)(1 + R_t^m) $$ where: - \\(A_t^m = x_t^m \\cdot A_t\\) (allocated contribution) - \\(\\sum_{m=1}^M x_t^m = 1\\), \\(x_t^m \\geq 0\\) (budget constraint)</p> <p>Returns: <pre><code>{\n    \"wealth\": np.ndarray,        # (n_sims, T+1, M)\n    \"total_wealth\": np.ndarray   # (n_sims, T+1)\n}\n</code></pre></p> <p>Computation methods:</p> <ol> <li>Recursive (default for simulation):</li> <li>Time: \\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\)</li> <li>Memory: \\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\)</li> <li> <p>Iterative evolution: \\(W_{t+1} = (W_t + A_t)(1+R_t)\\) vectorized over simulations</p> </li> <li> <p>Affine (preferred for optimization):</p> </li> <li>Time: \\(O(T^2 \\cdot M \\cdot n_{\\text{sims}})\\) (factor precomputation + application)</li> <li>Memory: \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) (stores accumulation factors \\(F\\))</li> <li>Closed-form: wealth is linear in allocation policy \\(X\\)</li> </ol> <p>Key behaviors: - Automatic broadcasting: deterministic <code>A</code> (shape <code>(T,)</code>) broadcast to <code>(n_sims, T)</code> - Validation: checks \\(X \\geq 0\\), \\(\\sum_m x_t^m = 1\\) for all \\(t\\) - Initial wealth: \\(W_0^m\\) from <code>self.accounts[m].initial_wealth</code> - No stochastic generation: assumes <code>R</code> is pre-generated externally</p>"},{"location":"portfolio/#affine-wealth-representation","title":"Affine wealth representation","text":""},{"location":"portfolio/#closed-form-formula","title":"Closed-form formula","text":"<p>The recursive dynamics admit a closed-form solution:</p> \\[ \\boxed{ W_t^m(X) = W_0^m \\cdot F_{0,t}^m + \\sum_{s=0}^{t-1} A_s \\, x_s^m \\, F_{s,t}^m } \\] <p>where the accumulation factor from month \\(s\\) to \\(t\\) is:</p> \\[ F_{s,t}^m := \\prod_{r=s}^{t-1} (1 + R_r^m) \\] <p>Convention: \\(F_{s,s}^m = 1\\) (no accumulation over empty interval).</p>"},{"location":"portfolio/#mathematical-properties","title":"Mathematical properties","text":"<ol> <li> <p>Affine in \\(X\\):    $$    W_t^m(\\alpha X + \\beta Y) = \\alpha W_t^m(X) + \\beta W_t^m(Y) + \\text{const}    $$    where const = \\(W_0^m F_{0,t}^m\\) (independent of policy).</p> </li> <li> <p>Analytical gradient:    $$    \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s \\, F_{s,t}^m, \\quad s &lt; t    $$    Enables gradient-based optimization without numerical differentiation.</p> </li> <li> <p>Monotonicity:    If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m\\) is strictly increasing in \\(x_s^m\\).</p> </li> </ol>"},{"location":"portfolio/#accumulation-factors-computation","title":"Accumulation factors computation","text":"<p>Method signature: <pre><code>def compute_accumulation_factors(self, R: np.ndarray) -&gt; np.ndarray\n</code></pre></p> <p>Input: Returns matrix <code>R</code> of shape <code>(n_sims, T, M)</code> Output: Factors tensor <code>F</code> of shape <code>(n_sims, T+1, T+1, M)</code></p> <p>Algorithm: Vectorized product over time dimension <pre><code>F[:, s, t, :] = np.prod(gross_returns[:, s:t, :], axis=1)\n# where gross_returns = 1.0 + R\n</code></pre></p> <p>Complexity: - Time: \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) - Memory: \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) floats (8 bytes each)</p> <p>Memory estimates: - <code>n_sims=500, T=24, M=2</code>: ~115 MB - <code>n_sims=500, T=120, M=5</code>: ~14 GB - <code>n_sims=1000, T=240, M=10</code>: ~221 GB (infeasible)</p> <p>Warnings: For \\(T &gt; 100\\), consider: - Using <code>method=\"recursive\"</code> (no \\(F\\) precomputation) - Batching simulations (chunking <code>n_sims</code>) - On-the-fly gradient computation (store only needed \\(F_{s,t}\\) pairs) - Sparse storage for time-specific constraints</p>"},{"location":"portfolio/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"portfolio/#workflow","title":"Workflow","text":"<pre><code># 1. Define accounts (annual parameters recommended)\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Housing\", annual_return=0.07, annual_volatility=0.12)\n]\n\n# 2. Create portfolio executor\nportfolio = Portfolio(accounts)\n\n# 3. Generate stochastic inputs externally\nincome = IncomeModel(fixed=..., variable=...)\nreturns = ReturnModel(accounts, default_correlation=np.eye(2))\n\nT, n_sims = 24, 500\nA = income.contributions(T, start=date(2025,1,1), n_sims=n_sims)  # (500, 24)\nR = returns.generate(T, n_sims=n_sims, seed=42)                    # (500, 24, 2)\n\n# 4. Define allocation policy\nX = np.tile([0.6, 0.4], (T, 1))  # 60-40 split\n\n# 5. Execute wealth dynamics\nresult = portfolio.simulate(A=A, R=R, X=X, method=\"affine\")\nW = result[\"wealth\"]              # (500, 25, 2)\nW_total = result[\"total_wealth\"]  # (500, 25)\n\n# 6. Visualize\nportfolio.plot(result=result, X=X, save_path=\"portfolio_analysis.png\")\n</code></pre>"},{"location":"portfolio/#data-flow","title":"Data flow","text":"<pre><code>income.py          returns.py\n    \u2193                  \u2193\n    A                  R          (external generation)\n    \u2193                  \u2193\n    \u2514\u2500\u2500\u25ba portfolio.simulate(A, R, X) \u2500\u2500\u25ba W\n                       \u2191\n                       X          (from user or optimizer)\n</code></pre>"},{"location":"portfolio/#optimization-integration","title":"Optimization integration","text":"<p>Inner problem (fixed horizon \\(T\\)):</p> \\[ \\begin{aligned} \\max_{X \\in \\mathcal{X}_T} \\;\\; &amp; f(X) = \\mathbb{E}\\big[\\sum_m W_T^m(X)\\big] \\\\ \\text{s.t.} \\;\\; &amp; \\mathbb{P}\\big(W_t^m(X) \\ge b_t^m\\big) \\ge 1 - \\varepsilon_t^m, \\quad \\forall (t,m,b_t^m,\\varepsilon_t^m) \\in \\mathcal{G} \\end{aligned} \\] <p>Gradient computation: <pre><code>F = portfolio.compute_accumulation_factors(R)  # (n_sims, T+1, T+1, M)\n\n# Gradient of E[W_t^m] w.r.t. x_s^m\ngrad = (A[:, s, None] * F[:, s, t, :]).mean(axis=0)  # shape: (M,)\n</code></pre></p> <p>Chance constraint via SAA: <pre><code># Constraint: P(W_t^m &gt;= b) &gt;= 1-\u03b5\nW_t_m = portfolio._simulate_affine(A, R, X)[:, t, m]  # (n_sims,)\nviolation_rate = (W_t_m &lt; b).mean()\nconstraint_satisfied = (violation_rate &lt;= \u03b5)\n</code></pre></p>"},{"location":"portfolio/#visualization","title":"Visualization","text":"<p>Method signature: <pre><code>def plot(\n    self,\n    result: dict,      # from simulate()\n    X: np.ndarray,     # allocation policy\n    figsize: tuple = (16, 10),\n    title: Optional[str] = None,\n    save_path: Optional[str] = None,\n    return_fig_ax: bool = False,\n    show_trajectories: bool = True,\n    trajectory_alpha: float = 0.05,\n    colors: Optional[dict] = None,\n    hist_bins: int = 30,\n    hist_color: str = 'mediumseagreen'\n)\n</code></pre></p> <p>Panel layout: 1. Top-left: Wealth per account (time series with Monte Carlo trajectories) 2. Top-right: Total portfolio wealth + lateral histogram of final wealth distribution 3. Bottom-left: Portfolio composition (stacked area chart) 4. Bottom-right: Allocation policy heatmap (X matrix visualization)</p> <p>Key features: - Individual trajectories at low alpha (visual uncertainty quantification) - Mean trajectories in bold (expected path) - Final wealth statistics annotation (mean, median, std) - Lateral histogram for outcome distribution at \\(T\\) - Allocation heatmap with colorbar (0-1 scale)</p>"},{"location":"portfolio/#recommended-usage-patterns","title":"Recommended usage patterns","text":""},{"location":"portfolio/#a-basic-simulation-deterministic-contributions","title":"A) Basic simulation (deterministic contributions)","text":"<pre><code>A = np.full(24, 100_000.0)                      # (24,)\nR = returns.generate(T=24, n_sims=500, seed=42) # (500, 24, 2)\nX = np.tile([0.5, 0.5], (24, 1))                # equal split\n\nresult = portfolio.simulate(A, R, X)\nW = result[\"wealth\"]  # (500, 25, 2)\n</code></pre>"},{"location":"portfolio/#b-stochastic-contributions-returns","title":"B) Stochastic contributions + returns","text":"<pre><code># Both A and R are stochastic\nA = income.contributions(24, start=date(2025,1,1), n_sims=500)  # (500, 24)\nR = returns.generate(T=24, n_sims=500, seed=42)                  # (500, 24, 2)\nX = np.tile([0.7, 0.3], (24, 1))\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#c-time-varying-allocation-policy","title":"C) Time-varying allocation policy","text":"<pre><code># Glide path: decrease equity exposure over time\nT = 60\nequity_fractions = np.linspace(0.8, 0.4, T)\nX = np.column_stack([equity_fractions, 1 - equity_fractions])  # (60, 2)\n\nresult = portfolio.simulate(A, R, X)\n</code></pre>"},{"location":"portfolio/#d-optimization-ready-gradient-computation","title":"D) Optimization-ready gradient computation","text":"<pre><code># Compute accumulation factors once\nF = portfolio.compute_accumulation_factors(R)  # (n_sims, T+1, T+1, M)\n\n# Gradient of E[W_24^0] w.r.t. X[10, 0]\nt_goal, s_contrib, m_account = 24, 10, 0\nA_val = A[10] if A.ndim == 1 else A[:, 10].mean()\ngrad = A_val * F[:, s_contrib, t_goal, m_account].mean()\n</code></pre>"},{"location":"portfolio/#e-method-selection-heuristic","title":"E) Method selection heuristic","text":"<p>Use <code>method=\"recursive\"</code> when: - Pure simulation (no optimization) - Large horizons (\\(T &gt; 100\\)) - Memory-constrained environments - No need for gradients</p> <p>Use <code>method=\"affine\"</code> when: - Integrating with optimizer - Need analytical gradients - Moderate horizons (\\(T \\leq 100\\)) - Sufficient RAM for \\(O(n_{\\text{sims}} \\cdot T^2 \\cdot M)\\) storage</p>"},{"location":"portfolio/#key-design-decisions","title":"Key design decisions","text":""},{"location":"portfolio/#1-annual-parameters-as-primary-api","title":"1. Annual parameters as primary API","text":"<p>Rationale: Users think in annualized terms (e.g., \"4% per year\"), not monthly rates.</p> <p>Implementation: - <code>Account.from_annual()</code> is the recommended constructor - Internal storage uses monthly (canonical for numerical computation) - Properties provide dual views without runtime overhead</p>"},{"location":"portfolio/#2-no-embedded-return-generation","title":"2. No embedded return generation","text":"<p>Rationale: Separation of concerns enables: - Loose coupling (Portfolio never imports ReturnModel) - Flexibility (users can swap return models) - Testability (deterministic testing with controlled <code>R</code>)</p> <p>Pattern: <pre><code># \u274c Old pattern (tight coupling)\nportfolio.simulate(A, X, return_params={...})\n\n# \u2705 Current pattern (loose coupling)\nR = returns.generate(...)\nportfolio.simulate(A, R, X)\n</code></pre></p>"},{"location":"portfolio/#3-vectorized-batch-processing-via-n_sims","title":"3. Vectorized batch processing via <code>n_sims</code>","text":"<p>Rationale: Matches <code>income.py</code> API pattern for consistency.</p> <p>Performance benefit: <pre><code># Old: Python-level loop (slow)\nW_batch = [portfolio.simulate(A[i], R[i], X) for i in range(500)]\n\n# New: Single vectorized call (100x faster)\nW_batch = portfolio.simulate(A, R, X)  # A: (500, T), R: (500, T, M)\n</code></pre></p>"},{"location":"portfolio/#4-affine-method-as-default","title":"4. Affine method as default","text":"<p>Rationale: - Exposes gradients for optimization - Same asymptotic complexity as recursive for typical use cases - Memory overhead acceptable for \\(T \\leq 100\\)</p> <p>Tradeoff: Memory vs. gradient access</p>"},{"location":"portfolio/#5-accumulation-factors-as-explicit-artifact","title":"5. Accumulation factors as explicit artifact","text":"<p>Rationale: - Optimization frameworks need \\(F_{s,t}^m\\) for constraint reformulation - Precomputation amortizes cost across multiple objective evaluations - Users can inspect/debug via <code>compute_accumulation_factors()</code></p> <p>Complexity: Documented explicitly with memory estimates to guide method selection.</p>"},{"location":"portfolio/#implementation-notes","title":"Implementation notes","text":""},{"location":"portfolio/#rate-conversion-consistency","title":"Rate conversion consistency","text":"<p>All rate conversions use <code>utils.py</code> helpers: <pre><code>mu_monthly = annual_to_monthly(r_annual)  # geometric: (1+r)^(1/12)-1\nsigma_monthly = sigma_annual / np.sqrt(12)  # time scaling\n</code></pre></p> <p>Verification: <pre><code>assert np.isclose(\n    monthly_to_annual(annual_to_monthly(0.08)),\n    0.08\n)  # round-trip identity\n</code></pre></p>"},{"location":"portfolio/#wealth-initialization","title":"Wealth initialization","text":"<p>All simulations start from \\(W_0^m\\) defined in <code>Account.initial_wealth</code>: <pre><code>W[:, 0, :] = self.initial_wealth_vector  # broadcast to (n_sims, M)\n</code></pre></p> <p>Behavior: If \\(W_0^m = 0\\) for all accounts, wealth accumulates purely from contributions.</p>"},{"location":"portfolio/#numerical-stability","title":"Numerical stability","text":"<p>Accumulation factors: - Use product of gross returns: \\(\\prod (1 + R_r)\\) (numerically stable) - Avoid exp-sum-log for small returns (unnecessary complexity) - For extreme cases (\\(T &gt; 240\\)), consider log-space accumulation</p> <p>Gradient computation: - Gradients scale linearly with \\(A_s\\) and \\(F_{s,t}^m\\) - No risk of underflow for typical financial returns - Division-free (multiplication only)</p>"},{"location":"portfolio/#visualization-edge-cases","title":"Visualization edge cases","text":"<ul> <li>Single simulation (\\(n_{\\text{sims}} = 1\\)): histogram omitted (no distribution)</li> <li>Many accounts (\\(M &gt; 5\\)): allocation heatmap text labels suppressed</li> <li>Long horizons (\\(T &gt; 24\\)): heatmap remains readable via automatic aspect ratio</li> </ul>"},{"location":"portfolio/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Affine Wealth): For any allocation policy \\(X \\in \\mathcal{X}_T\\) and return realization \\(\\{R_t^m\\}\\): $$ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m $$ is affine in \\(X\\).</p> <p>Proof: Direct substitution from recursive formula. \u220e</p> <p>Corollary 1 (Linear Constraints): If goals are specified as \\(W_t^m(X) \\geq b_t^m\\) (deterministic), the feasible allocation set is a convex polytope.</p> <p>Proposition 2 (Gradient): The sensitivity of wealth to allocation at month \\(s\\) is: $$ \\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m, \\quad s &lt; t $$</p> <p>Proof: Differentiate affine formula w.r.t. \\(x_s^m\\). \u220e</p> <p>Corollary 2 (Monotonicity): If \\(F_{s,t}^m &gt; 0\\) (positive returns), then \\(W_t^m(X)\\) is strictly increasing in \\(x_s^m\\).</p> <p>Proposition 3 (Stochastic Gradient): For stochastic returns, the expected gradient is: $$ \\mathbb{E}\\left[\\frac{\\partial W_t^m}{\\partial x_s^m}\\right] = \\mathbb{E}[A_s] \\cdot \\mathbb{E}[F_{s,t}^m] $$ assuming independence of \\(A_s\\) and \\(F_{s,t}^m\\).</p> <p>Remark: For dependent \\(A\\) and \\(R\\), use sample average: \\(\\frac{1}{N}\\sum_{i=1}^N A_s^{(i)} F_{s,t}^{m,(i)}\\).</p>"},{"location":"portfolio/#extensions","title":"Extensions","text":"<p>Multi-period rebalancing: Allow \\(x_t^m\\) to vary by month (already supported).</p> <p>Transaction costs: Add friction terms \\(\\kappa \\|\\Delta x_t\\|_1\\) to objective.</p> <p>Tax-aware dynamics: Incorporate capital gains, withdrawal timing: $$ W_{t+1}^m = (W_t^m + A_t^m)(1 + R_t^m) - \\tau \\cdot \\max(0, W_t^m R_t^m) $$</p> <p>Robust optimization: Replace \\(\\mathbb{E}[W_T]\\) with worst-case \\(\\inf_{\\mathbb{P} \\in \\mathcal{P}} \\mathbb{E}_{\\mathbb{P}}[W_T]\\).</p> <p>Dynamic programming: For path-dependent constraints, use Bellman recursion: $$ V_t(W_t) = \\max_{x_t} \\mathbb{E}\\big[V_{t+1}(W_{t+1}) \\,|\\, W_t, x_t\\big] $$</p>"},{"location":"returns/","title":"<code>returns</code> \u2014 Philosophy &amp; Role in FinOpt","text":"<p>Purpose: Generate correlated stochastic returns under lognormal assumptions, providing the probabilistic foundation for Monte Carlo simulation and optimization under uncertainty. <code>returns.py</code> is the stochastic engine: it consumes account metadata (from <code>portfolio.py</code>) and produces vectorized return samples that drive wealth dynamics in <code>portfolio.simulate()</code>.</p>"},{"location":"returns/#why-a-dedicated-returns-module","title":"Why a dedicated returns module?","text":"<p>Financial planning under uncertainty requires explicit stochastic modeling: - <code>income.py</code> \u2192 cash flow uncertainty (seasonal + noise) - <code>returns.py</code> \u2192 market return uncertainty (correlated assets) - <code>portfolio.py</code> \u2192 wealth evolution executor - <code>optimization.py</code> \u2192 policy search under constraints</p> <p>This separation enables: - Loose coupling: Portfolio never generates returns (delegated to ReturnModel) - Correlation modeling: Cross-sectional dependence between accounts - Lognormal guarantee: \\(R_t &gt; -1\\) (no catastrophic losses) - Dual temporal API: Seamless monthly \u2194 annual parameter conversion</p>"},{"location":"returns/#mathematical-framework","title":"Mathematical framework","text":""},{"location":"returns/#lognormal-return-model","title":"Lognormal return model","text":"<p>Gross returns follow a correlated lognormal distribution:</p> \\[ 1 + R_t^m \\sim \\text{LogNormal}(\\mu_{\\text{log}}^m, \\Sigma) \\] <p>where the covariance matrix is constructed as:</p> \\[ \\Sigma = D \\rho D \\] <p>with: - \\(D = \\text{diag}(\\sigma_{\\text{log}}^1, \\ldots, \\sigma_{\\text{log}}^M)\\) (log-volatilities) - \\(\\rho \\in \\mathbb{R}^{M \\times M}\\) (correlation matrix, symmetric PSD with diagonal = 1)</p>"},{"location":"returns/#parameter-conversion","title":"Parameter conversion","text":"<p>Given arithmetic parameters \\((\\mu_{\\text{arith}}, \\sigma_{\\text{arith}})\\), convert to log-space:</p> \\[ \\begin{aligned} \\sigma_{\\text{log}} &amp;= \\sqrt{\\log\\left(1 + \\frac{\\sigma_{\\text{arith}}^2}{(1 + \\mu_{\\text{arith}})^2}\\right)} \\\\[8pt] \\mu_{\\text{log}} &amp;= \\log(1 + \\mu_{\\text{arith}}) - \\frac{\\sigma_{\\text{log}}^2}{2} \\end{aligned} \\] <p>Rationale: The adjustment \\(-\\sigma_{\\text{log}}^2/2\\) ensures: $$ \\mathbb{E}[1 + R_t^m] = \\exp\\left(\\mu_{\\text{log}} + \\frac{\\sigma_{\\text{log}}^2}{2}\\right) = 1 + \\mu_{\\text{arith}} $$</p>"},{"location":"returns/#generation-algorithm","title":"Generation algorithm","text":"<ol> <li>Sample log-returns: \\(Z \\sim \\mathcal{N}(\\mu_{\\text{log}}, \\Sigma)\\) with shape \\((n_{\\text{sims}}, T, M)\\)</li> <li>Transform to arithmetic: \\(R = \\exp(Z) - 1\\)</li> <li>Guarantee: \\(R_t^m &gt; -1\\) for all realizations (lognormal property)</li> </ol> <p>Complexity: \\(O(n_{\\text{sims}} \\cdot T \\cdot M^3)\\) dominated by Cholesky decomposition of \\(\\Sigma\\) (one-time cost).</p>"},{"location":"returns/#design-principles","title":"Design principles","text":"<ol> <li>Lognormal constraint</li> <li>Ensures \\(R_t &gt; -1\\) (realistic: no portfolio loses more than 100%)</li> <li> <p>Alternative to Normal (which allows \\(R_t &lt; -1\\)) or Bootstrap (limited to historical support)</p> </li> <li> <p>Correlation modeling</p> </li> <li>Default: uncorrelated accounts (\\(\\rho = I\\))</li> <li>Override per <code>generate()</code> call for sensitivity analysis</li> <li> <p>Validation: symmetric, PSD, diagonal = 1</p> </li> <li> <p>Dual temporal representation</p> </li> <li>User-facing: annual parameters (intuitive)</li> <li>Internal: monthly log-space (canonical for sampling)</li> <li> <p>Properties provide views without conversion overhead</p> </li> <li> <p>No portfolio dependency</p> </li> <li>Consumes <code>Account</code> metadata (loose coupling)</li> <li>Never imports <code>Portfolio</code> (inverted dependency)</li> <li> <p>Testable in isolation</p> </li> <li> <p>IID assumption</p> </li> <li>Returns are independent across time (no GARCH/AR)</li> <li>Extension to time-series models is straightforward</li> </ol>"},{"location":"returns/#the-core-surface-returnmodel","title":"The core surface: <code>ReturnModel</code>","text":""},{"location":"returns/#constructor","title":"Constructor","text":"<p>Signature: <pre><code>ReturnModel(\n    accounts: List[Account],\n    default_correlation: Optional[np.ndarray] = None\n)\n</code></pre></p> <p>Parameters: - <code>accounts</code>: list of <code>Account</code> objects with <code>return_strategy</code> metadata - <code>default_correlation</code>: \\(M \\times M\\) correlation matrix (default: \\(I_M\\))</p> <p>Initialization: 1. Validate correlation matrix (symmetric, PSD, diagonal = 1) 2. Extract arithmetic parameters from <code>accounts</code> 3. Precompute log-space parameters \\((\\mu_{\\text{log}}, \\sigma_{\\text{log}})\\) 4. Store for efficient sampling</p> <p>Key behaviors: - Raises <code>ValueError</code> if correlation invalid - Eigenvalue check: \\(\\lambda_{\\min}(\\rho) \\geq -10^{-10}\\) (numerical tolerance)</p>"},{"location":"returns/#properties","title":"Properties","text":"<p>Dual temporal access:</p> <pre><code>@property\ndef monthly_params(self) -&gt; List[Dict[str, float]]\n    # [{\"mu\": float, \"sigma\": float}, ...]\n\n@property\ndef annual_params(self) -&gt; List[Dict[str, float]]\n    # [{\"return\": float, \"volatility\": float}, ...]\n</code></pre> <p>Introspection: <pre><code>returns.params_table()  # DataFrame with monthly vs annual comparison\nprint(returns)          # Human-readable summary\n</code></pre></p> <p>Example output: <pre><code>ReturnModel(M=2, \u03c1=eye, accounts=['Emergency': 4.0%/year, 'Growth': 12.0%/year])\n</code></pre></p>"},{"location":"returns/#core-generation-method","title":"Core generation method","text":"<p>Signature: <pre><code>def generate(\n    self,\n    T: int,\n    n_sims: int = 1,\n    correlation: Optional[np.ndarray] = None,\n    seed: Optional[int] = None\n) -&gt; np.ndarray\n</code></pre></p> <p>Parameters: - <code>T</code>: time horizon (months) - <code>n_sims</code>: number of Monte Carlo trajectories - <code>correlation</code>: override default correlation (sensitivity analysis) - <code>seed</code>: RNG seed for reproducibility</p> <p>Returns: - <code>R</code>: shape \\((n_{\\text{sims}}, T, M)\\) with \\(R_{i,t,m} &gt; -1\\) for all \\((i,t,m)\\)</p> <p>Algorithm: <pre><code># 1. Build covariance: \u03a3 = D @ \u03c1 @ D\ncov = diag(\u03c3_log) @ correlation @ diag(\u03c3_log)\n\n# 2. Sample log-returns\nrng = np.random.default_rng(seed)\nZ = rng.multivariate_normal(\u03bc_log, cov, size=(n_sims, T))  # (n_sims, T, M)\n\n# 3. Transform to arithmetic\nR = np.exp(Z) - 1.0\n</code></pre></p> <p>Complexity: - Time: \\(O(M^3 + n_{\\text{sims}} \\cdot T \\cdot M^2)\\)   - \\(O(M^3)\\): Cholesky decomposition of \\(\\Sigma\\) (one-time)   - \\(O(n_{\\text{sims}} \\cdot T \\cdot M^2)\\): sampling via transform - Memory: \\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\)</p> <p>Key behaviors: - Deterministic when <code>seed</code> is specified - Validates correlation matrix on each call (allows runtime override) - Returns empty array if \\(T \\leq 0\\): shape \\((n_{\\text{sims}}, 0, M)\\)</p>"},{"location":"returns/#visualization-methods","title":"Visualization methods","text":""},{"location":"returns/#1-plot-distribution-analysis","title":"1) <code>plot()</code> \u2014 Distribution analysis","text":"<p>Panel layout: 1. Top-left: Return trajectories (Monte Carlo paths) 2. Top-right: Marginal histograms (monthly distribution) 3. Bottom: Summary statistics (monthly + annualized)</p> <p>Key features: - Individual trajectories at low alpha - Mean path in bold - Dual metrics: monthly + annualized (compounded for mean, time-scaled for std)</p> <p>Usage: <pre><code>returns.plot(T=24, n_sims=500, seed=42, show_trajectories=True)\n</code></pre></p>"},{"location":"returns/#2-plot_cumulative-wealth-evolution","title":"2) <code>plot_cumulative()</code> \u2014 Wealth evolution","text":"<p>Visualization: - Cumulative returns: \\(\\left(\\prod_{s=0}^{t-1}(1+R_s^m)\\right) - 1\\) - Lateral histogram of final returns - Percentile bands (default: 5th-95th)</p> <p>Modes: - M=1: Single plot with lateral histogram - M&gt;1: Separate subplot per account</p> <p>Theoretical validation: <pre><code># Annotation box shows:\n# - Simulation mean vs theoretical: E[(1+\u03bc)^T - 1]\n# - Jensen's inequality: sample mean &gt; theoretical (convexity)\n</code></pre></p> <p>Usage: <pre><code>returns.plot_cumulative(T=24, n_sims=1000, show_percentiles=True)\n</code></pre></p>"},{"location":"returns/#3-plot_horizon_analysis-time-diversification","title":"3) <code>plot_horizon_analysis()</code> \u2014 Time diversification","text":"<p>Analysis across investment horizons (default: 1, 2, 3, 5, 10, 20 years):</p> <p>Panel 1: Return vs Volatility - Expected return: \\((1+\\mu_{\\text{monthly}})^{T_{\\text{months}}} - 1\\) - Volatility: \\(\\sigma_{\\text{monthly}} \\sqrt{T_{\\text{months}}}\\) (time scaling) - Signal-to-noise ratio: \\(\\text{SNR} = \\mathbb{E}[R] / \\sigma[R]\\)</p> <p>Panel 2: Probability of Loss - \\(P(R_T &lt; 0)\\) via Normal approximation - Risk reduction annotation (e.g., 40% \u2192 5% over 20 years)</p> <p>Printed table: <pre><code>HORIZON ANALYSIS - Emergency\n================================================================================\nHorizon | Expected | Volatility | P(Loss) | P25-P75 |  SNR\n(years) |   Return |    (\u00b11\u03c3)   |         |  Range  |\n--------------------------------------------------------------------------------\n    1.0 |     4.0% |      5.0%  |   21.2% |    6.7% |  0.80\n    5.0 |    21.7% |     11.2%  |    2.6% |   15.0% |  1.94\n   20.0 |   119.1% |     22.4%  |    0.0% |   30.0% |  5.32\n================================================================================\n</code></pre></p> <p>Usage: <pre><code>returns.plot_horizon_analysis(horizons=np.array([1, 5, 10, 20]))\n</code></pre></p>"},{"location":"returns/#integration-with-finopt-pipeline","title":"Integration with FinOpt pipeline","text":""},{"location":"returns/#workflow","title":"Workflow","text":"<pre><code># 1. Define accounts (annual parameters)\naccounts = [\n    Account.from_annual(\"Emergency\", annual_return=0.04, annual_volatility=0.05),\n    Account.from_annual(\"Housing\", annual_return=0.07, annual_volatility=0.12)\n]\n\n# 2. Create return generator\nreturns = ReturnModel(accounts, default_correlation=np.eye(2))\n\n# 3. Generate samples\nR = returns.generate(T=24, n_sims=500, seed=42)  # (500, 24, 2)\n\n# 4. Feed to portfolio\nresult = portfolio.simulate(A=A, R=R, X=X)\n</code></pre>"},{"location":"returns/#data-flow","title":"Data flow","text":"<pre><code>Account metadata \u2192 ReturnModel \u2192 R \u2192 Portfolio.simulate() \u2192 W\n                        \u2191\n                   correlation\n                   (user/optimizer)\n</code></pre>"},{"location":"returns/#optimization-integration","title":"Optimization integration","text":"<p>Chance constraint evaluation: <pre><code># Generate scenario ensemble\nR_scenarios = returns.generate(T=24, n_sims=500, seed=42)\n\n# Evaluate constraint: P(W_T^m &gt;= b) &gt;= 1-\u03b5\nfor scenario in R_scenarios:\n    W_T_m = portfolio.simulate(A, scenario, X)[\"wealth\"][:, T, m]\n    violations += (W_T_m &lt; b).sum()\n\nfeasible = (violations / n_sims &lt;= \u03b5)\n</code></pre></p> <p>Sensitivity analysis: <pre><code># Test correlation impact\ncorrelations = [np.eye(2), np.array([[1, 0.5], [0.5, 1]])]\n\nfor rho in correlations:\n    R = returns.generate(T=24, n_sims=500, correlation=rho)\n    result = portfolio.simulate(A, R, X)\n    # Compare outcomes\n</code></pre></p>"},{"location":"returns/#recommended-usage-patterns","title":"Recommended usage patterns","text":""},{"location":"returns/#a-basic-generation-uncorrelated","title":"A) Basic generation (uncorrelated)","text":"<pre><code>accounts = [\n    Account.from_annual(\"Conservative\", 0.04, 0.05),\n    Account.from_annual(\"Aggressive\", 0.12, 0.20)\n]\nreturns = ReturnModel(accounts)  # default: \u03c1 = I\n\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#b-correlated-accounts","title":"B) Correlated accounts","text":"<pre><code># Positive correlation (typical for equity/bond)\nrho = np.array([\n    [1.00, 0.30],\n    [0.30, 1.00]\n])\n\nreturns = ReturnModel(accounts, default_correlation=rho)\nR = returns.generate(T=24, n_sims=500, seed=42)\n</code></pre>"},{"location":"returns/#c-correlation-override-sensitivity","title":"C) Correlation override (sensitivity)","text":"<pre><code># Default: \u03c1 = 0.3\nreturns = ReturnModel(accounts, default_correlation=rho_low)\n\n# Test high correlation\nrho_high = np.array([[1.0, 0.8], [0.8, 1.0]])\nR_high = returns.generate(T=24, n_sims=500, correlation=rho_high, seed=42)\n\n# Compare portfolio outcomes\nresult_low = portfolio.simulate(A, R_low, X)\nresult_high = portfolio.simulate(A, R_high, X)\n</code></pre>"},{"location":"returns/#d-introspection-and-validation","title":"D) Introspection and validation","text":"<pre><code># Parameter table\nprint(returns.params_table())\n#            \u03bc (monthly)  \u03bc (annual)  \u03c3 (monthly)  \u03c3 (annual)\n# Emergency       0.0033       4.00%       0.0144       5.00%\n# Growth          0.0095      12.00%       0.0577      20.00%\n\n# Generate and validate\nR = returns.generate(T=240, n_sims=1000, seed=42)\n\n# Check lognormal property\nassert np.all(R &gt; -1.0)  # guaranteed by construction\n\n# Check empirical moments\nmu_empirical = R.mean(axis=(0,1))  # average over sims and time\nmu_theoretical = returns.mean_returns  # from properties\nnp.testing.assert_allclose(mu_empirical, mu_theoretical, rtol=0.05)\n</code></pre>"},{"location":"returns/#e-horizon-analysis","title":"E) Horizon analysis","text":"<pre><code># Understand time diversification\nreturns.plot_horizon_analysis(\n    horizons=np.array([1, 2, 3, 5, 10, 15, 20]),\n    show_table=True,\n    save_path=\"horizon_analysis.png\"\n)\n\n# Typical findings:\n# - SNR increases with \u221aT (signal grows faster than noise)\n# - P(Loss) decreases exponentially with T\n# - Volatility grows with \u221aT (absolute risk increases)\n</code></pre>"},{"location":"returns/#key-design-decisions","title":"Key design decisions","text":""},{"location":"returns/#1-lognormal-vs-normal-vs-bootstrap","title":"1. Lognormal vs Normal vs Bootstrap","text":"<p>Lognormal (chosen): - \u2705 Guarantees \\(R_t &gt; -1\\) (realistic) - \u2705 Closed-form moments - \u2705 Positive skewness (matches empirical asset returns) - \u274c Assumes IID (no time-series structure)</p> <p>Normal: - \u2705 Simpler mathematics - \u274c Allows \\(R_t &lt; -1\\) (unrealistic) - \u274c Symmetric tails (doesn't match data)</p> <p>Bootstrap: - \u2705 Matches historical distribution exactly - \u274c Limited to observed range (no extrapolation) - \u274c Requires historical data (not forward-looking)</p> <p>Justification: Lognormal provides analytical tractability, realistic constraints, and forward-looking flexibility.</p>"},{"location":"returns/#2-correlation-as-parameter-not-covariance","title":"2. Correlation as parameter (not covariance)","text":"<p>Rationale: - Correlation is scale-invariant (easier to specify) - Natural interpretation: \\(\\rho_{12} = 0.5\\) means \"moderate positive dependence\" - Covariance mixes magnitude and correlation (confusing)</p> <p>Construction: \\(\\Sigma = D\\rho D\\) separates scale (volatility) from dependence (correlation).</p>"},{"location":"returns/#3-dual-temporal-api-matching-portfoliopy","title":"3. Dual temporal API matching <code>portfolio.py</code>","text":"<p>Consistency: - <code>Account.from_annual()</code> \u2192 user specifies annual parameters - <code>ReturnModel.monthly_params</code> \u2192 internal canonical form - <code>ReturnModel.annual_params</code> \u2192 user-friendly view</p> <p>Conversion: - Geometric for returns: \\((1+\\mu_m)^{12} - 1\\) - Time-scaling for volatility: \\(\\sigma_m \\sqrt{12}\\)</p>"},{"location":"returns/#4-precomputed-log-parameters","title":"4. Precomputed log-parameters","text":"<p>Performance: <pre><code># \u274c Bad: compute in hot loop\nfor sim in range(n_sims):\n    sigma_log = np.sqrt(np.log(1 + sigma_arith**2 / (1 + mu_arith)**2))\n    mu_log = np.log(1 + mu_arith) - 0.5 * sigma_log**2\n    # ... sample\n\n# \u2705 Good: precompute once in __init__\nself._mu_log = ...  # computed once\nself._sigma_log = ...\n\nfor sim in range(n_sims):\n    # ... sample using cached values\n</code></pre></p> <p>Justification: Conversion formulas involve <code>log</code>, <code>sqrt</code> (expensive). Amortize cost by precomputing.</p>"},{"location":"returns/#5-correlation-override-per-generate-call","title":"5. Correlation override per <code>generate()</code> call","text":"<p>Use case: Sensitivity analysis <pre><code># Sweep correlation from 0 to 0.9\nfor corr_val in np.linspace(0, 0.9, 10):\n    rho = np.array([[1, corr_val], [corr_val, 1]])\n    R = returns.generate(T=24, n_sims=500, correlation=rho, seed=42)\n    # ... evaluate portfolio performance\n</code></pre></p> <p>Alternative (rejected): Creating new <code>ReturnModel</code> instances is expensive (rebuilds everything).</p>"},{"location":"returns/#implementation-notes","title":"Implementation notes","text":""},{"location":"returns/#parameter-conversion-formulas","title":"Parameter conversion formulas","text":"<p>Arithmetic \u2192 Log-space: <pre><code>sigma_log = np.sqrt(np.log(1 + sigma_arith**2 / (1 + mu_arith)**2))\nmu_log = np.log(1 + mu_arith) - 0.5 * sigma_log**2\n</code></pre></p> <p>Log-space \u2192 Arithmetic (verification): <pre><code># Expected gross return\nE_gross = np.exp(mu_log + 0.5 * sigma_log**2)\nmu_arith_recovered = E_gross - 1\n\n# Volatility (more complex)\nvar_gross = (np.exp(sigma_log**2) - 1) * np.exp(2*mu_log + sigma_log**2)\nsigma_arith_recovered = np.sqrt(var_gross)\n</code></pre></p> <p>Round-trip test: <pre><code>assert np.isclose(mu_arith_recovered, mu_arith)\nassert np.isclose(sigma_arith_recovered, sigma_arith)\n</code></pre></p>"},{"location":"returns/#correlation-matrix-validation","title":"Correlation matrix validation","text":"<p>Three checks: 1. Symmetry: \\(\\rho = \\rho^T\\) 2. Diagonal: \\(\\rho_{ii} = 1\\) for all \\(i\\) 3. Positive semi-definite: \\(\\lambda_{\\min}(\\rho) \\geq 0\\)</p> <p>Implementation: <pre><code># PSD check via eigenvalues (numerically stable)\neigvals = np.linalg.eigvalsh(rho)  # sorted ascending\nif np.any(eigvals &lt; -1e-10):  # numerical tolerance\n    raise ValueError(f\"Not PSD: \u03bb_min = {eigvals.min():.6f}\")\n</code></pre></p> <p>Alternative (rejected): Cholesky decomposition fails silently for near-PSD matrices.</p>"},{"location":"returns/#sampling-via-multivariate-normal","title":"Sampling via multivariate normal","text":"<p>NumPy implementation: <pre><code>rng = np.random.default_rng(seed)\nZ = rng.multivariate_normal(mean=\u03bc_log, cov=\u03a3, size=(n_sims, T))\n</code></pre></p> <p>Internal algorithm: 1. Cholesky: \\(\\Sigma = LL^T\\) where \\(L\\) is lower triangular (\\(O(M^3)\\)) 2. Sample: \\(Z_i \\sim \\mathcal{N}(0, I_M)\\) (\\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\)) 3. Transform: \\(X_i = \\mu + LZ_i\\) (\\(O(n_{\\text{sims}} \\cdot T \\cdot M^2)\\))</p> <p>Bottleneck: Cholesky is \\(O(M^3)\\) but computed once per <code>generate()</code> call.</p>"},{"location":"returns/#numerical-stability","title":"Numerical stability","text":"<p>Lognormal sampling: - Samples in log-space (stable) - Exponentiation: \\(R = \\exp(Z) - 1\\) (no underflow for \\(Z \\ll 0\\)) - No division (gradients flow cleanly)</p> <p>Edge case: \\(\\sigma_{\\text{log}} = 0\\) (deterministic) <pre><code># Covariance becomes singular but multivariate_normal handles it\ncov = np.zeros((M, M))  # degenerate\nZ = rng.multivariate_normal(\u03bc_log, cov, size=(n_sims, T))\n# Result: Z[:, :, m] = \u03bc_log[m] for all realizations (constant)\n</code></pre></p>"},{"location":"returns/#mathematical-results","title":"Mathematical results","text":"<p>Proposition 1 (Lognormal Moments): If \\(1 + R \\sim \\text{LogNormal}(\\mu_{\\log}, \\sigma_{\\log}^2)\\), then: $$ \\begin{aligned} \\mathbb{E}[R] &amp;= \\exp\\left(\\mu_{\\log} + \\frac{\\sigma_{\\log}^2}{2}\\right) - 1 \\[6pt] \\text{Var}[R] &amp;= \\left(\\exp(\\sigma_{\\log}^2) - 1\\right) \\exp(2\\mu_{\\log} + \\sigma_{\\log}^2) \\end{aligned} $$</p> <p>Proof: Standard lognormal distribution formulas. \u220e</p> <p>Proposition 2 (Return Bound): For lognormal returns, \\(R_t^m &gt; -1\\) almost surely.</p> <p>Proof: \\(1 + R_t^m = \\exp(Z_t^m)\\) where \\(Z_t^m \\in \\mathbb{R}\\). Since \\(\\exp(z) &gt; 0\\) for all \\(z \\in \\mathbb{R}\\), we have \\(1 + R_t^m &gt; 0\\), thus \\(R_t^m &gt; -1\\). \u220e</p> <p>Proposition 3 (Correlation Preservation): If \\((Z_1, Z_2)\\) are bivariate normal with correlation \\(\\rho\\), then \\(\\text{Corr}(\\exp(Z_1), \\exp(Z_2))\\) is a monotone increasing function of \\(\\rho\\).</p> <p>Consequence: Higher correlation in log-space \u2192 higher correlation in gross returns.</p> <p>Proof: Follows from monotonicity of \\(\\exp\\) and Gaussian copula properties. \u220e</p> <p>Proposition 4 (Time Diversification): For IID returns with \\(\\mu &gt; 0\\), the probability of loss decreases exponentially: $$ P\\left(\\prod_{t=1}^T (1+R_t) &lt; 1\\right) \\approx \\Phi\\left(-\\frac{\\mu \\sqrt{T}}{\\sigma}\\right) \\xrightarrow{T \\to \\infty} 0 $$</p> <p>where \\(\\Phi\\) is the standard normal CDF.</p> <p>Proof: Central Limit Theorem applied to log-returns. \u220e</p>"},{"location":"returns/#extensions-temporal-dependence-in-returns","title":"Extensions: Temporal Dependence in Returns","text":""},{"location":"returns/#motivation","title":"Motivation","text":"<p>The current IID assumption (\\(R_t^m \\perp R_s^m\\) for \\(t \\neq s\\)) is appropriate for monthly horizons and typical investment periods (\\(T = 24-60\\) months), where empirical autocorrelation is weak (\\(|\\rho_1| &lt; 0.1\\)). However, temporal structure becomes relevant for:</p> <ol> <li>Long horizons: \\(T &gt; 120\\) months where autocorrelation accumulates</li> <li>Momentum strategies: Assets with persistent trends (\\(\\phi &gt; 0.2\\))</li> <li>Volatility clustering: Crisis periods with persistent high volatility</li> <li>Mean reversion: Fixed-income or commodity markets with negative autocorrelation</li> </ol>"},{"location":"returns/#mathematical-framework_1","title":"Mathematical Framework","text":""},{"location":"returns/#ar1-process","title":"AR(1) Process","text":"\\[ R_t^m = \\phi^m R_{t-1}^m + \\epsilon_t^m, \\quad \\epsilon_t^m \\sim \\text{LogNormal}(\\mu_\\epsilon, \\sigma_\\epsilon) \\] <p>Key insight: Preserves affine wealth representation because returns remain exogenous:</p> \\[ W_t^m(X) = W_0^m F_{0,t}^m + \\sum_{s=0}^{t-1} A_s x_s^m F_{s,t}^m \\] <p>where \\(F_{s,t}^m = \\prod_{r=s}^{t-1}(1+R_r^m)\\) now depends on past returns but not on policy \\(X\\).</p> <p>Properties: - Gradient: \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) (unchanged) - Convexity: optimization problem remains convex - Variance scaling: \\(\\text{Var}[\\sum_{t=1}^T R_t] \\approx T\\sigma^2 \\cdot \\frac{1+\\phi}{1-\\phi}\\)</p> <p>Implementation sketch: <pre><code>def _generate_ar1(self, T, n_sims, phi, seed):\n    epsilon = self._generate_iid(T, n_sims, seed)  # IID innovations\n    R = np.zeros((n_sims, T, self.M))\n    R[:, 0, :] = epsilon[:, 0, :]\n\n    for t in range(1, T):\n        R[:, t, :] = phi * R[:, t-1, :] + epsilon[:, t, :]\n    return R\n</code></pre></p> <p>Complexity: \\(O(n_{\\text{sims}} \\cdot T \\cdot M)\\) vs \\(O(n_{\\text{sims}} \\cdot M^3)\\) for IID (sequential vs parallel generation).</p>"},{"location":"returns/#garch11-process","title":"GARCH(1,1) Process","text":"\\[ \\begin{aligned} R_t^m &amp;= \\sigma_t^m Z_t^m, \\quad Z_t^m \\sim \\text{LogNormal}(\\mu, 1) \\\\ (\\sigma_t^m)^2 &amp;= \\omega^m + \\alpha^m (R_{t-1}^m)^2 + \\beta^m (\\sigma_{t-1}^m)^2 \\end{aligned} \\] <p>Purpose: Captures volatility clustering without affecting expected returns.</p> <p>Constraints: \\(\\omega &gt; 0\\), \\(\\alpha, \\beta \\geq 0\\), \\(\\alpha + \\beta &lt; 1\\) (stationarity).</p> <p>Affine property: Preserved (returns exogenous to policy).</p> <p>Parameter estimation: Requires \\(n &gt; 200\\) monthly observations; MLE is non-convex.</p>"},{"location":"returns/#implementation-strategy","title":"Implementation Strategy","text":"<p>Extensible API: <pre><code>class ReturnModel:\n    def __init__(\n        self, \n        accounts: List[Account],\n        default_correlation: Optional[np.ndarray] = None,\n        temporal_model: Literal[\"iid\", \"ar1\", \"garch\"] = \"iid\",\n        temporal_params: Optional[Dict] = None  # {\"phi\": [...], \"omega\": [...], ...}\n    ):\n        self.temporal_model = temporal_model\n        self.temporal_params = temporal_params or {}\n        # ... existing init\n\n    def generate(self, T, n_sims, correlation=None, seed=None):\n        if self.temporal_model == \"iid\":\n            return self._generate_iid(T, n_sims, correlation, seed)\n        elif self.temporal_model == \"ar1\":\n            phi = self.temporal_params.get(\"phi\", np.zeros(self.M))\n            return self._generate_ar1(T, n_sims, phi, correlation, seed)\n        elif self.temporal_model == \"garch\":\n            return self._generate_garch(T, n_sims, correlation, seed, **self.temporal_params)\n</code></pre></p> <p>Backward compatibility: Default <code>temporal_model=\"iid\"</code> preserves existing behavior.</p>"},{"location":"returns/#when-to-implement","title":"When to Implement","text":"<p>Signals that temporal structure matters:</p> <ol> <li>Backtesting shows systematic bias: IID predictions consistently over/underestimate risk</li> <li>Long-horizon planning: \\(T &gt; 120\\) months where autocorrelation compounds</li> <li>Asset-specific evidence: Ljung-Box test rejects IID at 5% significance</li> <li>Volatility analysis: ARCH test detects conditional heteroskedasticity</li> </ol> <p>Estimation requirements: - AR(1): minimum \\(n = 60\\) monthly returns per account - GARCH(1,1): minimum \\(n = 120\\) monthly or \\(n = 500\\) daily returns</p>"},{"location":"returns/#trade-offs","title":"Trade-offs","text":"Aspect IID AR(1) GARCH(1,1) Affine structure \u2713 \u2713 \u2713 Computational cost 1x 5-10x 10-20x Parameters per account 2 3 4 Closed-form moments \u2713 \u2717 \u2717 Empirical necessity (monthly) \u2713 \u223c \u223c <p>Recommendation: Implement AR(1) first if empirical autocorrelation \\(|\\phi| &gt; 0.15\\). GARCH only if volatility clustering dominates (e.g., crisis modeling).</p>"},{"location":"returns/#references-for-implementation","title":"References for Implementation","text":"<ul> <li>AR estimation: Yule-Walker equations via <code>statsmodels.tsa.ar_model.AutoReg</code></li> <li>GARCH estimation: <code>arch</code> package (Engle 2001 implementation)</li> <li>Model selection: AIC/BIC comparison, Ljung-Box test for residuals</li> <li>Validation: Out-of-sample log-likelihood, forecast MSE</li> </ul> <p>Prompt for resuming work: \"Implement temporal dependence in <code>ReturnModel</code> using AR(1) process. Preserve affine wealth representation and convex optimization structure. Validate that \\(\\frac{\\partial W_t^m}{\\partial x_s^m} = A_s F_{s,t}^m\\) holds. Benchmark computational overhead vs IID baseline for \\(T=24, n_{\\text{sims}}=500\\).\"</p>"}]}