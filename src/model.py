"""
Financial modeling module for FinOpt.

Purpose
-------
Unified orchestrator for income → returns → portfolio simulation.
Integrates all FinOpt components (income, returns, portfolio) into a single
coherent interface for Monte Carlo simulation and scenario analysis.

Key components
--------------
- SimulationResult:
    Dataclass container for complete simulation output with metadata.
    Stores wealth trajectories, contributions, returns, income breakdown,
    and all parameters needed for reproducibility. Includes analytical
    methods for metrics computation and statistical summaries.

- FinancialModel:
    Main facade class that coordinates:
    1. Income generation (fixed + variable streams)
    2. Return generation (correlated lognormal)
    3. Portfolio dynamics (wealth accumulation)
    
    Provides unified plot() method with automatic simulation and caching,
    plus simulate() method with intelligent result reuse.

Design principles
-----------------
- Single entry point: FinancialModel orchestrates all components
- Reproducibility: explicit seed management with automatic propagation
- Intelligent caching: simulations cached by parameter hash (RAM efficient)
- Auto-simulation: plot() simulates internally when needed
- Loose coupling: components remain independently usable
- Type safety: SimulationResult as explicit dataclass (not dict)

Example
-------
>>> from datetime import date
>>> from finopt.src.income import FixedIncome, VariableIncome, IncomeModel
>>> from finopt.src.portfolio import Account
>>> from finopt.src.model import FinancialModel
>>> 
>>> # 1. Setup components
>>> income = IncomeModel(
...     fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
...     variable=VariableIncome(base=200_000, sigma=0.10, seed=42)
... )
>>> accounts = [
...     Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
...     Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
... ]
>>> 
>>> # 2. Create unified model
>>> model = FinancialModel(income, accounts)
>>> 
>>> # 3. Direct plotting (auto-simulates + caches)
>>> X = np.tile([0.6, 0.4], (24, 1))
>>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42)
>>> 
>>> # 4. Or explicit simulation (for data access)
>>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
>>> print(result.summary())
>>> model.plot("wealth", result=result)  # reuse result
"""

from __future__ import annotations

import hashlib
import pickle
import sys
from dataclasses import dataclass, field
from datetime import date
from typing import List, Optional

import numpy as np
import pandas as pd

from .income import IncomeModel
from .portfolio import Account, Portfolio
from .returns import ReturnModel
from .utils import compute_cagr, drawdown

__all__ = [
    "SimulationResult",
    "FinancialModel",
]


# ---------------------------------------------------------------------------
# Simulation Result Container
# ---------------------------------------------------------------------------

@dataclass(frozen=False)
class SimulationResult:
    """
    Container for complete Monte Carlo simulation results with metadata.
    
    Stores all outputs from a FinancialModel.simulate() run, including
    wealth trajectories, contributions, returns, income breakdown, and
    all parameters needed for reproducibility. Provides analytical methods
    for computing financial metrics and statistical summaries.
    
    Attributes
    ----------
    wealth : np.ndarray, shape (n_sims, T+1, M)
        Wealth trajectories for each simulation, time period, and account.
        Includes initial wealth at t=0.
    total_wealth : np.ndarray, shape (n_sims, T+1)
        Total portfolio wealth across all accounts: sum_m W_t^m.
    contributions : np.ndarray
        Monthly contributions to portfolio.
        - Shape (n_sims, T) if income is stochastic
        - Shape (T,) if income is deterministic
    returns : np.ndarray, shape (n_sims, T, M)
        Monthly arithmetic returns for each simulation, period, and account.
        Generated by ReturnModel (correlated lognormal).
    income : dict
        Income breakdown with keys:
        - "fixed": np.ndarray, fixed income stream
        - "variable": np.ndarray, variable income stream  
        - "total": np.ndarray, total income
        All arrays have shape (n_sims, T) or (T,) depending on stochasticity.
    allocation : np.ndarray, shape (T, M)
        Allocation policy X used in simulation.
        X[t, m] = fraction of A_t allocated to account m.
    T : int
        Time horizon (number of months).
    n_sims : int
        Number of Monte Carlo simulations.
    M : int
        Number of accounts/portfolios.
    start : date
        Effective start date used in simulation (calendar alignment).
        If original start=None, this is the inferred date.
    seed : Optional[int]
        Random seed used for reproducibility.
        None indicates non-deterministic simulation.
    account_names : List[str]
        Names of accounts for indexing and display.
    
    Methods
    -------
    metrics(account=None) -> pd.DataFrame
        Compute financial metrics (CAGR, Sharpe, Sortino, VaR, etc.).
    summary(confidence=0.95) -> pd.DataFrame
        Statistical summary of final wealth with confidence intervals.
    convergence_analysis() -> pd.DataFrame
        Analyze Monte Carlo convergence (error vs n_sims).
    
    Notes
    -----
    - Mutable by design (frozen=False) to allow lazy computation
    - Internal cache (_metrics) computed on first metrics() call
    - All arrays are numpy ndarrays for computational efficiency
    - Seed propagation: income uses seed, returns uses seed+1
    
    Examples
    --------
    >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> 
    >>> # Access wealth data
    >>> final_wealth = result.wealth[:, -1, :]  # (500, 2)
    >>> mean_final_wealth = result.total_wealth[:, -1].mean()
    >>> 
    >>> # Compute metrics
    >>> metrics = result.metrics()  # all accounts
    >>> metrics_emergency = result.metrics(account="Emergency")
    >>> 
    >>> # Statistical summary
    >>> summary = result.summary(confidence=0.95)
    >>> print(summary)
    >>> 
    >>> # Verify reproducibility
    >>> result2 = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> np.allclose(result.wealth, result2.wealth)  # True
    """
    wealth: np.ndarray
    total_wealth: np.ndarray
    contributions: np.ndarray
    returns: np.ndarray
    income: dict
    allocation: np.ndarray
    
    # Metadata
    T: int
    n_sims: int
    M: int
    start: date
    seed: Optional[int]
    account_names: List[str]
    
    # Internal cache for lazy computation
    _metrics: Optional[dict[str, pd.DataFrame]] = field(default=None, init=False, repr=False)
    
    def metrics(self, account: Optional[str] = None) -> pd.DataFrame:
        """
        Compute financial metrics by account or aggregate.
        
        Computes standard risk-adjusted performance metrics:
        - CAGR: Compound Annual Growth Rate
        - Volatility: Standard deviation of monthly returns
        - Sharpe Ratio: Mean return / volatility
        - Sortino Ratio: Mean return / downside deviation
        - Max Drawdown: Maximum peak-to-trough decline
        - VaR 95%: Value at Risk (5th percentile of final wealth)
        - CVaR 95%: Conditional VaR (mean of worst 5% outcomes)
        
        Results are cached on first call for efficiency.
        
        Parameters
        ----------
        account : str, optional
            Account name to compute metrics for.
            If None, returns concatenated metrics for all accounts.
        
        Returns
        -------
        pd.DataFrame
            Metrics with shape (n_sims, n_metrics) if account specified,
            or MultiIndex DataFrame with level 0 = account if None.
        
        Examples
        --------
        >>> # All accounts
        >>> metrics_all = result.metrics()
        >>> print(metrics_all.groupby(level=0).mean())
        >>> 
        >>> # Specific account
        >>> metrics_emerg = result.metrics(account="Emergency")
        >>> print(f"Mean Sharpe: {metrics_emerg['sharpe'].mean():.3f}")
        >>> 
        >>> # Distribution of CAGR
        >>> import matplotlib.pyplot as plt
        >>> result.metrics(account="Housing")['cagr'].hist(bins=30)
        """
        if self._metrics is None:
            self._compute_metrics()
        
        if account is not None:
            if account not in self._metrics:
                valid = ", ".join(self._metrics.keys())
                raise ValueError(f"Account '{account}' not found. Valid: {valid}")
            return self._metrics[account]
        
        # Return concatenated DataFrame with account as level 0 index
        return pd.concat(self._metrics, names=['account'])
    
    def _compute_metrics(self):
        """Lazy computation of financial metrics."""
        self._metrics = {}
        
        for m, acc_name in enumerate(self.account_names):
            W = self.wealth[:, :, m]  # (n_sims, T+1)
            
            # Monthly returns (handle W_t = 0 gracefully)
            with np.errstate(divide='ignore', invalid='ignore'):
                R = np.diff(W, axis=1) / W[:, :-1]
            R = np.where(np.isfinite(R), R, 0.0)
            
            # CAGR per simulation
            cagr_values = np.array([
                compute_cagr(pd.Series(W[i]), periods_per_year=12) 
                for i in range(self.n_sims)
            ])
            
            # Volatility
            volatility = R.std(axis=1, ddof=1)
            
            # Sharpe ratio (avoid division by zero)
            with np.errstate(divide='ignore', invalid='ignore'):
                sharpe = R.mean(axis=1) / volatility
            sharpe = np.where(np.isfinite(sharpe), sharpe, 0.0)
            
            # Sortino ratio (downside deviation)
            downside_returns = R.copy()
            downside_returns[downside_returns > 0] = 0
            downside_dev = downside_returns.std(axis=1, ddof=1)
            with np.errstate(divide='ignore', invalid='ignore'):
                sortino = R.mean(axis=1) / downside_dev
            sortino = np.where(np.isfinite(sortino), sortino, 0.0)
            
            # Max drawdown per simulation
            max_dd = np.array([
                drawdown(pd.Series(W[i])).min() 
                for i in range(self.n_sims)
            ])
            
            # VaR and CVaR (5%)
            W_final = W[:, -1]
            var_95 = np.percentile(W_final, 5)
            cvar_95 = W_final[W_final <= var_95].mean()
            
            # Store as DataFrame
            self._metrics[acc_name] = pd.DataFrame({
                'cagr': cagr_values,
                'volatility': volatility,
                'sharpe': sharpe,
                'sortino': sortino,
                'max_drawdown': max_dd,
                'var_95': var_95,
                'cvar_95': cvar_95
            })
    
    def summary(self, confidence: float = 0.95) -> pd.DataFrame:
        """
        Statistical summary of final wealth with confidence intervals.
        
        Computes summary statistics across Monte Carlo simulations:
        - Mean, median, standard deviation of final wealth
        - Confidence intervals at specified level
        - Per-account and total portfolio
        
        Parameters
        ----------
        confidence : float, default 0.95
            Confidence level for intervals (between 0 and 1).
        
        Returns
        -------
        pd.DataFrame
            Summary statistics indexed by account name.
            Columns: mean, median, std, CI_lower_{conf}, CI_upper_{conf}
        
        Examples
        --------
        >>> summary = result.summary(confidence=0.95)
        >>> print(summary)
                     mean      median        std  CI_lower_95  CI_upper_95
        Emergency  2500000.0  2480000.0  120000.0    2280000.0    2720000.0
        Housing   12800000.0 12750000.0  580000.0   11700000.0   13900000.0
        Total     15300000.0 15200000.0  650000.0   14100000.0   16500000.0
        """
        alpha = (1 - confidence) / 2
        
        rows = []
        
        # Per-account statistics
        for m, acc_name in enumerate(self.account_names):
            W_final = self.wealth[:, -1, m]
            rows.append({
                'account': acc_name,
                'mean': W_final.mean(),
                'median': np.median(W_final),
                'std': W_final.std(),
                f'CI_lower_{int(confidence*100)}': np.percentile(W_final, alpha*100),
                f'CI_upper_{int(confidence*100)}': np.percentile(W_final, (1-alpha)*100)
            })
        
        # Total portfolio
        W_total_final = self.total_wealth[:, -1]
        rows.append({
            'account': 'Total',
            'mean': W_total_final.mean(),
            'median': np.median(W_total_final),
            'std': W_total_final.std(),
            f'CI_lower_{int(confidence*100)}': np.percentile(W_total_final, alpha*100),
            f'CI_upper_{int(confidence*100)}': np.percentile(W_total_final, (1-alpha)*100)
        })
        
        return pd.DataFrame(rows).set_index('account')
    
    def convergence_analysis(self) -> pd.DataFrame:
        """
        Analyze Monte Carlo convergence: standard error vs n_sims.
        
        Computes mean and standard error of final total wealth for
        increasing subsample sizes. Useful for diagnosing if n_sims
        is sufficient for stable estimates.
        
        Returns
        -------
        pd.DataFrame
            Convergence statistics with columns:
            - n_sims: subsample size (log-spaced)
            - mean: mean final wealth
            - std_error: standard error of mean
        
        Notes
        -----
        Standard error should decay as 1/sqrt(n_sims). If std_error
        is still large at n_sims, consider increasing simulation count.
        
        Examples
        --------
        >>> conv = result.convergence_analysis()
        >>> print(conv)
           n_sims         mean    std_error
        0      10  15250000.0    205833.33
        1      31  15280000.0    116666.67
        2     100  15295000.0     65000.00
        3     316  15300000.0     36547.01
        4    1000  15302000.0     20562.31
        >>> 
        >>> # Plot convergence
        >>> import matplotlib.pyplot as plt
        >>> plt.loglog(conv['n_sims'], conv['std_error'])
        >>> plt.xlabel('n_sims')
        >>> plt.ylabel('Standard Error')
        """
        # Log-spaced subsample sizes
        block_sizes = np.logspace(1, np.log10(self.n_sims), 10).astype(int)
        block_sizes = np.unique(block_sizes)
        
        rows = []
        for n in block_sizes:
            W_subsample = self.total_wealth[:n, -1]
            rows.append({
                'n_sims': n,
                'mean': W_subsample.mean(),
                'std_error': W_subsample.std() / np.sqrt(n)
            })
        
        return pd.DataFrame(rows)


# ---------------------------------------------------------------------------
# Financial Model (Unified Orchestrator)
# ---------------------------------------------------------------------------

class FinancialModel:
    """
    Unified financial modeling orchestrator for Monte Carlo simulation.
    
    Integrates income generation, return modeling, and portfolio dynamics
    into a single coherent interface. Coordinates the flow:
    
        income → contributions (A) → returns (R) → wealth (W)
    
    Manages seed propagation for reproducible stochastic simulations,
    provides intelligent caching to avoid redundant computation, and
    offers unified plot() method with automatic simulation.
    
    Parameters
    ----------
    income : IncomeModel
        Combined fixed + variable income model from income.py.
        Generates monthly income projections and contribution schedules.
    accounts : List[Account]
        Portfolio account specifications with return/volatility parameters.
        Used to construct ReturnModel and Portfolio instances.
    default_correlation : np.ndarray, shape (M, M), optional
        Default cross-sectional correlation matrix for returns.
        If None, assumes uncorrelated accounts (identity matrix).
    enable_cache : bool, default True
        If True, caches simulation results by parameter hash.
        Set to False to disable caching (saves memory for large grids).
    
    Attributes
    ----------
    income : IncomeModel
        Income generation component.
    accounts : List[Account]
        Account metadata.
    returns : ReturnModel
        Stochastic return generator (correlated lognormal).
    portfolio : Portfolio
        Wealth dynamics executor.
    M : int
        Number of accounts.
    
    Methods
    -------
    simulate(T, X, n_sims, start, seed, use_cache) -> SimulationResult
        Run complete Monte Carlo simulation with caching.
    plot(mode, ...) -> None or (fig, ax)
        Unified plotting interface with auto-simulation.
    cache_info() -> dict
        Get cache statistics (size, memory usage).
    clear_cache()
        Clear simulation cache to free memory.
    
    Notes
    -----
    - Components (income, returns, portfolio) remain independently usable
    - Seed propagation: income uses seed, returns uses seed+1 (independence)
    - Default simulation method is "affine" (exposes gradients for optimization)
    - Cache key: SHA256 hash of (T, X, n_sims, start, seed)
    - Memory usage: ~(n_sims * T * M * 8 bytes) per cached simulation
    
    Examples
    --------
    >>> # 1. Setup
    >>> income = IncomeModel(
    ...     fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
    ...     variable=VariableIncome(base=200_000, sigma=0.10)
    ... )
    >>> accounts = [
    ...     Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
    ...     Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
    ... ]
    >>> model = FinancialModel(income, accounts)
    >>> 
    >>> # 2. Direct plotting (auto-simulates + caches)
    >>> X = np.tile([0.6, 0.4], (24, 1))
    >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42)
    >>> 
    >>> # 3. Explicit simulation (for data access)
    >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> print(result.summary())
    >>> 
    >>> # 4. Cache management
    >>> print(model.cache_info())  # {'size': 1, 'memory_mb': 9.6}
    >>> model.clear_cache()
    """
    
    def __init__(
        self,
        income: IncomeModel,
        accounts: List[Account],
        default_correlation: Optional[np.ndarray] = None,
        enable_cache: bool = True
    ):
        # Validation
        if not accounts:
            raise ValueError("accounts list cannot be empty")
        
        # Store components
        self.income = income
        self.accounts = accounts
        self.M = len(accounts)
        
        # Build return generator and portfolio executor
        self.returns = ReturnModel(accounts, default_correlation)
        self.portfolio = Portfolio(accounts)
        
        # Cache management
        self._cache_enabled = enable_cache
        self._simulation_cache = {}  # {hash: SimulationResult}
    
    def simulate(
        self,
        T: int,
        X: np.ndarray,
        n_sims: int = 1,
        start: Optional[date] = None,
        seed: Optional[int] = None,
        use_cache: bool = True
    ) -> SimulationResult:
        """
        Run Monte Carlo simulation with automatic caching.
        
        Executes the full pipeline:
        1. Generate income projections and contributions (uses seed)
        2. Generate correlated returns (uses seed+1 for independence)
        3. Simulate wealth dynamics under allocation policy X
        4. Package results with metadata for reproducibility
        
        Results are cached by (T, X, n_sims, start, seed) hash.
        Subsequent calls with identical parameters return cached result.
        
        Parameters
        ----------
        T : int
            Time horizon in months. Must be > 0.
        X : np.ndarray, shape (T, M)
            Allocation policy matrix.
            X[t, m] = fraction of monthly contribution A_t allocated to account m.
            Constraints: X[t, :].sum() = 1, X[t, m] >= 0 for all t, m.
        n_sims : int, default 1
            Number of Monte Carlo simulations.
            For deterministic analysis, use n_sims=1.
            For uncertainty quantification, use n_sims >= 500.
        start : Optional[date], default None
            Calendar start date for simulation.
            - If date: aligns income seasonality and calendar index
            - If None: uses date.today() as effective start
            Stored in result for reproducibility.
        seed : Optional[int], default None
            Random seed for reproducibility.
            - Income component uses seed
            - Returns component uses seed+1 (ensures independence)
            - If None, simulation is non-deterministic
        use_cache : bool, default True
            If True, returns cached result if available.
            If False, forces re-simulation.
        
        Returns
        -------
        SimulationResult
            Immutable dataclass containing:
            - wealth: (n_sims, T+1, M) trajectories
            - total_wealth: (n_sims, T+1) portfolio totals
            - contributions: (n_sims, T) or (T,) monthly contributions
            - returns: (n_sims, T, M) monthly returns
            - income: dict with fixed/variable/total breakdown
            - allocation: (T, M) policy used
            - Metadata: T, n_sims, M, start, seed, account_names
        
        Raises
        ------
        ValueError
            If X.shape != (T, M).
            If portfolio.simulate() detects invalid allocation (sum != 1, etc.).
        
        Notes
        -----
        - Seed propagation ensures statistical independence between income and returns
        - Uses portfolio.simulate(method="affine") internally for optimization readiness
        - Deterministic income (sigma=0) results in contributions.shape = (T,)
        - Stochastic income (sigma>0) results in contributions.shape = (n_sims, T)
        - Cache key computed via SHA256 hash (deterministic, collision-resistant)
        
        Examples
        --------
        >>> # Basic simulation
        >>> X = np.tile([0.7, 0.3], (24, 1))
        >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
        >>> 
        >>> # Second call: cached (instant)
        >>> result2 = model.simulate(T=24, X=X, n_sims=500, seed=42)
        >>> assert result is result2  # same object
        >>> 
        >>> # Force re-simulation
        >>> result3 = model.simulate(T=24, X=X, n_sims=500, seed=42, use_cache=False)
        >>> 
        >>> # Access results
        >>> print(result.summary())
        >>> final_wealth = result.total_wealth[:, -1]
        >>> print(f"Mean: ${final_wealth.mean():,.0f}")
        """
        # Validate allocation policy shape
        if X.shape != (T, self.M):
            raise ValueError(
                f"Allocation policy X has shape {X.shape}, expected ({T}, {self.M}). "
                f"X must be a (T, M) matrix where X[t, m] is the fraction allocated "
                f"to account m at month t."
            )
        
        # Check cache
        if self._cache_enabled and use_cache:
            cache_key = self._hash_simulation_params(T, X, n_sims, start, seed)
            
            if cache_key in self._simulation_cache:
                return self._simulation_cache[cache_key]
        
        # Infer effective start date if None
        start_effective = start if start is not None else date.today()
        
        # Generate stochastic inputs with seed propagation
        
        # Income uses provided seed
        A = self.income.contributions(
            months=T,
            start=start_effective,
            seed=seed,
            output="array",
            n_sims=n_sims
        )  # (n_sims, T) or (T,)
        
        # Full income breakdown
        income_full = self.income.project(
            months=T,
            start=start_effective,
            seed=seed,
            output="array",
            n_sims=n_sims
        )  # dict with {"fixed": ..., "variable": ..., "total": ...}
        
        # Returns use seed+1 for independence
        R = self.returns.generate(
            T=T,
            n_sims=n_sims,
            seed=None if seed is None else seed + 1
        )  # (n_sims, T, M)
        
        # Simulate wealth dynamics
        portfolio_result = self.portfolio.simulate(
            A=A,
            R=R,
            X=X,
            method="affine"
        )
        
        # Package into result container
        result = SimulationResult(
            wealth=portfolio_result["wealth"],
            total_wealth=portfolio_result["total_wealth"],
            contributions=A,
            returns=R,
            income=income_full,
            allocation=X,
            T=T,
            n_sims=n_sims,
            M=self.M,
            start=start_effective,
            seed=seed,
            account_names=[acc.name for acc in self.accounts]
        )
        
        # Store in cache
        if self._cache_enabled and use_cache:
            self._simulation_cache[cache_key] = result
        
        return result
    
    def _hash_simulation_params(
        self, 
        T: int, 
        X: np.ndarray, 
        n_sims: int, 
        start: Optional[date], 
        seed: Optional[int]
    ) -> str:
        """
        Compute deterministic hash of simulation parameters.
        
        Uses SHA256 on pickled tuple of (T, X_bytes, n_sims, start, seed).
        X is converted to bytes via tobytes() for efficiency.
        
        Returns
        -------
        str
            64-character hex digest (collision-resistant).
        """
        # Convert X to bytes (more efficient than pickling full array)
        X_bytes = X.tobytes()
        
        # Tuple of parameters
        params = (T, X_bytes, n_sims, start, seed)
        
        # Serialize and hash
        params_serialized = pickle.dumps(params, protocol=pickle.HIGHEST_PROTOCOL)
        return hashlib.sha256(params_serialized).hexdigest()
    
    def clear_cache(self):
        """
        Clear simulation cache to free memory.
        
        Removes all cached SimulationResult objects. Useful when running
        large parameter sweeps or when memory is constrained.
        
        Examples
        --------
        >>> model.simulate(T=24, X=X, n_sims=500)  # cached
        >>> model.clear_cache()
        >>> model.simulate(T=24, X=X, n_sims=500)  # re-computes
        """
        self._simulation_cache.clear()
    
    def cache_info(self) -> dict:
        """
        Get cache statistics.
        
        Returns
        -------
        dict
            Keys:
            - 'size': number of cached simulations
            - 'memory_mb': approximate RAM usage (MB)
        
        Notes
        -----
        Memory estimate includes wealth, returns, and contributions arrays.
        Actual memory usage may be higher due to Python overhead.
        
        Examples
        --------
        >>> info = model.cache_info()
        >>> print(f"Cached simulations: {info['size']}")
        >>> print(f"Memory usage: {info['memory_mb']:.1f} MB")
        """
        size = len(self._simulation_cache)
        
        # Estimate memory (sum of major arrays)
        memory_bytes = sum(
            sys.getsizeof(result.wealth) +
            sys.getsizeof(result.returns) +
            sys.getsizeof(result.contributions)
            for result in self._simulation_cache.values()
        )
        
        return {
            'size': size,
            'memory_mb': memory_bytes / (1024 ** 2)
        }
    
    # -----------------------------------------------------------------------
    # Unified plotting interface
    # -----------------------------------------------------------------------
    
    def plot(
        self,
        mode: str,
        *,
        # Simulation parameters (for modes that need to simulate)
        T: Optional[int] = None,
        X: Optional[np.ndarray] = None,
        n_sims: int = 500,
        start: Optional[date] = None,
        seed: Optional[int] = None,
        
        # Bypass: pre-computed result (optional)
        result: Optional[SimulationResult] = None,
        
        # Common plotting parameters
        figsize: Optional[tuple] = None,
        title: Optional[str] = None,
        save_path: Optional[str] = None,
        return_fig_ax: bool = False,
        
        # Cache control
        use_cache: bool = True,
        
        # Mode-specific kwargs
        **kwargs
    ):
        """
        Unified plotting interface with automatic simulation.
        
        Dispatches to specialized plotting methods based on mode. For modes
        requiring simulation ("wealth", "comparison"), automatically executes
        simulate() internally unless a pre-computed result is provided.
        Simulations are cached by default to avoid redundant computation.
        
        Parameters
        ----------
        mode : str
            Visualization type. Available modes:
            
            **Pre-simulation (no simulation needed):**
            - "income": Income streams (fixed, variable, total)
            - "contributions": Monthly contribution schedule
            - "returns": Return distributions and trajectories
            - "returns_cumulative": Cumulative return evolution
            - "returns_horizon": Risk-return by investment horizon
            
            **Simulation-based (auto-simulates if result not provided):**
            - "wealth": Portfolio dynamics (4 panels)
            - "comparison": Compare multiple strategies
        
        T : int, optional
            Time horizon for simulation-based modes.
            Required if mode in {"wealth"} and result not provided.
        X : np.ndarray, shape (T, M), optional
            Allocation policy for simulation-based modes.
            Required if mode in {"wealth"} and result not provided.
        n_sims : int, default 500
            Number of Monte Carlo simulations.
        start : date, optional
            Calendar start date.
        seed : int, optional
            Random seed for reproducibility.
        result : SimulationResult, optional
            Pre-computed simulation result. If provided, bypasses simulate()
            and uses this result directly. Useful when result already exists
            or for multiple plots from same simulation.
        figsize : tuple, optional
            Figure size (width, height). Defaults vary by mode.
        title : str, optional
            Main figure title. Auto-generated if None.
        save_path : str, optional
            Path to save figure. If None, displays interactively.
        return_fig_ax : bool, default False
            If True, returns (fig, ax) or (fig, axes) for customization.
        use_cache : bool, default True
            If True, checks cache before simulating. If False, forces
            re-simulation even if cached result exists.
        **kwargs
            Mode-specific parameters forwarded to underlying methods.
            
            **Income/Contributions modes:**
            - months : int, projection horizon
            - show_trajectories : bool
            - n_simulations : int
            - dual_axis : "auto"|True|False (income only)
            
            **Returns modes:**
            - n_sims : int
            - correlation : np.ndarray
            - show_trajectories : bool
            - show_percentiles : bool (cumulative only)
            - horizons : np.ndarray (horizon only)
            
            **Wealth mode:**
            - show_trajectories : bool
            - trajectory_alpha : float
            - colors : dict
            
            **Comparison mode:**
            - results : dict[str, SimulationResult], required
            - metric : str
        
        Returns
        -------
        None or (fig, ax)
            If return_fig_ax=True, returns figure and axes.
            Otherwise displays plot and returns None.
        
        Raises
        ------
        ValueError
            If mode is invalid or required parameters are missing.
        
        Examples
        --------
        >>> model = FinancialModel(income, accounts)
        >>> X = np.tile([0.6, 0.4], (24, 1))
        >>> 
        >>> # Pre-simulation: income streams
        >>> model.plot("income", months=24, start=date(2025,1,1))
        >>> 
        >>> # Pre-simulation: return analysis
        >>> model.plot("returns", T=24, n_sims=300, seed=42)
        >>> model.plot("returns_cumulative", T=120, n_sims=500)
        >>> 
        >>> # Simulation-based: auto-simulates + caches
        >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42)
        >>> # Second call: instant (cached)
        >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42, title="Alt View")
        >>> 
        >>> # Bypass simulation if result exists
        >>> result = model.simulate(T=24, X=X, n_sims=500)
        >>> model.plot("wealth", result=result, show_trajectories=False)
        >>> 
        >>> # Strategy comparison
        >>> result1 = model.simulate(T=24, X=X_conservative, n_sims=500)
        >>> result2 = model.simulate(T=24, X=X_aggressive, n_sims=500)
        >>> model.plot("comparison", results={"60-40": result1, "80-20": result2})
        """
        
        # Determine if mode needs simulation
        simulation_modes = {"wealth", "comparison"}
        needs_simulation = mode in simulation_modes
        
        if needs_simulation:
            # Option 1: result already provided (bypass)
            if result is not None:
                sim_result = result
            
            # Option 2: simulate with given parameters
            else:
                if mode == "wealth":
                    # Validate required parameters
                    if T is None or X is None:
                        raise ValueError(
                            f"mode='wealth' requires T and X parameters "
                            f"(or provide result=...)"
                        )
                    sim_result = self.simulate(
                        T=T, X=X, n_sims=n_sims, 
                        start=start, seed=seed, use_cache=use_cache
                    )
                
                elif mode == "comparison":
                    # This mode requires dict of results (special case)
                    if "results" not in kwargs:
                        raise ValueError(
                            f"mode='comparison' requires results parameter "
                            f"(dict of SimulationResult objects)"
                        )
                    sim_result = None  # no single result
        
        # Build dispatch kwargs - start with user-provided kwargs
        dispatch_kwargs = {
            "figsize": figsize,
            "title": title,
            "save_path": save_path,
            "return_fig_ax": return_fig_ax,
            **kwargs  # User kwargs first (will not be overridden)
        }
        
        # Add mode-specific parameters (only if not already in kwargs)
        if mode in ["returns", "returns_cumulative"]:
            # These modes expect T, n_sims, seed, correlation (optional)
            if T is not None:
                dispatch_kwargs.setdefault("T", T)
            dispatch_kwargs.setdefault("n_sims", n_sims)
            if seed is not None:
                dispatch_kwargs.setdefault("seed", seed)
            # correlation comes from kwargs if provided
        
        elif mode == "returns_horizon":
            # This mode uses horizons array from kwargs, no T/n_sims/seed
            pass
        
        elif mode in ["income", "contributions"]:
            # These modes expect months (from kwargs) and start
            if start is not None:
                dispatch_kwargs.setdefault("start", start)
        
        elif mode == "wealth":
            # Inject simulation result and allocation policy
            dispatch_kwargs["result"] = sim_result
            if X is not None:
                dispatch_kwargs["X"] = X
        
        elif mode == "comparison":
            # results already in kwargs, no additional parameters needed
            pass
        
        # Remove None values (let underlying methods use their defaults)
        dispatch_kwargs = {k: v for k, v in dispatch_kwargs.items() 
                        if v is not None}
        
        # Dispatch
        return self._dispatch_plot(mode, **dispatch_kwargs)
    
    def _dispatch_plot(self, mode: str, **kwargs):
        """Internal dispatcher to plotting methods."""
        _dispatch = {
            # Pre-simulation
            "income": self._plot_income,
            "contributions": self._plot_contributions,
            "returns": self._plot_returns,
            "returns_cumulative": self._plot_returns_cumulative,
            "returns_horizon": self._plot_returns_horizon,
            
            # Simulation-based
            "wealth": self._plot_wealth,
            "comparison": self._plot_comparison,
        }
        
        if mode not in _dispatch:
            valid = ", ".join(f"'{m}'" for m in _dispatch.keys())
            raise ValueError(
                f"Invalid mode '{mode}'. Valid modes: {valid}"
            )
        
        return _dispatch[mode](**kwargs)
    
    # -----------------------------------------------------------------------
    # Plot delegates (forward to component methods)
    # -----------------------------------------------------------------------
    
    def _plot_income(self, **kwargs):
        """Delegate to income.plot_income()."""
        return self.income.plot_income(**kwargs)
    
    def _plot_contributions(self, **kwargs):
        """Delegate to income.plot_contributions()."""
        return self.income.plot_contributions(**kwargs)
    
    def _plot_returns(self, **kwargs):
        """Delegate to returns.plot()."""
        return self.returns.plot(**kwargs)
    
    def _plot_returns_cumulative(self, **kwargs):
        """Delegate to returns.plot_cumulative()."""
        return self.returns.plot_cumulative(**kwargs)
    
    def _plot_returns_horizon(self, **kwargs):
        """Delegate to returns.plot_horizon_analysis()."""
        return self.returns.plot_horizon_analysis(**kwargs)
    
    def _plot_wealth(
        self, 
        result: SimulationResult, 
        X: Optional[np.ndarray] = None, 
        **kwargs
    ):
        """Delegate to portfolio.plot()."""
        if not isinstance(result, SimulationResult):
            raise TypeError("mode='wealth' requires result parameter")
        
        X_plot = X if X is not None else result.allocation
        portfolio_result = {
            "wealth": result.wealth,
            "total_wealth": result.total_wealth
        }
        
        return self.portfolio.plot(portfolio_result, X_plot, **kwargs)
    
    def _plot_comparison(
        self,
        results: dict[str, SimulationResult],
        metric: str = "total_wealth",
        **kwargs
    ):
        """
        Compare multiple strategies side-by-side.
        
        Creates 2-panel comparison:
        - Left: Mean trajectory over time
        - Right: Final distribution boxplots
        
        Parameters
        ----------
        results : dict[str, SimulationResult]
            Dictionary mapping strategy labels to simulation results.
        metric : str, default "total_wealth"
            Metric to compare. Options: "total_wealth", "wealth".
        **kwargs
            Plotting parameters (figsize, title, save_path, return_fig_ax).
        """
        if not isinstance(results, dict):
            raise TypeError("mode='comparison' requires results dict")
        
        import matplotlib.pyplot as plt
        
        figsize = kwargs.get("figsize", (14, 6))
        title = kwargs.get("title", f"Strategy Comparison: {metric}")
        save_path = kwargs.get("save_path", None)
        return_fig_ax = kwargs.get("return_fig_ax", False)
        
        fig, axes = plt.subplots(1, 2, figsize=figsize)
        
        # Panel 1: Mean trajectories
        for label, result in results.items():
            if metric == "total_wealth":
                data = result.total_wealth.mean(axis=0)
            elif metric == "wealth":
                # Sum across all accounts
                data = result.wealth.sum(axis=2).mean(axis=0)
            else:
                raise ValueError(
                    f"Unsupported metric '{metric}'. "
                    f"Valid: 'total_wealth', 'wealth'"
                )
            
            axes[0].plot(data, label=label, linewidth=2.5)
        
        axes[0].set_xlabel("Month", fontsize=11)
        axes[0].set_ylabel(metric.replace('_', ' ').title(), fontsize=11)
        axes[0].set_title("Mean Trajectories", fontsize=12, fontweight='bold')
        axes[0].legend(loc='best', fontsize=10)
        axes[0].grid(True, alpha=0.3)
        
        # Panel 2: Final distribution boxplots
        final_data = [r.total_wealth[:, -1] for r in results.values()]
        bp = axes[1].boxplot(final_data, labels=results.keys(), patch_artist=True)
        
        # Color boxes
        colors = plt.cm.Set3(np.linspace(0, 1, len(results)))
        for patch, color in zip(bp['boxes'], colors):
            patch.set_facecolor(color)
        
        axes[1].set_ylabel("Final Wealth", fontsize=11)
        axes[1].set_title("Distribution at T", fontsize=12, fontweight='bold')
        axes[1].grid(True, alpha=0.3, axis='y')
        axes[1].tick_params(axis='x', rotation=45)
        
        fig.suptitle(title, fontsize=14, fontweight='bold')
        plt.tight_layout()
        
        if save_path:
            fig.savefig(save_path, bbox_inches='tight', dpi=150)
        
        if return_fig_ax:
            return fig, axes
    
    def __repr__(self) -> str:
        """Human-readable string representation."""
        account_names = [acc.name for acc in self.accounts]
        cache_status = "enabled" if self._cache_enabled else "disabled"
        return (f"FinancialModel(M={self.M}, accounts={account_names}, "
                f"cache={cache_status})")


# ---------------------------------------------------------------------------
# Sanity check / Example usage (manual execution only)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    from datetime import date
    import numpy as np
    from .income import FixedIncome, VariableIncome, IncomeModel
    from .portfolio import Account
    
    print("=== FinancialModel Sanity Check ===\n")
    
    # 1. Setup
    print("1. Creating components...")
    income = IncomeModel(
        fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
        variable=VariableIncome(base=200_000, sigma=0.10, seed=42)
    )
    
    accounts = [
        Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
        Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
    ]
    
    model = FinancialModel(income, accounts)
    print(f"   {model}\n")
    
    # 2. Test caching
    print("2. Testing simulation cache...")
    T = 6
    X = np.tile([0.6, 0.4], (T, 1))
    
    import time
    
    start = time.time()
    result1 = model.simulate(T=T, X=X, n_sims=100, seed=123)
    time1 = time.time() - start
    
    start = time.time()
    result2 = model.simulate(T=T, X=X, n_sims=100, seed=123)  # cached
    time2 = time.time() - start
    
    print(f"   First call: {time1*1000:.1f} ms")
    print(f"   Second call (cached): {time2*1000:.1f} ms")
    print(f"   Speedup: {time1/time2:.0f}x")
    print(f"   Same object: {result1 is result2}")
    print(f"   Cache info: {model.cache_info()}\n")
    
    # 3. Test SimulationResult methods
    print("3. Testing SimulationResult methods...")
    summary = result1.summary(confidence=0.95)
    print("   Summary statistics:")
    print(summary)
    print()
    
    metrics = result1.metrics(account="Emergency")
    print(f"   Emergency account - Mean Sharpe: {metrics['sharpe'].mean():.3f}")
    print()
    
    # 4. Test plot() with auto-simulation
    print("4. Testing plot() with auto-simulation...")
    try:
        # This should use cached result
        model.plot("wealth", T=T, X=X, n_sims=100, seed=123, 
                  title="Test Plot", save_path=None, return_fig_ax=False)
        print("   ✓ plot('wealth') executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('wealth') failed: {e}\n")
    
    # 5. Test plot() with pre-computed result
    print("5. Testing plot() with pre-computed result...")
    try:
        model.plot("wealth", result=result1, title="From Result")
        print("   ✓ plot('wealth', result=...) executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('wealth', result=...) failed: {e}\n")
    
    # 6. Test comparison mode
    print("6. Testing comparison mode...")
    X2 = np.tile([0.4, 0.6], (T, 1))  # different allocation
    result3 = model.simulate(T=T, X=X2, n_sims=100, seed=456)
    
    try:
        model.plot("comparison", results={
            "60-40": result1,
            "40-60": result3
        })
        print("   ✓ plot('comparison') executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('comparison') failed: {e}\n")
    
    # 7. Final cache info
    print("7. Final cache info:")
    info = model.cache_info()
    print(f"   Cached simulations: {info['size']}")
    print(f"   Memory usage: {info['memory_mb']:.2f} MB\n")
    
    print("✓ All sanity checks completed!")