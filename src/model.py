"""
Financial modeling module for FinOpt.

Purpose
-------
Unified orchestrator for income → returns → portfolio simulation.
Integrates all FinOpt components (income, returns, portfolio) into a single
coherent interface for Monte Carlo simulation and scenario analysis.

Key components
--------------
- SimulationResult:
    Dataclass container for complete simulation output with metadata.
    Stores wealth trajectories, contributions, returns, income breakdown,
    and all parameters needed for reproducibility. Includes analytical
    methods for metrics computation and statistical summaries.

- FinancialModel:
    Main facade class that coordinates:
    1. Income generation (fixed + variable streams)
    2. Return generation (correlated lognormal)
    3. Portfolio dynamics (wealth accumulation)
    
    Provides unified plot() method with automatic simulation and caching,
    plus simulate() method with intelligent result reuse.

Design principles
-----------------
- Single entry point: FinancialModel orchestrates all components
- Reproducibility: explicit seed management with automatic propagation
- Intelligent caching: simulations cached by parameter hash (RAM efficient)
- Auto-simulation: plot() simulates internally when needed
- Loose coupling: components remain independently usable
- Type safety: SimulationResult as explicit dataclass (not dict)
- Portfolio-aware: Uses Account objects throughout for type safety

Example
-------
>>> from datetime import date
>>> from finopt.src.income import FixedIncome, VariableIncome, IncomeModel
>>> from finopt.src.portfolio import Account
>>> from finopt.src.model import FinancialModel
>>> 
>>> # 1. Setup components
>>> income = IncomeModel(
...     fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
...     variable=VariableIncome(base=200_000, sigma=0.10, seed=42)
... )
>>> accounts = [
...     Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
...     Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
... ]
>>> 
>>> # 2. Create unified model
>>> model = FinancialModel(income, accounts)
>>> 
>>> # 3. Direct plotting (auto-simulates + caches)
>>> X = np.tile([0.6, 0.4], (24, 1))
>>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42)
>>> 
>>> # 4. Or explicit simulation (for data access)
>>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
>>> print(result.summary())
>>> model.plot("wealth", result=result)  # reuse result
"""

from __future__ import annotations

import hashlib
import pickle
import sys
from dataclasses import dataclass, field
from datetime import date
from typing import List, Optional, Union, Dict, TYPE_CHECKING

import numpy as np
import pandas as pd

# Lazy imports for optimization (avoid circular dependencies)
if TYPE_CHECKING:
    from .optimization import AllocationOptimizer, OptimizationResult

# Direct imports (always available)
from .income import IncomeModel
from .portfolio import Account, Portfolio
from .returns import ReturnModel
from .utils import compute_cagr, drawdown
from .goals import IntermediateGoal, TerminalGoal

__all__ = [
    "SimulationResult",
    "FinancialModel",
]


# ---------------------------------------------------------------------------
# Simulation Result Container
# ---------------------------------------------------------------------------

@dataclass(frozen=False)
class SimulationResult:
    """
    Container for complete Monte Carlo simulation results with metadata.
    
    Stores all outputs from a FinancialModel.simulate() run, including
    wealth trajectories, contributions, returns, income breakdown, and
    all parameters needed for reproducibility. Provides analytical methods
    for computing financial metrics and statistical summaries.
    
    Attributes
    ----------
    wealth : np.ndarray, shape (n_sims, T+1, M)
        Wealth trajectories for each simulation, time period, and account.
        Includes initial wealth at t=0.
    total_wealth : np.ndarray, shape (n_sims, T+1)
        Total portfolio wealth across all accounts: sum_m W_t^m.
    contributions : np.ndarray
        Monthly contributions to portfolio.
        - Shape (n_sims, T) if income is stochastic
        - Shape (T,) if income is deterministic
    returns : np.ndarray, shape (n_sims, T, M)
        Monthly arithmetic returns for each simulation, period, and account.
        Generated by ReturnModel (correlated lognormal).
    income : dict
        Income breakdown with keys:
        - "fixed": np.ndarray, fixed income stream
        - "variable": np.ndarray, variable income stream  
        - "total": np.ndarray, total income
        All arrays have shape (n_sims, T) or (T,) depending on stochasticity.
    allocation : np.ndarray, shape (T, M)
        Allocation policy X used in simulation.
        X[t, m] = fraction of A_t allocated to account m.
    T : int
        Time horizon (number of months).
    n_sims : int
        Number of Monte Carlo simulations.
    M : int
        Number of accounts/portfolios.
    start : date
        Effective start date used in simulation (calendar alignment).
        If original start=None, this is the inferred date.
    seed : Optional[int]
        Random seed used for reproducibility.
        None indicates non-deterministic simulation.
    account_names : List[str]
        Names of accounts for indexing and display.
    
    Methods
    -------
    metrics(account=None) -> pd.DataFrame
        Compute per-simulation financial metrics (CAGR, Sharpe, Sortino, etc.).
    aggregate_metrics(account=None) -> pd.Series | pd.DataFrame
        Compute distribution-level metrics (VaR, CVaR, final wealth statistics).
    summary(confidence=0.95) -> pd.DataFrame
        Statistical summary of final wealth with confidence intervals.
    convergence_analysis() -> pd.DataFrame
        Analyze Monte Carlo convergence (error vs n_sims).
    
    Notes
    -----
    - Mutable by design (frozen=False) to allow lazy computation
    - Internal cache (_metrics) computed on first metrics() call
    - All arrays are numpy ndarrays for computational efficiency
    - Seed propagation: income uses seed, returns uses seed+1
    
    Examples
    --------
    >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> 
    >>> # Access wealth data
    >>> final_wealth = result.wealth[:, -1, :]  # (500, 2)
    >>> mean_final_wealth = result.total_wealth[:, -1].mean()
    >>> 
    >>> # Compute metrics
    >>> metrics = result.metrics()  # all accounts
    >>> metrics_emergency = result.metrics(account="Emergency")
    >>> 
    >>> # Statistical summary
    >>> summary = result.summary(confidence=0.95)
    >>> print(summary)
    >>> 
    >>> # Verify reproducibility
    >>> result2 = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> np.allclose(result.wealth, result2.wealth)  # True
    """
    wealth: np.ndarray
    total_wealth: np.ndarray
    contributions: np.ndarray
    returns: np.ndarray
    income: dict
    allocation: np.ndarray
    
    # Metadata
    T: int
    n_sims: int
    M: int
    start: date
    seed: Optional[int]
    account_names: List[str]
    
    # Internal cache for lazy computation
    _metrics: Optional[dict[str, pd.DataFrame]] = field(default=None, init=False, repr=False)
    _aggregate_metrics: Optional[dict[str, dict]] = field(default=None, init=False, repr=False)

    def metrics(self, account: Optional[str] = None) -> pd.DataFrame:
        """
        Compute per-simulation financial metrics by account.
        
        Computes standard risk-adjusted performance metrics for each simulation:
        - CAGR: Compound Annual Growth Rate
        - Volatility: Standard deviation of monthly returns
        - Sharpe Ratio: Mean return / volatility
        - Sortino Ratio: Mean return / downside deviation
        - Max Drawdown: Maximum peak-to-trough decline
        
        For distribution-level metrics (VaR, CVaR, final wealth statistics),
        use `aggregate_metrics()` instead.
        
        Results are cached on first call for efficiency.
        
        Parameters
        ----------
        account : str, optional
            Account name to compute metrics for.
            If None, returns concatenated metrics for all accounts.
        
        Returns
        -------
        pd.DataFrame
            Metrics with shape (n_sims, n_metrics) if account specified,
            or MultiIndex DataFrame with level 0 = account if None.
        
        See Also
        --------
        aggregate_metrics : Distribution-level metrics (VaR, CVaR, etc.)
        
        Examples
        --------
        >>> # All accounts
        >>> metrics_all = result.metrics()
        >>> print(metrics_all.groupby(level=0).mean())
        
        >>> # Specific account
        >>> metrics_emerg = result.metrics(account="Emergency")
        >>> print(f"Mean Sharpe: {metrics_emerg['sharpe'].mean():.3f}")
        
        >>> # Distribution of CAGR
        >>> import matplotlib.pyplot as plt
        >>> result.metrics(account="Housing")['cagr'].hist(bins=30)
        """
        if self._metrics is None:
            self._compute_metrics()
        
        if account is not None:
            if account not in self._metrics:
                valid = ", ".join(self._metrics.keys())
                raise ValueError(f"Account '{account}' not found. Valid: {valid}")
            return self._metrics[account]
        
        # Return concatenated DataFrame with account as level 0 index
        return pd.concat(self._metrics, names=['account'])
    
    def _compute_metrics(self):
        """Lazy computation of financial metrics."""
        self._metrics = {}
        self._aggregate_metrics = {}
        
        for m, acc_name in enumerate(self.account_names):
            W = self.wealth[:, :, m]  # (n_sims, T+1)
            
            # Monthly returns (handle W_t = 0 gracefully)
            with np.errstate(divide='ignore', invalid='ignore'):
                R = np.diff(W, axis=1) / W[:, :-1]
            R = np.where(np.isfinite(R), R, 0.0)
            
            # CAGR per simulation
            cagr_values = np.array([
                compute_cagr(pd.Series(W[i]), periods_per_year=12) 
                for i in range(self.n_sims)
            ])
            
            # Volatility
            volatility = R.std(axis=1, ddof=1)
            
            # Sharpe ratio (avoid division by zero)
            with np.errstate(divide='ignore', invalid='ignore'):
                sharpe = R.mean(axis=1) / volatility
            sharpe = np.where(np.isfinite(sharpe), sharpe, 0.0)
            
            # Sortino ratio (downside deviation)
            downside_returns = R.copy()
            downside_returns[downside_returns > 0] = 0
            downside_dev = downside_returns.std(axis=1, ddof=1)
            with np.errstate(divide='ignore', invalid='ignore'):
                sortino = R.mean(axis=1) / downside_dev
            sortino = np.where(np.isfinite(sortino), sortino, 0.0)
            
            # Max drawdown per simulation
            max_dd = np.array([
                drawdown(pd.Series(W[i])).min() 
                for i in range(self.n_sims)
            ])
            
            # Store per-simulation metrics
            self._metrics[acc_name] = pd.DataFrame({
                'cagr': cagr_values,
                'volatility': volatility,
                'sharpe': sharpe,
                'sortino': sortino,
                'max_drawdown': max_dd,
            })
            
            # Aggregate metrics (distribution-level)
            W_final = W[:, -1]
            var_95_val = np.percentile(W_final, 5)
            
            self._aggregate_metrics[acc_name] = {
                'var_95': var_95_val,
                'cvar_95': W_final[W_final <= var_95_val].mean(),
                'mean_final': W_final.mean(),
                'median_final': np.median(W_final),
                'std_final': W_final.std(),
                'min_final': W_final.min(),
                'max_final': W_final.max(),
            }

    def aggregate_metrics(self, account: Optional[str] = None) -> pd.Series | pd.DataFrame:
        """
        Compute distribution-level metrics (VaR, CVaR, final wealth statistics).
        
        These metrics characterize the entire distribution of outcomes across
        simulations, not individual simulation paths. Includes risk measures
        and summary statistics of terminal wealth.
        
        Parameters
        ----------
        account : str, optional
            Account name to compute metrics for.
            If None, returns metrics for all accounts.
        
        Returns
        -------
        pd.Series or pd.DataFrame
            If account specified: Series with keys ['var_95', 'cvar_95', 
            'mean_final', 'median_final', 'std_final', 'min_final', 'max_final'].
            If None: DataFrame with accounts as rows, metrics as columns.
        
        Notes
        -----
        - VaR₉₅: Value at Risk at 5% confidence (5th percentile of final wealth)
        - CVaR₉₅: Conditional VaR (mean of worst 5% outcomes)
        - Results cached on first call; recomputed when wealth changes
        
        Examples
        --------
        >>> # All accounts
        >>> agg = result.aggregate_metrics()
        >>> print(agg)
                    var_95    cvar_95  mean_final  median_final  std_final
        Emergency  2280000.0  2150000.0   2500000.0     2480000.0  120000.0
        Housing   11700000.0 11200000.0  12800000.0    12750000.0  580000.0
        
        >>> # Specific account
        >>> emerg_agg = result.aggregate_metrics(account="Emergency")
        >>> print(f"VaR₉₅: ${emerg_agg['var_95']:,.0f}")
        VaR₉₅: $2,280,000
        """
        if self._metrics is None:
            self._compute_metrics()
        
        if account is not None:
            if account not in self._aggregate_metrics:
                valid = ", ".join(self._aggregate_metrics.keys())
                raise ValueError(f"Account '{account}' not found. Valid: {valid}")
            return pd.Series(self._aggregate_metrics[account], name=account)
        
        return pd.DataFrame(self._aggregate_metrics).T
    
    def summary(self, confidence: float = 0.95) -> pd.DataFrame:
        """
        Statistical summary of final wealth with confidence intervals.
        
        Computes summary statistics across Monte Carlo simulations:
        - Mean, median, standard deviation of final wealth
        - Confidence intervals at specified level
        - Per-account and total portfolio
        
        Parameters
        ----------
        confidence : float, default 0.95
            Confidence level for intervals (between 0 and 1).
        
        Returns
        -------
        pd.DataFrame
            Summary statistics indexed by account name.
            Columns: mean, median, std, CI_lower_{conf}, CI_upper_{conf}
        
        Examples
        --------
        >>> summary = result.summary(confidence=0.95)
        >>> print(summary)
                     mean      median        std  CI_lower_95  CI_upper_95
        Emergency  2500000.0  2480000.0  120000.0    2280000.0    2720000.0
        Housing   12800000.0 12750000.0  580000.0   11700000.0   13900000.0
        Total     15300000.0 15200000.0  650000.0   14100000.0   16500000.0
        """
        alpha = (1 - confidence) / 2
        
        rows = []
        
        # Per-account statistics
        for m, acc_name in enumerate(self.account_names):
            W_final = self.wealth[:, -1, m]
            rows.append({
                'account': acc_name,
                'mean': W_final.mean(),
                'median': np.median(W_final),
                'std': W_final.std(),
                f'CI_lower_{int(confidence*100)}': np.percentile(W_final, alpha*100),
                f'CI_upper_{int(confidence*100)}': np.percentile(W_final, (1-alpha)*100)
            })
        
        # Total portfolio
        W_total_final = self.total_wealth[:, -1]
        rows.append({
            'account': 'Total',
            'mean': W_total_final.mean(),
            'median': np.median(W_total_final),
            'std': W_total_final.std(),
            f'CI_lower_{int(confidence*100)}': np.percentile(W_total_final, alpha*100),
            f'CI_upper_{int(confidence*100)}': np.percentile(W_total_final, (1-alpha)*100)
        })
        
        return pd.DataFrame(rows).set_index('account')
    
    def convergence_analysis(self) -> pd.DataFrame:
        """
        Analyze Monte Carlo convergence: standard error vs n_sims.
        
        Computes mean and standard error of final total wealth for
        increasing subsample sizes. Useful for diagnosing if n_sims
        is sufficient for stable estimates.
        
        Returns
        -------
        pd.DataFrame
            Convergence statistics with columns:
            - n_sims: subsample size (log-spaced)
            - mean: mean final wealth
            - std_error: standard error of mean
        
        Notes
        -----
        Standard error should decay as 1/sqrt(n_sims). If std_error
        is still large at n_sims, consider increasing simulation count.
        
        Examples
        --------
        >>> conv = result.convergence_analysis()
        >>> print(conv)
           n_sims         mean    std_error
        0      10  15250000.0    205833.33
        1      31  15280000.0    116666.67
        2     100  15295000.0     65000.00
        3     316  15300000.0     36547.01
        4    1000  15302000.0     20562.31
        >>> 
        >>> # Plot convergence
        >>> import matplotlib.pyplot as plt
        >>> plt.loglog(conv['n_sims'], conv['std_error'])
        >>> plt.xlabel('n_sims')
        >>> plt.ylabel('Standard Error')
        """
        # Log-spaced subsample sizes
        block_sizes = np.logspace(1, np.log10(self.n_sims), 10).astype(int)
        block_sizes = np.unique(block_sizes)
        
        rows = []
        for n in block_sizes:
            W_subsample = self.total_wealth[:n, -1]
            rows.append({
                'n_sims': n,
                'mean': W_subsample.mean(),
                'std_error': W_subsample.std() / np.sqrt(n)
            })
        
        return pd.DataFrame(rows)


# ---------------------------------------------------------------------------
# Financial Model (Unified Orchestrator)
# ---------------------------------------------------------------------------

class FinancialModel:
    """
    Unified financial modeling orchestrator for Monte Carlo simulation.
    
    Integrates income generation, return modeling, and portfolio dynamics
    into a single coherent interface. Coordinates the flow:
    
        income → contributions (A) → returns (R) → wealth (W)
    
    Manages seed propagation for reproducible stochastic simulations,
    provides intelligent caching to avoid redundant computation, and
    offers unified plot() method with automatic simulation.
    
    Parameters
    ----------
    income : IncomeModel
        Combined fixed + variable income model from income.py.
        Generates monthly income projections and contribution schedules.
    accounts : List[Account]
        Portfolio account specifications with return/volatility parameters.
        Used to construct ReturnModel and Portfolio instances.
        Becomes canonical source of truth for account metadata throughout system.
    default_correlation : np.ndarray, shape (M, M), optional
        Default cross-sectional correlation matrix for returns.
        If None, assumes uncorrelated accounts (identity matrix).
    enable_cache : bool, default True
        If True, caches simulation results by parameter hash.
        Set to False to disable caching (saves memory for large grids).
    
    Attributes
    ----------
    income : IncomeModel
        Income generation component.
    accounts : List[Account]
        Account metadata (same reference as portfolio.accounts).
    returns : ReturnModel
        Stochastic return generator (correlated lognormal).
    portfolio : Portfolio
        Wealth dynamics executor.
    M : int
        Number of accounts.
    
    Methods
    -------
    simulate(T, X, n_sims, start, seed, use_cache) -> SimulationResult
        Run complete Monte Carlo simulation with caching.
    optimize(goals, optimizer, T_max, ...) -> OptimizationResult
        Find minimum-horizon policy satisfying financial goals.
    verify_goals(result, goals, start) -> dict
        Validate goal satisfaction in simulation/optimization result.
    simulate_from_optimization(opt_result, ...) -> SimulationResult
        Convenience wrapper to simulate with optimal policy.
    plot(mode, ...) -> None or (fig, ax)
        Unified plotting interface with auto-simulation.
    cache_info() -> dict
        Get cache statistics (size, memory usage).
    clear_cache()
        Clear simulation cache to free memory.
    
    Notes
    -----
    - Components (income, returns, portfolio) remain independently usable
    - Seed propagation: income uses seed, returns uses seed+1 (independence)
    - Default simulation method is "affine" (exposes gradients for optimization)
    - Cache key: SHA256 hash of (T, X, n_sims, start, seed)
    - Memory usage: ~(n_sims * T * M * 8 bytes) per cached simulation
    - self.accounts and self.portfolio.accounts share same reference (no duplication)
    
    Examples
    --------
    >>> # 1. Setup
    >>> income = IncomeModel(
    ...     fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
    ...     variable=VariableIncome(base=200_000, sigma=0.10)
    ... )
    >>> accounts = [
    ...     Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
    ...     Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
    ... ]
    >>> model = FinancialModel(income, accounts)
    >>> 
    >>> # 2. Direct plotting (auto-simulates + caches)
    >>> X = np.tile([0.6, 0.4], (24, 1))
    >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42)
    >>> 
    >>> # 3. Explicit simulation (for data access)
    >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
    >>> print(result.summary())
    >>> 
    >>> # 4. Cache management
    >>> print(model.cache_info())  # {'size': 1, 'memory_mb': 9.6}
    >>> model.clear_cache()
    """
    
    def __init__(
        self,
        income: IncomeModel,
        accounts: List[Account],
        default_correlation: Optional[np.ndarray] = None,
        enable_cache: bool = True
    ):
        # Validation
        if not accounts:
            raise ValueError("accounts list cannot be empty")
        
        # Store components
        self.income = income
        self.accounts = accounts  # Canonical source (shared with portfolio)
        self.M = len(accounts)
        
        # Build return generator and portfolio executor
        # Note: self.accounts and self.portfolio.accounts are same reference
        self.returns = ReturnModel(accounts, default_correlation)
        self.portfolio = Portfolio(accounts)
        
        # Cache management
        self._cache_enabled = enable_cache
        self._simulation_cache = {}  # {hash: SimulationResult}
    
    def simulate(
        self,
        T: int,
        X: np.ndarray,
        n_sims: int = 1,
        start: Optional[date] = None,
        seed: Optional[int] = None,
        use_cache: bool = True
    ) -> SimulationResult:
        """
        Run Monte Carlo simulation with automatic caching.
        
        Executes the full pipeline:
        1. Generate income projections and contributions (uses seed)
        2. Generate correlated returns (uses seed+1 for independence)
        3. Simulate wealth dynamics under allocation policy X
        4. Package results with metadata for reproducibility
        
        Results are cached by (T, X, n_sims, start, seed) hash.
        Subsequent calls with identical parameters return cached result.
        
        Parameters
        ----------
        T : int
            Time horizon in months. Must be > 0.
        X : np.ndarray, shape (T, M)
            Allocation policy matrix.
            X[t, m] = fraction of monthly contribution A_t allocated to account m.
            Constraints: X[t, :].sum() = 1, X[t, m] >= 0 for all t, m.
        n_sims : int, default 1
            Number of Monte Carlo simulations.
            For deterministic analysis, use n_sims=1.
            For uncertainty quantification, use n_sims >= 500.
        start : Optional[date], default None
            Calendar start date for simulation.
            - If date: aligns income seasonality and calendar index
            - If None: uses date.today() as effective start
            Stored in result for reproducibility.
        seed : Optional[int], default None
            Random seed for reproducibility.
            - Income component uses seed
            - Returns component uses seed+1 (ensures independence)
            - If None, simulation is non-deterministic
        use_cache : bool, default True
            If True, returns cached result if available.
            If False, forces re-simulation.
        
        Returns
        -------
        SimulationResult
            Immutable dataclass containing:
            - wealth: (n_sims, T+1, M) trajectories
            - total_wealth: (n_sims, T+1) portfolio totals
            - contributions: (n_sims, T) or (T,) monthly contributions
            - returns: (n_sims, T, M) monthly returns
            - income: dict with fixed/variable/total breakdown
            - allocation: (T, M) policy used
            - Metadata: T, n_sims, M, start, seed, account_names
        
        Raises
        ------
        ValueError
            If X.shape != (T, M).
            If portfolio.simulate() detects invalid allocation (sum != 1, etc.).
        
        Notes
        -----
        - Seed propagation ensures statistical independence between income and returns
        - Uses portfolio.simulate(method="affine") internally for optimization readiness
        - Deterministic income (sigma=0) results in contributions.shape = (T,)
        - Stochastic income (sigma>0) results in contributions.shape = (n_sims, T)
        - Cache key computed via SHA256 hash (deterministic, collision-resistant)
        
        Examples
        --------
        >>> # Basic simulation
        >>> X = np.tile([0.7, 0.3], (24, 1))
        >>> result = model.simulate(T=24, X=X, n_sims=500, seed=42)
        >>> 
        >>> # Second call: cached (instant)
        >>> result2 = model.simulate(T=24, X=X, n_sims=500, seed=42)
        >>> assert result is result2  # same object
        >>> 
        >>> # Force re-simulation
        >>> result3 = model.simulate(T=24, X=X, n_sims=500, seed=42, use_cache=False)
        >>> 
        >>> # Access results
        >>> print(result.summary())
        >>> final_wealth = result.total_wealth[:, -1]
        >>> print(f"Mean: ${final_wealth.mean():,.0f}")
        """

        # Validate number of simulations
        if n_sims < 1 or not isinstance(n_sims, int):
            raise ValueError(f"n_sims must be positive integer, got {n_sims}")

        # Validate allocation policy shape
        if X.shape != (T, self.M):
            raise ValueError(
                f"Allocation policy X has shape {X.shape}, expected ({T}, {self.M}). "
                f"X must be a (T, M) matrix where X[t, m] is the fraction allocated "
                f"to account m at month t."
            )
        
        # Check cache
        if self._cache_enabled and use_cache:
            cache_key = self._hash_simulation_params(T, X, n_sims, start, seed)
            
            if cache_key in self._simulation_cache:
                return self._simulation_cache[cache_key]
        
        # Infer effective start date if None
        start_effective = start if start is not None else date.today()
        
        # Generate stochastic inputs with seed propagation
        
        # Income uses provided seed
        A = self.income.contributions(
            months=T,
            start=start_effective,
            seed=seed,
            output="array",
            n_sims=n_sims
        )  # (n_sims, T) or (T,)
        
        # Full income breakdown
        income_full = self.income.project(
            months=T,
            start=start_effective,
            seed=seed,
            output="array",
            n_sims=n_sims
        )  # dict with {"fixed": ..., "variable": ..., "total": ...}
        
        # Returns use seed+1 for independence
        R = self.returns.generate(
            T=T,
            n_sims=n_sims,
            seed=None if seed is None else seed + 1
        )  # (n_sims, T, M)
        
        # Simulate wealth dynamics
        portfolio_result = self.portfolio.simulate(
            A=A,
            R=R,
            X=X,
            method="affine"
        )
        
        # Package into result container
        result = SimulationResult(
            wealth=portfolio_result["wealth"],
            total_wealth=portfolio_result["total_wealth"],
            contributions=A,
            returns=R,
            income=income_full,
            allocation=X,
            T=T,
            n_sims=n_sims,
            M=self.M,
            start=start_effective,
            seed=seed,
            account_names=[acc.name for acc in self.accounts]
        )
        
        # Store in cache
        if self._cache_enabled and use_cache:
            self._simulation_cache[cache_key] = result
        
        return result
    
    def _hash_simulation_params(
        self, 
        T: int, 
        X: np.ndarray, 
        n_sims: int, 
        start: Optional[date], 
        seed: Optional[int]
    ) -> str:
        """
        Compute deterministic hash of simulation parameters.
        
        Uses SHA256 on pickled tuple of (T, X_bytes, n_sims, start, seed).
        X is converted to bytes via tobytes() for efficiency.
        
        Returns
        -------
        str
            64-character hex digest (collision-resistant).
        """
        # Convert X to bytes (more efficient than pickling full array)
        X_bytes = X.tobytes()
        
        # Tuple of parameters
        params = (T, X_bytes, n_sims, start, seed)
        
        # Serialize and hash
        params_serialized = pickle.dumps(params, protocol=pickle.HIGHEST_PROTOCOL)
        return hashlib.sha256(params_serialized).hexdigest()
    
    def clear_cache(self):
        """
        Clear simulation cache to free memory.
        
        Removes all cached SimulationResult objects. Useful when running
        large parameter sweeps or when memory is constrained.
        
        Examples
        --------
        >>> model.simulate(T=24, X=X, n_sims=500)  # cached
        >>> model.clear_cache()
        >>> model.simulate(T=24, X=X, n_sims=500)  # re-computes
        """
        self._simulation_cache.clear()
    
    def cache_info(self) -> dict:
        """
        Get cache statistics.
        
        Returns
        -------
        dict
            Keys:
            - 'size': number of cached simulations
            - 'memory_mb': approximate RAM usage (MB)
        
        Notes
        -----
        Memory estimate includes wealth, returns, and contributions arrays.
        Actual memory usage may be higher due to Python overhead.
        
        Examples
        --------
        >>> info = model.cache_info()
        >>> print(f"Cached simulations: {info['size']}")
        >>> print(f"Memory usage: {info['memory_mb']:.1f} MB")
        """
        size = len(self._simulation_cache)
        
        # Estimate memory (sum of major arrays)
        memory_bytes = sum(
            sys.getsizeof(result.wealth) +
            sys.getsizeof(result.returns) +
            sys.getsizeof(result.contributions)
            for result in self._simulation_cache.values()
        )
        
        return {
            'size': size,
            'memory_mb': memory_bytes / (1024 ** 2)
        }
    
    def optimize(
        self,
        goals: List[Union[IntermediateGoal, TerminalGoal]],
        optimizer: AllocationOptimizer,
        T_max: int = 240,
        n_sims: int = 500,
        seed: Optional[int] = None,
        start: Optional[date] = None,
        verbose: bool = True,
        search_method: str = "binary",
        **solver_kwargs
    ) -> OptimizationResult:
        """
        Find minimum-horizon allocation policy satisfying financial goals.
        
        Executes bilevel optimization:
        - Outer problem: min T (via linear search)
        - Inner problem: find feasible X* at horizon T
        
        Uses intelligent horizon estimation for terminal-only goals via
        heuristic in goals.py (avoids testing infeasible T=1,2,3...).
        
        Parameters
        ----------
        goals : List[Union[IntermediateGoal, TerminalGoal]]
            Financial objectives as chance constraints.
            - IntermediateGoal: ℙ(W_t^m ≥ b) ≥ 1-ε at fixed month t
            - TerminalGoal: ℙ(W_T^m ≥ b) ≥ 1-ε at variable horizon T
        optimizer : AllocationOptimizer
            Inner problem solver. Available implementations:
            - SAAOptimizer: Sigmoid-smoothed SAA (recommended)
            - CVaROptimizer: Risk-adjusted (requires CVXPY, stub)
        T_max : int, default 240
            Maximum search horizon (months). Typical: 120-240 (10-20 years).
        n_sims : int, default 500
            Monte Carlo scenarios for chance constraint approximation.
            Higher → better approximation, slower. Minimum: 100.
        seed : int, optional
            Random seed for reproducibility. Propagated to income (seed)
            and returns (seed+1) generators.
        start : date, optional
            Calendar start date for goal resolution. If None, uses today.
        verbose : bool, default True
            Print iteration progress (horizon testing, feasibility status).
        search_method : str, default "binary"
            Horizon search strategy:
            - "binary": Binary search (faster, ~50% fewer iterations)
            - "linear": Sequential search (safer, guaranteed to find solution)
        **solver_kwargs
            Forwarded to AllocationOptimizer.solve():
            - maxiter : int, default 1000 (SLSQP iterations)
            - gtol : float, default 1e-6 (gradient tolerance)
            - ftol : float, default 1e-9 (function tolerance)
        
        Returns
        -------
        OptimizationResult
            Dataclass containing:
            - X : np.ndarray (T*, M) - optimal allocation policy
            - T : int - minimum feasible horizon
            - objective_value : float - terminal wealth at optimum
            - feasible : bool - goal satisfaction status
            - goals : List - original goal specifications
            - goal_set : GoalSet - validated collection with accounts
            - solve_time : float - total execution time (seconds)
            - n_iterations : int - solver iterations
            - diagnostics : dict - convergence info
        
        Raises
        ------
        ValueError
            If goals list is empty.
            If T_min (from intermediate goals) > T_max.
        RuntimeError
            If no feasible solution found in [T_min, T_max].
        
        Notes
        -----
        - Optimization uses model's income/returns generators internally
        - Terminal-only goals trigger heuristic T_start estimation (saves iterations)
        - Warm start: X policy extended from previous T (faster convergence)
        - Feasibility check: exact SAA validation (non-smoothed indicators)
        - Result.goal_set contains full Account objects for downstream use
        
        Algorithm Overview
        ------------------
        1. Create GoalSeeker with optimizer
        2. Build generators: A(T,n,s) → contributions, R(T,n,s) → returns
        3. Linear search T ∈ [T_start, T_max]:
        a. If terminal-only goals: estimate T_start via heuristic
        b. Generate (A, R) scenarios for current T
        c. Solve inner problem: find X* satisfying goals
        d. Check feasibility (exact SAA)
        e. If feasible: return X*, else T++
        4. If T > T_max: raise ValueError (no solution)
        
        Examples
        --------
        >>> from finopt.src.optimization import SAAOptimizer
        >>> from finopt.src.goals import IntermediateGoal, TerminalGoal
        >>> from datetime import date
        >>> 
        >>> # Define goals
        >>> goals = [
        ...     IntermediateGoal(
        ...         month=12, 
        ...         account="Emergency",
        ...         threshold=5_500_000,
        ...         confidence=0.90
        ...     ),
        ...     TerminalGoal(
        ...         account="Housing",
        ...         threshold=20_000_000,
        ...         confidence=0.90
        ...     )
        ... ]
        >>> 
        >>> # Create optimizer
        >>> optimizer = SAAOptimizer(
        ...     n_accounts=model.M,
        ...     tau=0.1,
        ...     objective="terminal_wealth"
        ... )
        >>> 
        >>> # Optimize
        >>> result = model.optimize(
        ...     goals=goals,
        ...     optimizer=optimizer,
        ...     T_max=120,
        ...     n_sims=500,
        ...     seed=42,
        ...     start=date(2025, 1, 1),
        ...     verbose=True
        ... )
        >>> 
        >>> print(f"Optimal horizon: T*={result.T} months")
        >>> print(f"Feasible: {result.feasible}")
        >>> print(result.summary())
        >>> 
        >>> # Simulate with optimal policy for validation
        >>> sim_result = model.simulate_from_optimization(result, n_sims=1000, seed=100)
        >>> status = model.verify_goals(sim_result, goals)
        """
        from .optimization import GoalSeeker, AllocationOptimizer, OptimizationResult
        
        # Validate inputs
        if not goals:
            raise ValueError("goals list cannot be empty")
        if not hasattr(optimizer, 'solve') or not callable(optimizer.solve):
            raise TypeError(
                f"optimizer must implement AllocationOptimizer interface "
                f"(requires .solve() method), got {type(optimizer)}"
            )
        if not hasattr(optimizer, 'M') or optimizer.M != self.M:
            raise ValueError(
                f"optimizer.M={getattr(optimizer, 'M', None)} must match "
                f"model.M={self.M}"
            )
        
        # Create bilevel solver
        seeker = GoalSeeker(optimizer, T_max=T_max, verbose=verbose)
        
        # Build generators using model components
        start_date = start if start is not None else date.today()
        
        def A_generator(T: int, n: int, s: Optional[int]) -> np.ndarray:
            """Generate contribution scenarios."""
            return self.income.contributions(
                months=T,
                n_sims=n,
                seed=s,
                output="array",
                start=start_date
            )
        
        def R_generator(T: int, n: int, s: Optional[int]) -> np.ndarray:
            """Generate return scenarios."""
            return self.returns.generate(T, n_sims=n, seed=s)
        
        # Extract initial wealth
        W0 = self.portfolio.initial_wealth_vector
        
        # Execute bilevel optimization
        return seeker.seek(
            goals=goals,
            A_generator=A_generator,
            R_generator=R_generator,
            W0=W0,
            accounts=self.portfolio.accounts,
            start_date=start_date,
            n_sims=n_sims,
            seed=seed,
            search_method=search_method,
            **solver_kwargs
        )

    def simulate_from_optimization(
        self,
        opt_result: OptimizationResult,
        n_sims: int = 500,
        seed: Optional[int] = None,
        start: Optional[date] = None
    ) -> SimulationResult:
        """
        Simulate wealth using optimal policy from optimization.
        
        Convenience wrapper that extracts X* and T from OptimizationResult
        and runs full Monte Carlo simulation for analysis/validation.
        
        Parameters
        ----------
        opt_result : OptimizationResult
            Optimization output from model.optimize().
        n_sims : int, default 500
            Number of Monte Carlo scenarios. Can differ from optimization
            n_sims for higher-fidelity validation.
        seed : int, optional
            Random seed (independent from optimization seed).
        start : date, optional
            Calendar start date. If None, uses today.
        
        Returns
        -------
        SimulationResult
            Full simulation output with X=opt_result.X.
        
        Notes
        -----
        - Uses same T as optimization
        - Generates fresh scenarios (independent from optimization)
        - Useful for out-of-sample goal validation
        
        Examples
        --------
        >>> opt_result = model.optimize(goals, optimizer, T_max=120, n_sims=500, seed=42)
        >>> # Validate with 1000 fresh scenarios
        >>> sim_result = model.simulate_from_optimization(opt_result, n_sims=1000, seed=999)
        >>> status = model.verify_goals(sim_result, goals)
        >>> print(f"Goal satisfaction rate: {status}")
        """
        from .optimization import OptimizationResult
        if not isinstance(opt_result, OptimizationResult):
            raise TypeError(
                f"opt_result must be OptimizationResult, got {type(opt_result)}"
            )
        
        return self.simulate(
            T=opt_result.T,
            X=opt_result.X,
            n_sims=n_sims,
            seed=seed,
            start=start if start is not None else date.today()
        )

    def verify_goals(
        self,
        result: Union[SimulationResult, OptimizationResult],
        goals: List[Union[IntermediateGoal, TerminalGoal]],
        start: Optional[date] = None
    ) -> Dict[Union[IntermediateGoal, TerminalGoal], Dict[str, float]]:
        """
        Verify goal satisfaction in simulation/optimization result.
        
        Computes empirical violation rates and compares against goal
        confidence levels. Handles both result types automatically.
        
        Parameters
        ----------
        result : SimulationResult or OptimizationResult
            Result to validate. If OptimizationResult, automatically
            simulates with X* first.
        goals : List[Union[IntermediateGoal, TerminalGoal]]
            Goals to check.
        start : date, optional
            Calendar start date for intermediate goal resolution.
            If None, extracts from result (SimulationResult) or uses today.
        
        Returns
        -------
        dict : {Goal: metrics}
            For each goal, returns:
            - satisfied : bool
            - violation_rate : float (empirical ℙ(W < threshold))
            - required_rate : float (goal's ε = 1 - confidence)
            - margin : float (positive → satisfied)
            - median_shortfall : float
            - n_violations : int
        
        Examples
        --------
        >>> opt_result = model.optimize(goals, optimizer)
        >>> status = model.verify_goals(opt_result, goals)
        >>> 
        >>> for goal, metrics in status.items():
        ...     if not metrics['satisfied']:
        ...         print(f"VIOLATED: {goal}")
        ...         print(f"  Violation rate: {metrics['violation_rate']:.2%}")
        ...         print(f"  Shortfall: ${metrics['median_shortfall']:,.0f}")
        
        Notes
        -----
        OptimizationResult is automatically converted to SimulationResult internally
        by calling simulate_from_optimization() with 500 fresh scenarios.
        The union type accepts both for user convenience.

        For higher-fidelity validation, manually call:
        >>> sim_result = model.simulate_from_optimization(opt_result, n_sims=1000)
        >>> model.verify_goals(sim_result, goals)
        """
        from .goals import check_goals
        from .optimization import OptimizationResult

        # Handle OptimizationResult: simulate first
        if isinstance(result, OptimizationResult):
            sim_result = self.simulate_from_optimization(
                result, 
                n_sims=500,  # Default for validation
                seed=None  # Fresh scenarios
            )
        elif isinstance(result, SimulationResult):
            sim_result = result
        else:
            raise TypeError(
                f"result must be SimulationResult or OptimizationResult, "
                f"got {type(result)}"
            )
        
        # Extract start date
        start_date = start if start is not None else sim_result.start
        
        # ✅ CAMBIO CLAVE: Pasar accounts en lugar de lista de strings
        return check_goals(
            sim_result,
            goals,
            self.portfolio.accounts,  # ✅ En lugar de [acc.name for acc in self.accounts]
            start_date
        )
    
    # -----------------------------------------------------------------------
    # Unified plotting interface
    # -----------------------------------------------------------------------

    def plot(
        self,
        mode: str,
        *,
        # Simulation parameters (for modes that need to simulate)
        T: Optional[int] = None,
        X: Optional[np.ndarray] = None,
        n_sims: int = 500,
        start: Optional[date] = None,
        seed: Optional[int] = None,
        
        # Bypass: pre-computed result (optional)
        result: Optional[SimulationResult] = None,
        
        # Common plotting parameters
        figsize: Optional[tuple] = None,
        title: Optional[str] = None,
        save_path: Optional[str] = None,
        return_fig_ax: bool = False,
        
        # Cache control
        use_cache: bool = True,
        
        # Mode-specific kwargs
        **kwargs
    ):
        """
        Unified plotting interface with automatic simulation.
        
        Dispatches to specialized plotting methods based on mode. For modes
        requiring simulation ("wealth", "comparison"), automatically executes
        simulate() internally unless a pre-computed result is provided.
        Simulations are cached by default to avoid redundant computation.
        
        Parameters
        ----------
        mode : str
            Visualization type. Available modes:
            
            **Pre-simulation (no simulation needed):**
            - "income": Income streams (fixed, variable, total)
            - "contributions": Monthly contribution schedule
            - "returns": Return distributions and trajectories
            - "returns_cumulative": Cumulative return evolution
            - "returns_horizon": Risk-return by investment horizon
            
            **Simulation-based (auto-simulates if result not provided):**
            - "wealth": Portfolio dynamics (4 panels)
            - "comparison": Compare multiple strategies
        
        T : int, optional
            Time horizon for simulation-based modes.
            Required if mode in {"wealth"} and result not provided.
        X : np.ndarray, shape (T, M), optional
            Allocation policy for simulation-based modes.
            Required if mode in {"wealth"} and result not provided.
        n_sims : int, default 500
            Number of Monte Carlo simulations.
        start : date, optional
            Calendar start date. Used for:
            - Simulation: aligns income seasonality and calendar index
            - Plotting: enables calendar-based x-axis (YYYY-MM format)
            If None, numeric month indices (0, 1, 2, ...) are used.
        seed : int, optional
            Random seed for reproducibility.
        result : SimulationResult, optional
            Pre-computed simulation result. If provided, bypasses simulate()
            and uses this result directly. Useful when result already exists
            or for multiple plots from same simulation.
        figsize : tuple, optional
            Figure size (width, height). Defaults vary by mode.
        title : str, optional
            Main figure title. Auto-generated if None.
        save_path : str, optional
            Path to save figure. If None, displays interactively.
        return_fig_ax : bool, default False
            If True, returns (fig, ax) or (fig, axes) for customization.
        use_cache : bool, default True
            If True, checks cache before simulating. If False, forces
            re-simulation even if cached result exists.
        **kwargs
            Mode-specific parameters forwarded to underlying methods.
            
            **Income/Contributions modes:**
            - months : int, projection horizon
            - show_trajectories : bool
            - n_simulations : int
            - dual_axis : "auto"|True|False (income only)
            
            **Returns modes:**
            - correlation : np.ndarray
            - show_trajectories : bool
            - trajectory_alpha : float
            - show_percentiles : bool (cumulative only)
            - percentiles : tuple (cumulative only)
            - horizons : np.ndarray (horizon only)
            
            **Wealth mode:**
            - show_trajectories : bool
            - trajectory_alpha : float
            - colors : dict
            - hist_bins : int
            - hist_color : str
            
            **Comparison mode:**
            - results : dict[str, SimulationResult], required
            - metric : str
        
        Returns
        -------
        None or (fig, ax)
            If return_fig_ax=True, returns figure and axes.
            Otherwise displays plot and returns None.
        
        Raises
        ------
        ValueError
            If mode is invalid or required parameters are missing.
        
        Examples
        --------
        >>> from datetime import date
        >>> model = FinancialModel(income, accounts)
        >>> X = np.tile([0.6, 0.4], (24, 1))
        >>> 
        >>> # Pre-simulation: income streams (calendar axis)
        >>> model.plot("income", months=24, start=date(2025,1,1))
        >>> 
        >>> # Pre-simulation: return analysis (calendar axis)
        >>> model.plot("returns", T=24, n_sims=300, seed=42, start=date(2025,1,1))
        >>> model.plot("returns_cumulative", T=120, n_sims=500, start=date(2025,1,1))
        >>> 
        >>> # Simulation-based: auto-simulates + caches (calendar axis propagated)
        >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42, start=date(2025,1,1))
        >>> # Second call: instant (cached)
        >>> model.plot("wealth", T=24, X=X, n_sims=500, seed=42, title="Alt View")
        >>> 
        >>> # Bypass simulation if result exists (start extracted from result)
        >>> result = model.simulate(T=24, X=X, n_sims=500, start=date(2025,1,1))
        >>> model.plot("wealth", result=result, show_trajectories=False)
        >>> 
        >>> # Strategy comparison
        >>> result1 = model.simulate(T=24, X=X_conservative, n_sims=500)
        >>> result2 = model.simulate(T=24, X=X_aggressive, n_sims=500)
        >>> model.plot("comparison", results={"60-40": result1, "80-20": result2})
        """
        
        # Determine if mode needs simulation
        simulation_modes = {"wealth", "comparison"}
        needs_simulation = mode in simulation_modes

        if needs_simulation:
            # Option 1: result already provided (bypass)
            if result is not None:
                sim_result = result
            
            # Option 2: simulate with given parameters
            else:
                if mode == "wealth":
                    # Validate required parameters
                    if T is None or X is None:
                        raise ValueError(
                            f"mode='wealth' requires T and X parameters "
                            f"(or provide result=...)"
                        )
                    sim_result = self.simulate(
                        T=T, X=X, n_sims=n_sims, 
                        start=start, seed=seed, use_cache=use_cache
                    )
                
                elif mode == "comparison":
                    # This mode requires dict of results (special case)
                    if "results" not in kwargs:
                        raise ValueError(
                            f"mode='comparison' requires results parameter "
                            f"(dict of SimulationResult objects)"
                        )
                    sim_result = None  # no single result
        
        # Build dispatch kwargs - start with user-provided kwargs
        dispatch_kwargs = {
            "figsize": figsize,
            "title": title,
            "save_path": save_path,
            "return_fig_ax": return_fig_ax,
            **kwargs  # User kwargs first (will not be overridden)
        }
        
        # Add mode-specific parameters (only if not already in kwargs)
        if mode in ["returns", "returns_cumulative"]:
            # These modes expect T, n_sims, seed, start, correlation (optional)
            if T is not None:
                dispatch_kwargs.setdefault("T", T)
            dispatch_kwargs.setdefault("n_sims", n_sims)
            if seed is not None:
                dispatch_kwargs.setdefault("seed", seed)
            if start is not None:
                dispatch_kwargs.setdefault("start", start)
            # correlation comes from kwargs if provided
        
        elif mode == "returns_horizon":
            # This mode uses horizons array from kwargs, no T/n_sims/seed/start
            pass
        
        elif mode in ["income", "contributions"]:
            dispatch_kwargs.setdefault("months", T)
            if start is not None:
                dispatch_kwargs.setdefault("start", start)
        
        elif mode == "wealth":
            # Inject simulation result and allocation policy
            dispatch_kwargs["result"] = sim_result
            if X is not None:
                dispatch_kwargs["X"] = X
            # start will be extracted from sim_result in _plot_wealth
        
        elif mode == "comparison":
            # results already in kwargs, no additional parameters needed
            pass
        
        # Remove None values (let underlying methods use their defaults)
        dispatch_kwargs = {k: v for k, v in dispatch_kwargs.items() 
                        if v is not None}
        
        # Dispatch
        return self._dispatch_plot(mode, **dispatch_kwargs)

    def _dispatch_plot(self, mode: str, **kwargs):
        """Internal dispatcher to plotting methods."""
        _dispatch = {
            # Pre-simulation
            "income": self._plot_income,
            "contributions": self._plot_contributions,
            "returns": self._plot_returns,
            "returns_cumulative": self._plot_returns_cumulative,
            "returns_horizon": self._plot_returns_horizon,
            
            # Simulation-based
            "wealth": self._plot_wealth,
            "comparison": self._plot_comparison,
        }
        
        if mode not in _dispatch:
            valid = ", ".join(f"'{m}'" for m in _dispatch.keys())
            raise ValueError(
                f"Invalid mode '{mode}'. Valid modes: {valid}"
            )
        
        return _dispatch[mode](**kwargs)

    # -----------------------------------------------------------------------
    # Plot delegates (forward to component methods)
    # -----------------------------------------------------------------------

    def _plot_income(self, **kwargs):
        """Delegate to income.plot_income()."""
        return self.income.plot_income(**kwargs)

    def _plot_contributions(self, **kwargs):
        """Delegate to income.plot_contributions()."""
        return self.income.plot_contributions(**kwargs)

    def _plot_returns(self, **kwargs):
        """Delegate to returns.plot()."""
        return self.returns.plot(**kwargs)

    def _plot_returns_cumulative(self, **kwargs):
        """Delegate to returns.plot_cumulative()."""
        return self.returns.plot_cumulative(**kwargs)

    def _plot_returns_horizon(self, **kwargs):
        """Delegate to returns.plot_horizon_analysis()."""
        return self.returns.plot_horizon_analysis(**kwargs)

    def _plot_wealth(
        self, 
        result: SimulationResult, 
        X: Optional[np.ndarray] = None, 
        **kwargs
    ):
        """
        Delegate to portfolio.plot() with automatic start extraction.
        
        Extracts start date from SimulationResult if not explicitly provided
        in kwargs, enabling seamless calendar-based visualization.
        """
        if not isinstance(result, SimulationResult):
            raise TypeError("mode='wealth' requires result parameter")
        
        X_plot = X if X is not None else result.allocation
        portfolio_result = {
            "wealth": result.wealth,
            "total_wealth": result.total_wealth
        }
        
        # Extract start from SimulationResult if not explicitly provided
        # User-provided start in kwargs takes precedence
        if "start" not in kwargs:
            kwargs["start"] = result.start
        
        return self.portfolio.plot(portfolio_result, X_plot, **kwargs)

    def _plot_comparison(
        self,
        results: dict[str, SimulationResult],
        metric: str = "total_wealth",
        **kwargs
    ) -> Optional[tuple]:
        """
        Compare multiple strategies side-by-side.
        
        Creates 2-panel comparison:
        - Left: Mean trajectory over time
        - Right: Final distribution boxplots
        
        Parameters
        ----------
        results : dict[str, SimulationResult]
            Dictionary mapping strategy labels to simulation results.
        metric : str, default "total_wealth"
            Metric to compare. Options: "total_wealth", "wealth".
        **kwargs
            Plotting parameters (figsize, title, save_path, return_fig_ax).
        """
        if not isinstance(results, dict):
            raise TypeError("mode='comparison' requires results dict")
        
        import matplotlib.pyplot as plt
        
        figsize = kwargs.get("figsize", (14, 6))
        title = kwargs.get("title", f"Strategy Comparison: {metric}")
        save_path = kwargs.get("save_path", None)
        return_fig_ax = kwargs.get("return_fig_ax", False)
        
        fig, axes = plt.subplots(1, 2, figsize=figsize)
        
        # Panel 1: Mean trajectories
        for label, result in results.items():
            if metric == "total_wealth":
                data = result.total_wealth.mean(axis=0)
            elif metric == "wealth":
                # Sum across all accounts
                data = result.wealth.sum(axis=2).mean(axis=0)
            else:
                raise ValueError(
                    f"Unsupported metric '{metric}'. "
                    f"Valid: 'total_wealth', 'wealth'"
                )
            
            axes[0].plot(data, label=label, linewidth=2.5)
        
        axes[0].set_xlabel("Month", fontsize=11)
        axes[0].set_ylabel(metric.replace('_', ' ').title(), fontsize=11)
        axes[0].set_title("Mean Trajectories", fontsize=12, fontweight='bold')
        axes[0].legend(loc='best', fontsize=10)
        axes[0].grid(True, alpha=0.3)
        
        # Panel 2: Final distribution boxplots
        final_data = [r.total_wealth[:, -1] for r in results.values()]
        bp = axes[1].boxplot(final_data, labels=results.keys(), patch_artist=True)
        
        # Color boxes
        colors = plt.cm.Set3(np.linspace(0, 1, len(results)))
        for patch, color in zip(bp['boxes'], colors):
            patch.set_facecolor(color)
        
        axes[1].set_ylabel("Final Wealth", fontsize=11)
        axes[1].set_title("Distribution at T", fontsize=12, fontweight='bold')
        axes[1].grid(True, alpha=0.3, axis='y')
        axes[1].tick_params(axis='x', rotation=45)
        
        fig.suptitle(title, fontsize=14, fontweight='bold')
        plt.tight_layout()
        
        if save_path:
            fig.savefig(save_path, bbox_inches='tight', dpi=150)
        
        if return_fig_ax:
            return fig, axes

    def __repr__(self) -> str:
        """Human-readable string representation."""
        account_names = [acc.name for acc in self.accounts]
        cache_status = "enabled" if self._cache_enabled else "disabled"
        return (f"FinancialModel(M={self.M}, accounts={account_names}, "
                f"cache={cache_status})")


# ---------------------------------------------------------------------------
# Sanity check / Example usage (manual execution only)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    from datetime import date
    import numpy as np
    from .income import FixedIncome, VariableIncome, IncomeModel
    from .portfolio import Account
    
    print("=== FinancialModel Sanity Check ===\n")
    
    # 1. Setup
    print("1. Creating components...")
    income = IncomeModel(
        fixed=FixedIncome(base=1_400_000, annual_growth=0.03),
        variable=VariableIncome(base=200_000, sigma=0.10, seed=42)
    )
    
    accounts = [
        Account.from_annual("Emergency", annual_return=0.04, annual_volatility=0.05),
        Account.from_annual("Housing", annual_return=0.07, annual_volatility=0.12)
    ]
    
    model = FinancialModel(income, accounts)
    print(f"   {model}\n")
    
    # 2. Test caching
    print("2. Testing simulation cache...")
    T = 6
    X = np.tile([0.6, 0.4], (T, 1))
    
    import time
    
    start = time.time()
    result1 = model.simulate(T=T, X=X, n_sims=100, seed=123)
    time1 = time.time() - start
    
    start = time.time()
    result2 = model.simulate(T=T, X=X, n_sims=100, seed=123)  # cached
    time2 = time.time() - start
    
    print(f"   First call: {time1*1000:.1f} ms")
    print(f"   Second call (cached): {time2*1000:.1f} ms")
    print(f"   Speedup: {time1/time2:.0f}x")
    print(f"   Same object: {result1 is result2}")
    print(f"   Cache info: {model.cache_info()}\n")
    
    # 3. Test SimulationResult methods
    print("3. Testing SimulationResult methods...")
    summary = result1.summary(confidence=0.95)
    print("   Summary statistics:")
    print(summary)
    print()
    
    metrics = result1.metrics(account="Emergency")
    print(f"   Emergency account - Mean Sharpe: {metrics['sharpe'].mean():.3f}")
    print()
    
    # 4. Test plot() with auto-simulation
    print("4. Testing plot() with auto-simulation...")
    try:
        # This should use cached result
        model.plot("wealth", T=T, X=X, n_sims=100, seed=123, 
                  title="Test Plot", save_path=None, return_fig_ax=False)
        print("   ✓ plot('wealth') executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('wealth') failed: {e}\n")
    
    # 5. Test plot() with pre-computed result
    print("5. Testing plot() with pre-computed result...")
    try:
        model.plot("wealth", result=result1, title="From Result")
        print("   ✓ plot('wealth', result=...) executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('wealth', result=...) failed: {e}\n")
    
    # 6. Test comparison mode
    print("6. Testing comparison mode...")
    X2 = np.tile([0.4, 0.6], (T, 1))  # different allocation
    result3 = model.simulate(T=T, X=X2, n_sims=100, seed=456)
    
    try:
        model.plot("comparison", results={
            "60-40": result1,
            "40-60": result3
        })
        print("   ✓ plot('comparison') executed successfully\n")
    except Exception as e:
        print(f"   ✗ plot('comparison') failed: {e}\n")
    
    # 7. Final cache info
    print("7. Final cache info:")
    info = model.cache_info()
    print(f"   Cached simulations: {info['size']}")
    print(f"   Memory usage: {info['memory_mb']:.2f} MB\n")
    
    print("✓ All sanity checks completed!")